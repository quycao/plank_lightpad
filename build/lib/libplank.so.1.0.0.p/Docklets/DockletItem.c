/* DockletItem.c generated by valac 0.48.17, the Vala compiler
 * generated from DockletItem.vala, do not modify */

/**/
/*  Copyright (C) 2011 Robert Dyer*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <gdk/gdk.h>
#include <glib.h>
#include <gee.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>

#define PLANK_TYPE_DOCK_ELEMENT (plank_dock_element_get_type ())
#define PLANK_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElement))
#define PLANK_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))
#define PLANK_IS_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_IS_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_DOCK_ELEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))

typedef struct _PlankDockElement PlankDockElement;
typedef struct _PlankDockElementClass PlankDockElementClass;
typedef struct _PlankDockElementPrivate PlankDockElementPrivate;
typedef enum  {
	PLANK_POPUP_BUTTON_NONE = 1 << 0,
	PLANK_POPUP_BUTTON_LEFT = 1 << 1,
	PLANK_POPUP_BUTTON_MIDDLE = 1 << 2,
	PLANK_POPUP_BUTTON_RIGHT = 1 << 3
} PlankPopupButton;

#define PLANK_TYPE_POPUP_BUTTON (plank_popup_button_get_type ())
typedef enum  {
	PLANK_ANIMATION_TYPE_NONE,
	PLANK_ANIMATION_TYPE_BOUNCE,
	PLANK_ANIMATION_TYPE_DARKEN,
	PLANK_ANIMATION_TYPE_LIGHTEN
} PlankAnimationType;

#define PLANK_TYPE_ANIMATION_TYPE (plank_animation_type_get_type ())

#define PLANK_TYPE_DOCK_ITEM (plank_dock_item_get_type ())
#define PLANK_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ITEM, PlankDockItem))
#define PLANK_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ITEM, PlankDockItemClass))
#define PLANK_IS_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ITEM))
#define PLANK_IS_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ITEM))
#define PLANK_DOCK_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ITEM, PlankDockItemClass))

typedef struct _PlankDockItem PlankDockItem;
typedef struct _PlankDockItemClass PlankDockItemClass;
typedef struct _PlankDockItemPrivate PlankDockItemPrivate;

#define PLANK_TYPE_SURFACE (plank_surface_get_type ())
#define PLANK_SURFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_SURFACE, PlankSurface))
#define PLANK_SURFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_SURFACE, PlankSurfaceClass))
#define PLANK_IS_SURFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_SURFACE))
#define PLANK_IS_SURFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_SURFACE))
#define PLANK_SURFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_SURFACE, PlankSurfaceClass))

typedef struct _PlankSurface PlankSurface;
typedef struct _PlankSurfaceClass PlankSurfaceClass;

#define PLANK_TYPE_DOCKLET_ITEM (plank_docklet_item_get_type ())
#define PLANK_DOCKLET_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCKLET_ITEM, PlankDockletItem))
#define PLANK_DOCKLET_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCKLET_ITEM, PlankDockletItemClass))
#define PLANK_IS_DOCKLET_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCKLET_ITEM))
#define PLANK_IS_DOCKLET_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCKLET_ITEM))
#define PLANK_DOCKLET_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCKLET_ITEM, PlankDockletItemClass))

typedef struct _PlankDockletItem PlankDockletItem;
typedef struct _PlankDockletItemClass PlankDockletItemClass;
typedef struct _PlankDockletItemPrivate PlankDockletItemPrivate;
enum  {
	PLANK_DOCKLET_ITEM_0_PROPERTY,
	PLANK_DOCKLET_ITEM_NUM_PROPERTIES
};
static GParamSpec* plank_docklet_item_properties[PLANK_DOCKLET_ITEM_NUM_PROPERTIES];

struct _PlankDockElement {
	GObject parent_instance;
	PlankDockElementPrivate * priv;
};

struct _PlankDockElementClass {
	GObjectClass parent_class;
	PlankAnimationType (*on_clicked) (PlankDockElement* self, PlankPopupButton button, GdkModifierType mod, guint32 event_time);
	PlankAnimationType (*on_hovered) (PlankDockElement* self);
	PlankAnimationType (*on_scrolled) (PlankDockElement* self, GdkScrollDirection direction, GdkModifierType mod, guint32 event_time);
	GeeArrayList* (*get_menu_items) (PlankDockElement* self);
	gchar* (*get_drop_text) (PlankDockElement* self);
	gboolean (*can_be_removed) (PlankDockElement* self);
	gboolean (*can_accept_drop) (PlankDockElement* self, GeeArrayList* uris);
	gboolean (*accept_drop) (PlankDockElement* self, GeeArrayList* uris);
	gchar* (*unique_id) (PlankDockElement* self);
	void (*reset_buffers) (PlankDockElement* self);
};

struct _PlankDockItem {
	PlankDockElement parent_instance;
	PlankDockItemPrivate * priv;
};

struct _PlankDockItemClass {
	PlankDockElementClass parent_class;
	void (*load_from_launcher) (PlankDockItem* self);
	void (*draw_icon) (PlankDockItem* self, PlankSurface* surface);
	void (*draw_icon_fast) (PlankDockItem* self, PlankSurface* surface);
	gboolean (*is_valid) (PlankDockItem* self);
};

struct _PlankDockletItem {
	PlankDockItem parent_instance;
	PlankDockletItemPrivate * priv;
};

struct _PlankDockletItemClass {
	PlankDockItemClass parent_class;
};

static gpointer plank_docklet_item_parent_class = NULL;

GType plank_dock_element_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockElement, g_object_unref)
GType plank_popup_button_get_type (void) G_GNUC_CONST;
GType plank_animation_type_get_type (void) G_GNUC_CONST;
GType plank_dock_item_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockItem, g_object_unref)
GType plank_surface_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankSurface, g_object_unref)
GType plank_docklet_item_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockletItem, g_object_unref)
gboolean plank_dock_item_is_valid (PlankDockItem* self);
static gboolean plank_docklet_item_real_is_valid (PlankDockItem* base);
PlankDockletItem* plank_docklet_item_construct (GType object_type);
PlankDockItem* plank_dock_item_construct (GType object_type);
static GType plank_docklet_item_get_type_once (void);

static gboolean
plank_docklet_item_real_is_valid (PlankDockItem* base)
{
	PlankDockletItem * self;
	gboolean result = FALSE;
#line 24 "../lib/Docklets/DockletItem.vala"
	self = (PlankDockletItem*) base;
#line 26 "../lib/Docklets/DockletItem.vala"
	result = TRUE;
#line 26 "../lib/Docklets/DockletItem.vala"
	return result;
#line 166 "DockletItem.c"
}

PlankDockletItem*
plank_docklet_item_construct (GType object_type)
{
	PlankDockletItem * self = NULL;
#line 22 "../lib/Docklets/DockletItem.vala"
	self = (PlankDockletItem*) plank_dock_item_construct (object_type);
#line 22 "../lib/Docklets/DockletItem.vala"
	return self;
#line 177 "DockletItem.c"
}

static void
plank_docklet_item_class_init (PlankDockletItemClass * klass,
                               gpointer klass_data)
{
#line 22 "../lib/Docklets/DockletItem.vala"
	plank_docklet_item_parent_class = g_type_class_peek_parent (klass);
#line 22 "../lib/Docklets/DockletItem.vala"
	((PlankDockItemClass *) klass)->is_valid = (gboolean (*) (PlankDockItem*)) plank_docklet_item_real_is_valid;
#line 188 "DockletItem.c"
}

static void
plank_docklet_item_instance_init (PlankDockletItem * self,
                                  gpointer klass)
{
}

static GType
plank_docklet_item_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankDockletItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_docklet_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankDockletItem), 0, (GInstanceInitFunc) plank_docklet_item_instance_init, NULL };
	GType plank_docklet_item_type_id;
	plank_docklet_item_type_id = g_type_register_static (PLANK_TYPE_DOCK_ITEM, "PlankDockletItem", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	return plank_docklet_item_type_id;
}

GType
plank_docklet_item_get_type (void)
{
	static volatile gsize plank_docklet_item_type_id__volatile = 0;
	if (g_once_init_enter (&plank_docklet_item_type_id__volatile)) {
		GType plank_docklet_item_type_id;
		plank_docklet_item_type_id = plank_docklet_item_get_type_once ();
		g_once_init_leave (&plank_docklet_item_type_id__volatile, plank_docklet_item_type_id);
	}
	return plank_docklet_item_type_id__volatile;
}

