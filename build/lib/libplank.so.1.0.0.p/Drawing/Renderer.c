/* Renderer.c generated by valac 0.48.17, the Vala compiler
 * generated from Renderer.vala, do not modify */

/**/
/*  Copyright (C) 2011 Robert Dyer*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <glib.h>
#include <cairo-gobject.h>
#include <gtk/gtk.h>
#include <gdk/gdk.h>

#define PLANK_TYPE_RENDERER (plank_renderer_get_type ())
#define PLANK_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_RENDERER, PlankRenderer))
#define PLANK_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_RENDERER, PlankRendererClass))
#define PLANK_IS_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_RENDERER))
#define PLANK_IS_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_RENDERER))
#define PLANK_RENDERER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_RENDERER, PlankRendererClass))

typedef struct _PlankRenderer PlankRenderer;
typedef struct _PlankRendererClass PlankRendererClass;
typedef struct _PlankRendererPrivate PlankRendererPrivate;
enum  {
	PLANK_RENDERER_0_PROPERTY,
	PLANK_RENDERER_WIDGET_PROPERTY,
	PLANK_RENDERER_FRAME_TIME_PROPERTY,
	PLANK_RENDERER_NUM_PROPERTIES
};
static GParamSpec* plank_renderer_properties[PLANK_RENDERER_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _PlankRenderer {
	GObject parent_instance;
	PlankRendererPrivate * priv;
};

struct _PlankRendererClass {
	GObjectClass parent_class;
	gboolean (*animation_needed) (PlankRenderer* self, gint64 frame_time);
	void (*initialize_frame) (PlankRenderer* self, gint64 frame_time);
	void (*draw) (PlankRenderer* self, cairo_t* cr, gint64 frame_time);
};

struct _PlankRendererPrivate {
	GtkWidget* _widget;
	gint64 _frame_time;
	guint timer_id;
	gulong widget_realize_handler_id;
	gulong widget_draw_handler_id;
	gboolean is_updating;
};

static gint PlankRenderer_private_offset;
static gpointer plank_renderer_parent_class = NULL;

GType plank_renderer_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankRenderer, g_object_unref)
gboolean plank_renderer_animation_needed (PlankRenderer* self,
                                          gint64 frame_time);
void plank_renderer_initialize_frame (PlankRenderer* self,
                                      gint64 frame_time);
void plank_renderer_draw (PlankRenderer* self,
                          cairo_t* cr,
                          gint64 frame_time);
GtkWidget* plank_renderer_get_widget (PlankRenderer* self);
PlankRenderer* plank_renderer_construct (GType object_type,
                                         GtkWidget* widget);
static gboolean plank_renderer_real_animation_needed (PlankRenderer* self,
                                               gint64 frame_time);
static void plank_renderer_real_initialize_frame (PlankRenderer* self,
                                           gint64 frame_time);
static void plank_renderer_real_draw (PlankRenderer* self,
                               cairo_t* cr,
                               gint64 frame_time);
void plank_renderer_force_frame_time_update (PlankRenderer* self);
static void plank_renderer_set_frame_time (PlankRenderer* self,
                                    gint64 value);
void plank_renderer_animated_draw (PlankRenderer* self);
gint64 plank_renderer_get_frame_time (PlankRenderer* self);
static gboolean plank_renderer_draw_timeout (GtkWidget* widget,
                                      GdkFrameClock* frame_clock,
                                      PlankRenderer* self);
static gboolean plank_renderer_on_widget_draw (GtkWidget* widget,
                                        cairo_t* cr,
                                        PlankRenderer* self);
static void plank_renderer_on_widget_realize (GtkWidget* widget,
                                       PlankRenderer* self);
static void plank_renderer_set_widget (PlankRenderer* self,
                                GtkWidget* value);
static GObject * plank_renderer_constructor (GType type,
                                      guint n_construct_properties,
                                      GObjectConstructParam * construct_properties);
static void _plank_renderer_on_widget_realize_gtk_widget_realize (GtkWidget* _sender,
                                                           gpointer self);
static gboolean _plank_renderer_on_widget_draw_gtk_widget_draw (GtkWidget* _sender,
                                                         cairo_t* cr,
                                                         gpointer self);
static void plank_renderer_finalize (GObject * obj);
static GType plank_renderer_get_type_once (void);
static void _vala_plank_renderer_get_property (GObject * object,
                                        guint property_id,
                                        GValue * value,
                                        GParamSpec * pspec);
static void _vala_plank_renderer_set_property (GObject * object,
                                        guint property_id,
                                        const GValue * value,
                                        GParamSpec * pspec);

static inline gpointer
plank_renderer_get_instance_private (PlankRenderer* self)
{
	return G_STRUCT_MEMBER_P (self, PlankRenderer_private_offset);
}

/**
 * Creates a new animation renderer.
 */
PlankRenderer*
plank_renderer_construct (GType object_type,
                          GtkWidget* widget)
{
	PlankRenderer * self = NULL;
#line 41 "../lib/Drawing/Renderer.vala"
	g_return_val_if_fail (widget != NULL, NULL);
#line 43 "../lib/Drawing/Renderer.vala"
	self = (PlankRenderer*) g_object_new (object_type, "widget", widget, NULL);
#line 41 "../lib/Drawing/Renderer.vala"
	return self;
#line 146 "Renderer.c"
}

/**
 * Determines if animation should continue.
 *
 * @param frame_time the current time for this frame's render
 * @return if another animation frame is needed
 */
static gboolean
plank_renderer_real_animation_needed (PlankRenderer* self,
                                      gint64 frame_time)
{
	gboolean _tmp0_ = FALSE;
#line 77 "../lib/Drawing/Renderer.vala"
	g_critical ("Type `%s' does not implement abstract method `plank_renderer_animation_needed'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
#line 77 "../lib/Drawing/Renderer.vala"
	return _tmp0_;
#line 164 "Renderer.c"
}

gboolean
plank_renderer_animation_needed (PlankRenderer* self,
                                 gint64 frame_time)
{
#line 77 "../lib/Drawing/Renderer.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 77 "../lib/Drawing/Renderer.vala"
	return PLANK_RENDERER_GET_CLASS (self)->animation_needed (self, frame_time);
#line 175 "Renderer.c"
}

/**
 * Preparations which are not requiring a drawing context yet.
 *
 * @param frame_time the current time for this frame's render
 */
static void
plank_renderer_real_initialize_frame (PlankRenderer* self,
                                      gint64 frame_time)
{
#line 84 "../lib/Drawing/Renderer.vala"
	g_critical ("Type `%s' does not implement abstract method `plank_renderer_initialize_frame'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
#line 84 "../lib/Drawing/Renderer.vala"
	return;
#line 191 "Renderer.c"
}

void
plank_renderer_initialize_frame (PlankRenderer* self,
                                 gint64 frame_time)
{
#line 84 "../lib/Drawing/Renderer.vala"
	g_return_if_fail (self != NULL);
#line 84 "../lib/Drawing/Renderer.vala"
	PLANK_RENDERER_GET_CLASS (self)->initialize_frame (self, frame_time);
#line 202 "Renderer.c"
}

/**
 * Draws onto a context.
 *
 * @param cr the context to use for drawing
 */
static void
plank_renderer_real_draw (PlankRenderer* self,
                          cairo_t* cr,
                          gint64 frame_time)
{
#line 91 "../lib/Drawing/Renderer.vala"
	g_critical ("Type `%s' does not implement abstract method `plank_renderer_draw'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
#line 91 "../lib/Drawing/Renderer.vala"
	return;
#line 219 "Renderer.c"
}

void
plank_renderer_draw (PlankRenderer* self,
                     cairo_t* cr,
                     gint64 frame_time)
{
#line 91 "../lib/Drawing/Renderer.vala"
	g_return_if_fail (self != NULL);
#line 91 "../lib/Drawing/Renderer.vala"
	PLANK_RENDERER_GET_CLASS (self)->draw (self, cr, frame_time);
#line 231 "Renderer.c"
}

/**
 * Force an immediate update of the frame_time property.
 */
void
plank_renderer_force_frame_time_update (PlankRenderer* self)
{
#line 96 "../lib/Drawing/Renderer.vala"
	g_return_if_fail (self != NULL);
#line 98 "../lib/Drawing/Renderer.vala"
	plank_renderer_set_frame_time (self, g_get_monotonic_time ());
#line 244 "Renderer.c"
}

/**
 * Request re-drawing.
 */
void
plank_renderer_animated_draw (PlankRenderer* self)
{
	gboolean _tmp0_ = FALSE;
	gint64 _tmp2_;
	GtkWidget* _tmp3_;
	gint64 _tmp4_;
#line 104 "../lib/Drawing/Renderer.vala"
	g_return_if_fail (self != NULL);
#line 106 "../lib/Drawing/Renderer.vala"
	if (self->priv->is_updating) {
#line 106 "../lib/Drawing/Renderer.vala"
		_tmp0_ = TRUE;
#line 263 "Renderer.c"
	} else {
		GtkWidget* _tmp1_;
#line 106 "../lib/Drawing/Renderer.vala"
		_tmp1_ = self->priv->_widget;
#line 106 "../lib/Drawing/Renderer.vala"
		_tmp0_ = !gtk_widget_get_realized (_tmp1_);
#line 270 "Renderer.c"
	}
#line 106 "../lib/Drawing/Renderer.vala"
	if (_tmp0_) {
#line 107 "../lib/Drawing/Renderer.vala"
		return;
#line 276 "Renderer.c"
	}
#line 109 "../lib/Drawing/Renderer.vala"
	plank_renderer_force_frame_time_update (self);
#line 110 "../lib/Drawing/Renderer.vala"
	_tmp2_ = self->priv->_frame_time;
#line 110 "../lib/Drawing/Renderer.vala"
	plank_renderer_initialize_frame (self, _tmp2_);
#line 112 "../lib/Drawing/Renderer.vala"
	_tmp3_ = self->priv->_widget;
#line 112 "../lib/Drawing/Renderer.vala"
	gtk_widget_queue_draw (_tmp3_);
#line 114 "../lib/Drawing/Renderer.vala"
	_tmp4_ = self->priv->_frame_time;
#line 114 "../lib/Drawing/Renderer.vala"
	if (plank_renderer_animation_needed (self, _tmp4_)) {
#line 292 "Renderer.c"
		GdkFrameClock* frame_clock = NULL;
		GtkWidget* _tmp5_;
		GdkFrameClock* _tmp6_;
		GdkFrameClock* _tmp7_;
#line 115 "../lib/Drawing/Renderer.vala"
		_tmp5_ = self->priv->_widget;
#line 115 "../lib/Drawing/Renderer.vala"
		_tmp6_ = gtk_widget_get_frame_clock (_tmp5_);
#line 115 "../lib/Drawing/Renderer.vala"
		frame_clock = _tmp6_;
#line 116 "../lib/Drawing/Renderer.vala"
		_tmp7_ = frame_clock;
#line 116 "../lib/Drawing/Renderer.vala"
		gdk_frame_clock_begin_updating (_tmp7_);
#line 117 "../lib/Drawing/Renderer.vala"
		self->priv->is_updating = TRUE;
#line 309 "Renderer.c"
	}
}

static gboolean
plank_renderer_draw_timeout (GtkWidget* widget,
                             GdkFrameClock* frame_clock,
                             PlankRenderer* self)
{
	gint64 _tmp0_;
	gint64 _tmp1_;
	gboolean result = FALSE;
#line 122 "../lib/Drawing/Renderer.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 122 "../lib/Drawing/Renderer.vala"
	g_return_val_if_fail (widget != NULL, FALSE);
#line 122 "../lib/Drawing/Renderer.vala"
	g_return_val_if_fail (frame_clock != NULL, FALSE);
#line 124 "../lib/Drawing/Renderer.vala"
	plank_renderer_set_frame_time (self, g_get_monotonic_time ());
#line 125 "../lib/Drawing/Renderer.vala"
	_tmp0_ = self->priv->_frame_time;
#line 125 "../lib/Drawing/Renderer.vala"
	plank_renderer_initialize_frame (self, _tmp0_);
#line 126 "../lib/Drawing/Renderer.vala"
	gtk_widget_queue_draw (widget);
#line 128 "../lib/Drawing/Renderer.vala"
	_tmp1_ = self->priv->_frame_time;
#line 128 "../lib/Drawing/Renderer.vala"
	if (plank_renderer_animation_needed (self, _tmp1_)) {
#line 129 "../lib/Drawing/Renderer.vala"
		result = TRUE;
#line 129 "../lib/Drawing/Renderer.vala"
		return result;
#line 343 "Renderer.c"
	}
#line 131 "../lib/Drawing/Renderer.vala"
	gdk_frame_clock_end_updating (frame_clock);
#line 132 "../lib/Drawing/Renderer.vala"
	self->priv->is_updating = FALSE;
#line 133 "../lib/Drawing/Renderer.vala"
	result = TRUE;
#line 133 "../lib/Drawing/Renderer.vala"
	return result;
#line 353 "Renderer.c"
}

static gboolean
plank_renderer_on_widget_draw (GtkWidget* widget,
                               cairo_t* cr,
                               PlankRenderer* self)
{
	gint64 _tmp0_;
	gboolean result = FALSE;
#line 137 "../lib/Drawing/Renderer.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 137 "../lib/Drawing/Renderer.vala"
	g_return_val_if_fail (widget != NULL, FALSE);
#line 137 "../lib/Drawing/Renderer.vala"
	g_return_val_if_fail (cr != NULL, FALSE);
#line 139 "../lib/Drawing/Renderer.vala"
	_tmp0_ = self->priv->_frame_time;
#line 139 "../lib/Drawing/Renderer.vala"
	plank_renderer_draw (self, cr, _tmp0_);
#line 141 "../lib/Drawing/Renderer.vala"
	result = GDK_EVENT_PROPAGATE;
#line 141 "../lib/Drawing/Renderer.vala"
	return result;
#line 377 "Renderer.c"
}

static void
plank_renderer_on_widget_realize (GtkWidget* widget,
                                  PlankRenderer* self)
{
	gint64 _tmp0_;
#line 145 "../lib/Drawing/Renderer.vala"
	g_return_if_fail (self != NULL);
#line 145 "../lib/Drawing/Renderer.vala"
	g_return_if_fail (widget != NULL);
#line 147 "../lib/Drawing/Renderer.vala"
	plank_renderer_force_frame_time_update (self);
#line 148 "../lib/Drawing/Renderer.vala"
	_tmp0_ = self->priv->_frame_time;
#line 148 "../lib/Drawing/Renderer.vala"
	plank_renderer_initialize_frame (self, _tmp0_);
#line 150 "../lib/Drawing/Renderer.vala"
	if (self->priv->widget_realize_handler_id > 0UL) {
#line 151 "../lib/Drawing/Renderer.vala"
		g_signal_handler_disconnect ((GObject*) widget, self->priv->widget_realize_handler_id);
#line 152 "../lib/Drawing/Renderer.vala"
		self->priv->widget_realize_handler_id = 0UL;
#line 401 "Renderer.c"
	}
}

GtkWidget*
plank_renderer_get_widget (PlankRenderer* self)
{
	GtkWidget* result;
	GtkWidget* _tmp0_;
#line 28 "../lib/Drawing/Renderer.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 28 "../lib/Drawing/Renderer.vala"
	_tmp0_ = self->priv->_widget;
#line 28 "../lib/Drawing/Renderer.vala"
	result = _tmp0_;
#line 28 "../lib/Drawing/Renderer.vala"
	return result;
#line 418 "Renderer.c"
}

static gpointer
_g_object_ref0 (gpointer self)
{
#line 28 "../lib/Drawing/Renderer.vala"
	return self ? g_object_ref (self) : NULL;
#line 426 "Renderer.c"
}

static void
plank_renderer_set_widget (PlankRenderer* self,
                           GtkWidget* value)
{
	GtkWidget* old_value;
#line 28 "../lib/Drawing/Renderer.vala"
	g_return_if_fail (self != NULL);
#line 28 "../lib/Drawing/Renderer.vala"
	old_value = plank_renderer_get_widget (self);
#line 28 "../lib/Drawing/Renderer.vala"
	if (old_value != value) {
#line 440 "Renderer.c"
		GtkWidget* _tmp0_;
#line 28 "../lib/Drawing/Renderer.vala"
		_tmp0_ = _g_object_ref0 (value);
#line 28 "../lib/Drawing/Renderer.vala"
		_g_object_unref0 (self->priv->_widget);
#line 28 "../lib/Drawing/Renderer.vala"
		self->priv->_widget = _tmp0_;
#line 28 "../lib/Drawing/Renderer.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_renderer_properties[PLANK_RENDERER_WIDGET_PROPERTY]);
#line 450 "Renderer.c"
	}
}

gint64
plank_renderer_get_frame_time (PlankRenderer* self)
{
	gint64 result;
#line 31 "../lib/Drawing/Renderer.vala"
	g_return_val_if_fail (self != NULL, 0LL);
#line 31 "../lib/Drawing/Renderer.vala"
	result = self->priv->_frame_time;
#line 31 "../lib/Drawing/Renderer.vala"
	return result;
#line 464 "Renderer.c"
}

static void
plank_renderer_set_frame_time (PlankRenderer* self,
                               gint64 value)
{
#line 31 "../lib/Drawing/Renderer.vala"
	g_return_if_fail (self != NULL);
#line 31 "../lib/Drawing/Renderer.vala"
	self->priv->_frame_time = value;
#line 475 "Renderer.c"
}

static void
_plank_renderer_on_widget_realize_gtk_widget_realize (GtkWidget* _sender,
                                                      gpointer self)
{
#line 49 "../lib/Drawing/Renderer.vala"
	plank_renderer_on_widget_realize (_sender, (PlankRenderer*) self);
#line 484 "Renderer.c"
}

static gboolean
_plank_renderer_on_widget_draw_gtk_widget_draw (GtkWidget* _sender,
                                                cairo_t* cr,
                                                gpointer self)
{
	gboolean result;
	result = plank_renderer_on_widget_draw (_sender, cr, (PlankRenderer*) self);
#line 50 "../lib/Drawing/Renderer.vala"
	return result;
#line 496 "Renderer.c"
}

static GObject *
plank_renderer_constructor (GType type,
                            guint n_construct_properties,
                            GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	PlankRenderer * self;
	GtkWidget* _tmp0_;
	GtkWidget* _tmp1_;
	gulong _tmp2_;
	GtkWidget* _tmp3_;
	gulong _tmp4_;
#line 46 "../lib/Drawing/Renderer.vala"
	parent_class = G_OBJECT_CLASS (plank_renderer_parent_class);
#line 46 "../lib/Drawing/Renderer.vala"
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
#line 46 "../lib/Drawing/Renderer.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_RENDERER, PlankRenderer);
#line 48 "../lib/Drawing/Renderer.vala"
	_tmp0_ = self->priv->_widget;
#line 48 "../lib/Drawing/Renderer.vala"
	self->priv->timer_id = gtk_widget_add_tick_callback (_tmp0_, (GtkTickCallback) plank_renderer_draw_timeout, g_object_ref (self), g_object_unref);
#line 49 "../lib/Drawing/Renderer.vala"
	_tmp1_ = self->priv->_widget;
#line 49 "../lib/Drawing/Renderer.vala"
	_tmp2_ = g_signal_connect_object (_tmp1_, "realize", (GCallback) _plank_renderer_on_widget_realize_gtk_widget_realize, self, 0);
#line 49 "../lib/Drawing/Renderer.vala"
	self->priv->widget_realize_handler_id = _tmp2_;
#line 50 "../lib/Drawing/Renderer.vala"
	_tmp3_ = self->priv->_widget;
#line 50 "../lib/Drawing/Renderer.vala"
	_tmp4_ = g_signal_connect_object (_tmp3_, "draw", (GCallback) _plank_renderer_on_widget_draw_gtk_widget_draw, self, 0);
#line 50 "../lib/Drawing/Renderer.vala"
	self->priv->widget_draw_handler_id = _tmp4_;
#line 46 "../lib/Drawing/Renderer.vala"
	return obj;
#line 536 "Renderer.c"
}

static void
plank_renderer_class_init (PlankRendererClass * klass,
                           gpointer klass_data)
{
#line 26 "../lib/Drawing/Renderer.vala"
	plank_renderer_parent_class = g_type_class_peek_parent (klass);
#line 26 "../lib/Drawing/Renderer.vala"
	g_type_class_adjust_private_offset (klass, &PlankRenderer_private_offset);
#line 26 "../lib/Drawing/Renderer.vala"
	((PlankRendererClass *) klass)->animation_needed = (gboolean (*) (PlankRenderer*, gint64)) plank_renderer_real_animation_needed;
#line 26 "../lib/Drawing/Renderer.vala"
	((PlankRendererClass *) klass)->initialize_frame = (void (*) (PlankRenderer*, gint64)) plank_renderer_real_initialize_frame;
#line 26 "../lib/Drawing/Renderer.vala"
	((PlankRendererClass *) klass)->draw = (void (*) (PlankRenderer*, cairo_t*, gint64)) plank_renderer_real_draw;
#line 26 "../lib/Drawing/Renderer.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_plank_renderer_get_property;
#line 26 "../lib/Drawing/Renderer.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_plank_renderer_set_property;
#line 26 "../lib/Drawing/Renderer.vala"
	G_OBJECT_CLASS (klass)->constructor = plank_renderer_constructor;
#line 26 "../lib/Drawing/Renderer.vala"
	G_OBJECT_CLASS (klass)->finalize = plank_renderer_finalize;
#line 26 "../lib/Drawing/Renderer.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_RENDERER_WIDGET_PROPERTY, plank_renderer_properties[PLANK_RENDERER_WIDGET_PROPERTY] = g_param_spec_object ("widget", "widget", "widget", gtk_widget_get_type (), G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
#line 26 "../lib/Drawing/Renderer.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_RENDERER_FRAME_TIME_PROPERTY, plank_renderer_properties[PLANK_RENDERER_FRAME_TIME_PROPERTY] = g_param_spec_int64 ("frame-time", "frame-time", "frame-time", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_EXPLICIT_NOTIFY));
#line 565 "Renderer.c"
}

static void
plank_renderer_instance_init (PlankRenderer * self,
                              gpointer klass)
{
#line 26 "../lib/Drawing/Renderer.vala"
	self->priv = plank_renderer_get_instance_private (self);
#line 33 "../lib/Drawing/Renderer.vala"
	self->priv->timer_id = 0U;
#line 34 "../lib/Drawing/Renderer.vala"
	self->priv->widget_realize_handler_id = 0UL;
#line 35 "../lib/Drawing/Renderer.vala"
	self->priv->widget_draw_handler_id = 0UL;
#line 36 "../lib/Drawing/Renderer.vala"
	self->priv->is_updating = FALSE;
#line 582 "Renderer.c"
}

static void
plank_renderer_finalize (GObject * obj)
{
	PlankRenderer * self;
#line 26 "../lib/Drawing/Renderer.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_RENDERER, PlankRenderer);
#line 55 "../lib/Drawing/Renderer.vala"
	if (self->priv->timer_id > 0U) {
#line 593 "Renderer.c"
		GtkWidget* _tmp0_;
#line 56 "../lib/Drawing/Renderer.vala"
		_tmp0_ = self->priv->_widget;
#line 56 "../lib/Drawing/Renderer.vala"
		gtk_widget_remove_tick_callback (_tmp0_, self->priv->timer_id);
#line 57 "../lib/Drawing/Renderer.vala"
		self->priv->timer_id = 0U;
#line 601 "Renderer.c"
	}
#line 60 "../lib/Drawing/Renderer.vala"
	if (self->priv->widget_realize_handler_id > 0UL) {
#line 605 "Renderer.c"
		GtkWidget* _tmp1_;
#line 61 "../lib/Drawing/Renderer.vala"
		_tmp1_ = self->priv->_widget;
#line 61 "../lib/Drawing/Renderer.vala"
		g_signal_handler_disconnect ((GObject*) _tmp1_, self->priv->widget_realize_handler_id);
#line 62 "../lib/Drawing/Renderer.vala"
		self->priv->widget_realize_handler_id = 0UL;
#line 613 "Renderer.c"
	}
#line 65 "../lib/Drawing/Renderer.vala"
	if (self->priv->widget_draw_handler_id > 0UL) {
#line 617 "Renderer.c"
		GtkWidget* _tmp2_;
#line 66 "../lib/Drawing/Renderer.vala"
		_tmp2_ = self->priv->_widget;
#line 66 "../lib/Drawing/Renderer.vala"
		g_signal_handler_disconnect ((GObject*) _tmp2_, self->priv->widget_draw_handler_id);
#line 67 "../lib/Drawing/Renderer.vala"
		self->priv->widget_draw_handler_id = 0UL;
#line 625 "Renderer.c"
	}
#line 28 "../lib/Drawing/Renderer.vala"
	_g_object_unref0 (self->priv->_widget);
#line 26 "../lib/Drawing/Renderer.vala"
	G_OBJECT_CLASS (plank_renderer_parent_class)->finalize (obj);
#line 631 "Renderer.c"
}

/**
 * Handles animated rendering.  Uses a timer and continues requesting
 * redraws for a widget until no more animation is needed.
 */
static GType
plank_renderer_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankRendererClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_renderer_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankRenderer), 0, (GInstanceInitFunc) plank_renderer_instance_init, NULL };
	GType plank_renderer_type_id;
	plank_renderer_type_id = g_type_register_static (G_TYPE_OBJECT, "PlankRenderer", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	PlankRenderer_private_offset = g_type_add_instance_private (plank_renderer_type_id, sizeof (PlankRendererPrivate));
	return plank_renderer_type_id;
}

GType
plank_renderer_get_type (void)
{
	static volatile gsize plank_renderer_type_id__volatile = 0;
	if (g_once_init_enter (&plank_renderer_type_id__volatile)) {
		GType plank_renderer_type_id;
		plank_renderer_type_id = plank_renderer_get_type_once ();
		g_once_init_leave (&plank_renderer_type_id__volatile, plank_renderer_type_id);
	}
	return plank_renderer_type_id__volatile;
}

static void
_vala_plank_renderer_get_property (GObject * object,
                                   guint property_id,
                                   GValue * value,
                                   GParamSpec * pspec)
{
	PlankRenderer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_RENDERER, PlankRenderer);
#line 26 "../lib/Drawing/Renderer.vala"
	switch (property_id) {
#line 26 "../lib/Drawing/Renderer.vala"
		case PLANK_RENDERER_WIDGET_PROPERTY:
#line 26 "../lib/Drawing/Renderer.vala"
		g_value_set_object (value, plank_renderer_get_widget (self));
#line 26 "../lib/Drawing/Renderer.vala"
		break;
#line 26 "../lib/Drawing/Renderer.vala"
		case PLANK_RENDERER_FRAME_TIME_PROPERTY:
#line 26 "../lib/Drawing/Renderer.vala"
		g_value_set_int64 (value, plank_renderer_get_frame_time (self));
#line 26 "../lib/Drawing/Renderer.vala"
		break;
#line 682 "Renderer.c"
		default:
#line 26 "../lib/Drawing/Renderer.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 26 "../lib/Drawing/Renderer.vala"
		break;
#line 688 "Renderer.c"
	}
}

static void
_vala_plank_renderer_set_property (GObject * object,
                                   guint property_id,
                                   const GValue * value,
                                   GParamSpec * pspec)
{
	PlankRenderer * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_RENDERER, PlankRenderer);
#line 26 "../lib/Drawing/Renderer.vala"
	switch (property_id) {
#line 26 "../lib/Drawing/Renderer.vala"
		case PLANK_RENDERER_WIDGET_PROPERTY:
#line 26 "../lib/Drawing/Renderer.vala"
		plank_renderer_set_widget (self, g_value_get_object (value));
#line 26 "../lib/Drawing/Renderer.vala"
		break;
#line 26 "../lib/Drawing/Renderer.vala"
		case PLANK_RENDERER_FRAME_TIME_PROPERTY:
#line 26 "../lib/Drawing/Renderer.vala"
		plank_renderer_set_frame_time (self, g_value_get_int64 (value));
#line 26 "../lib/Drawing/Renderer.vala"
		break;
#line 714 "Renderer.c"
		default:
#line 26 "../lib/Drawing/Renderer.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 26 "../lib/Drawing/Renderer.vala"
		break;
#line 720 "Renderer.c"
	}
}

