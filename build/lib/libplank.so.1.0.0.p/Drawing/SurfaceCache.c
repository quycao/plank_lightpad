/* SurfaceCache.c generated by valac 0.48.17, the Vala compiler
 * generated from SurfaceCache.vala, do not modify */

/**/
/*  Copyright (C) 2015 Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <glib.h>
#include <gee.h>
#include <float.h>
#include <math.h>
#include "plank-internal.h"
#include <stdlib.h>
#include <string.h>
#include <gobject/gvaluecollector.h>
#include <gdk/gdk.h>

#define PLANK_TYPE_SURFACE (plank_surface_get_type ())
#define PLANK_SURFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_SURFACE, PlankSurface))
#define PLANK_SURFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_SURFACE, PlankSurfaceClass))
#define PLANK_IS_SURFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_SURFACE))
#define PLANK_IS_SURFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_SURFACE))
#define PLANK_SURFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_SURFACE, PlankSurfaceClass))

typedef struct _PlankSurface PlankSurface;
typedef struct _PlankSurfaceClass PlankSurfaceClass;
typedef PlankSurface* (*PlankDrawDataFunc) (gint width, gint height, PlankSurface* model, gconstpointer data, gpointer user_data);
typedef PlankSurface* (*PlankDrawFunc) (gint width, gint height, PlankSurface* model, PlankDrawDataFunc draw_data_func, gpointer draw_data_func_target, gpointer user_data);
typedef enum  {
	PLANK_SURFACE_CACHE_FLAGS_NONE = 0,
	PLANK_SURFACE_CACHE_FLAGS_ALLOW_DOWNSCALE = 1 << 0,
	PLANK_SURFACE_CACHE_FLAGS_ALLOW_UPSCALE = 1 << 1,
	PLANK_SURFACE_CACHE_FLAGS_ALLOW_SCALE = PLANK_SURFACE_CACHE_FLAGS_ALLOW_UPSCALE | PLANK_SURFACE_CACHE_FLAGS_ALLOW_DOWNSCALE,
	PLANK_SURFACE_CACHE_FLAGS_ADAPTIVE_SCALE = 1 << 2
} PlankSurfaceCacheFlags;

#define PLANK_TYPE_SURFACE_CACHE_FLAGS (plank_surface_cache_flags_get_type ())

#define PLANK_TYPE_SURFACE_CACHE (plank_surface_cache_get_type ())
#define PLANK_SURFACE_CACHE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_SURFACE_CACHE, PlankSurfaceCache))
#define PLANK_SURFACE_CACHE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_SURFACE_CACHE, PlankSurfaceCacheClass))
#define PLANK_IS_SURFACE_CACHE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_SURFACE_CACHE))
#define PLANK_IS_SURFACE_CACHE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_SURFACE_CACHE))
#define PLANK_SURFACE_CACHE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_SURFACE_CACHE, PlankSurfaceCacheClass))

typedef struct _PlankSurfaceCache PlankSurfaceCache;
typedef struct _PlankSurfaceCacheClass PlankSurfaceCacheClass;
typedef struct _PlankSurfaceCachePrivate PlankSurfaceCachePrivate;

#define PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO (plank_surface_cache_surface_info_get_type ())
#define PLANK_SURFACE_CACHE_SURFACE_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO, PlankSurfaceCacheSurfaceInfo))
#define PLANK_SURFACE_CACHE_SURFACE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO, PlankSurfaceCacheSurfaceInfoClass))
#define PLANK_SURFACE_CACHE_IS_SURFACE_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO))
#define PLANK_SURFACE_CACHE_IS_SURFACE_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO))
#define PLANK_SURFACE_CACHE_SURFACE_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO, PlankSurfaceCacheSurfaceInfoClass))

typedef struct _PlankSurfaceCacheSurfaceInfo PlankSurfaceCacheSurfaceInfo;
typedef struct _PlankSurfaceCacheSurfaceInfoClass PlankSurfaceCacheSurfaceInfoClass;
enum  {
	PLANK_SURFACE_CACHE_0_PROPERTY,
	PLANK_SURFACE_CACHE_G_TYPE,
	PLANK_SURFACE_CACHE_G_DUP_FUNC,
	PLANK_SURFACE_CACHE_G_DESTROY_FUNC,
	PLANK_SURFACE_CACHE_FLAGS_PROPERTY,
	PLANK_SURFACE_CACHE_NUM_PROPERTIES
};
static GParamSpec* plank_surface_cache_properties[PLANK_SURFACE_CACHE_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _plank_surface_cache_surface_info_unref0(var) ((var == NULL) ? NULL : (var = (plank_surface_cache_surface_info_unref (var), NULL)))
typedef struct _PlankSurfaceCacheSurfaceInfoPrivate PlankSurfaceCacheSurfaceInfoPrivate;
typedef struct _PlankSurfaceCacheParamSpecSurfaceInfo PlankSurfaceCacheParamSpecSurfaceInfo;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _PlankSurfaceCache {
	GObject parent_instance;
	PlankSurfaceCachePrivate * priv;
};

struct _PlankSurfaceCacheClass {
	GObjectClass parent_class;
};

struct _PlankSurfaceCachePrivate {
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	PlankSurfaceCacheFlags _flags;
	GeeTreeSet* infos;
	GeeHashMap* cache_map;
	PlankSurfaceCacheSurfaceInfo* last_info;
	GMutex cache_mutex;
	guint clean_up_timer_id;
};

struct _PlankSurfaceCacheSurfaceInfo {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PlankSurfaceCacheSurfaceInfoPrivate * priv;
	guint16 width;
	guint16 height;
	guint access_count;
	gint64 last_access_time;
	gint64 drawing_time;
	gdouble scale;
};

struct _PlankSurfaceCacheSurfaceInfoClass {
	GTypeClass parent_class;
	void (*finalize) (PlankSurfaceCacheSurfaceInfo *self);
};

struct _PlankSurfaceCacheParamSpecSurfaceInfo {
	GParamSpec parent_instance;
};

static gint PlankSurfaceCache_private_offset;
static gpointer plank_surface_cache_parent_class = NULL;
static gpointer plank_surface_cache_surface_info_parent_class = NULL;

GType plank_surface_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankSurface, g_object_unref)
GType plank_surface_cache_flags_get_type (void) G_GNUC_CONST;
GType plank_surface_cache_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankSurfaceCache, g_object_unref)
static gpointer plank_surface_cache_surface_info_ref (gpointer instance);
static void plank_surface_cache_surface_info_unref (gpointer instance);
static GParamSpec* plank_surface_cache_param_spec_surface_info (const gchar* name,
                                                         const gchar* nick,
                                                         const gchar* blurb,
                                                         GType object_type,
                                                         GParamFlags flags) G_GNUC_UNUSED;
static void plank_surface_cache_value_set_surface_info (GValue* value,
                                                 gpointer v_object) G_GNUC_UNUSED;
static void plank_surface_cache_value_take_surface_info (GValue* value,
                                                  gpointer v_object) G_GNUC_UNUSED;
static gpointer plank_surface_cache_value_get_surface_info (const GValue* value) G_GNUC_UNUSED;
static GType plank_surface_cache_surface_info_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankSurfaceCacheSurfaceInfo, plank_surface_cache_surface_info_unref)
#define PLANK_SURFACE_CACHE_MAX_CACHE_AGE ((gint64) (((5 * 60) * 1000) * 1000))
#define PLANK_SURFACE_CACHE_MIN_DRAWING_TIME ((gint64) (10 * 1000))
#define PLANK_SURFACE_CACHE_INSANE_DRAWING_TIME ((gint64) (30 * 1000))
#define PLANK_SURFACE_CACHE_ACCESS_REWARD ((gint64) (500 * 1000))
PlankSurfaceCache* plank_surface_cache_new (GType g_type,
                                            GBoxedCopyFunc g_dup_func,
                                            GDestroyNotify g_destroy_func,
                                            PlankSurfaceCacheFlags flags);
PlankSurfaceCache* plank_surface_cache_construct (GType object_type,
                                                  GType g_type,
                                                  GBoxedCopyFunc g_dup_func,
                                                  GDestroyNotify g_destroy_func,
                                                  PlankSurfaceCacheFlags flags);
PlankSurface* plank_surface_cache_get_surface (PlankSurfaceCache* self,
                                               GType g_type,
                                               GBoxedCopyFunc g_dup_func,
                                               GDestroyNotify g_destroy_func,
                                               gint width,
                                               gint height,
                                               PlankSurface* model,
                                               PlankDrawFunc draw_func,
                                               gpointer draw_func_target,
                                               PlankDrawDataFunc draw_data_func,
                                               gpointer draw_data_func_target);
static PlankSurfaceCacheSurfaceInfo* plank_surface_cache_find_match (PlankSurfaceCache* self,
                                                              guint16 width,
                                                              guint16 height,
                                                              gboolean* needs_scaling);
PlankSurface* plank_surface_scaled_copy (PlankSurface* self,
                                         gint width,
                                         gint height);
PlankSurfaceCacheFlags plank_surface_cache_get_flags (PlankSurfaceCache* self);
void plank_surface_cache_set_flags (PlankSurfaceCache* self,
                                    PlankSurfaceCacheFlags value);
static PlankSurfaceCacheSurfaceInfo* plank_surface_cache_surface_info_new (guint16 width,
                                                                    guint16 height,
                                                                    gint64 last_access_time,
                                                                    gint64 drawing_time);
static PlankSurfaceCacheSurfaceInfo* plank_surface_cache_surface_info_construct (GType object_type,
                                                                          guint16 width,
                                                                          guint16 height,
                                                                          gint64 last_access_time,
                                                                          gint64 drawing_time);
static gint plank_surface_cache_surface_info_compare_with (PlankSurfaceCacheSurfaceInfo* self,
                                                    guint16 width,
                                                    guint16 height);
void plank_surface_cache_clear (PlankSurfaceCache* self);
static void plank_surface_cache_clean_up (PlankSurfaceCache* self);
void plank_logger_verbose (const gchar* msg,
                           ...);
static guint plank_surface_cache_surface_info_hash (PlankSurfaceCacheSurfaceInfo* s);
static gint plank_surface_cache_surface_info_compare (PlankSurfaceCacheSurfaceInfo* s1,
                                               PlankSurfaceCacheSurfaceInfo* s2);
static void plank_surface_cache_surface_info_finalize (PlankSurfaceCacheSurfaceInfo * obj);
static GType plank_surface_cache_surface_info_get_type_once (void);
static GObject * plank_surface_cache_constructor (GType type,
                                           guint n_construct_properties,
                                           GObjectConstructParam * construct_properties);
static gboolean _plank_surface_cache___lambda8_ (PlankSurfaceCache* self);
static gboolean __plank_surface_cache___lambda8__gsource_func (gpointer self);
static void plank_surface_cache_finalize (GObject * obj);
static GType plank_surface_cache_get_type_once (void);
static void _vala_plank_surface_cache_get_property (GObject * object,
                                             guint property_id,
                                             GValue * value,
                                             GParamSpec * pspec);
static void _vala_plank_surface_cache_set_property (GObject * object,
                                             guint property_id,
                                             const GValue * value,
                                             GParamSpec * pspec);
static void _vala_clear_GMutex (GMutex * mutex);
static void _vala_clear_GRecMutex (GRecMutex * mutex);
static void _vala_clear_GRWLock (GRWLock * mutex);
static void _vala_clear_GCond (GCond * mutex);

/**
 * Controls some internal behaviors of a {@link Plank.SurfaceCache}
 */
static GType
plank_surface_cache_flags_get_type_once (void)
{
	static const GFlagsValue values[] = {{PLANK_SURFACE_CACHE_FLAGS_NONE, "PLANK_SURFACE_CACHE_FLAGS_NONE", "none"}, {PLANK_SURFACE_CACHE_FLAGS_ALLOW_DOWNSCALE, "PLANK_SURFACE_CACHE_FLAGS_ALLOW_DOWNSCALE", "allow-downscale"}, {PLANK_SURFACE_CACHE_FLAGS_ALLOW_UPSCALE, "PLANK_SURFACE_CACHE_FLAGS_ALLOW_UPSCALE", "allow-upscale"}, {PLANK_SURFACE_CACHE_FLAGS_ALLOW_SCALE, "PLANK_SURFACE_CACHE_FLAGS_ALLOW_SCALE", "allow-scale"}, {PLANK_SURFACE_CACHE_FLAGS_ADAPTIVE_SCALE, "PLANK_SURFACE_CACHE_FLAGS_ADAPTIVE_SCALE", "adaptive-scale"}, {0, NULL, NULL}};
	GType plank_surface_cache_flags_type_id;
	plank_surface_cache_flags_type_id = g_flags_register_static ("PlankSurfaceCacheFlags", values);
	return plank_surface_cache_flags_type_id;
}

GType
plank_surface_cache_flags_get_type (void)
{
	static volatile gsize plank_surface_cache_flags_type_id__volatile = 0;
	if (g_once_init_enter (&plank_surface_cache_flags_type_id__volatile)) {
		GType plank_surface_cache_flags_type_id;
		plank_surface_cache_flags_type_id = plank_surface_cache_flags_get_type_once ();
		g_once_init_leave (&plank_surface_cache_flags_type_id__volatile, plank_surface_cache_flags_type_id);
	}
	return plank_surface_cache_flags_type_id__volatile;
}

static inline gpointer
plank_surface_cache_get_instance_private (PlankSurfaceCache* self)
{
	return G_STRUCT_MEMBER_P (self, PlankSurfaceCache_private_offset);
}

PlankSurfaceCache*
plank_surface_cache_construct (GType object_type,
                               GType g_type,
                               GBoxedCopyFunc g_dup_func,
                               GDestroyNotify g_destroy_func,
                               PlankSurfaceCacheFlags flags)
{
	PlankSurfaceCache * self = NULL;
#line 130 "../lib/Drawing/SurfaceCache.vala"
	self = (PlankSurfaceCache*) g_object_new (object_type, "flags", flags, NULL);
#line 130 "../lib/Drawing/SurfaceCache.vala"
	self->priv->g_type = g_type;
#line 130 "../lib/Drawing/SurfaceCache.vala"
	self->priv->g_dup_func = g_dup_func;
#line 130 "../lib/Drawing/SurfaceCache.vala"
	self->priv->g_destroy_func = g_destroy_func;
#line 128 "../lib/Drawing/SurfaceCache.vala"
	return self;
#line 282 "SurfaceCache.c"
}

PlankSurfaceCache*
plank_surface_cache_new (GType g_type,
                         GBoxedCopyFunc g_dup_func,
                         GDestroyNotify g_destroy_func,
                         PlankSurfaceCacheFlags flags)
{
#line 128 "../lib/Drawing/SurfaceCache.vala"
	return plank_surface_cache_construct (PLANK_TYPE_SURFACE_CACHE, g_type, g_dup_func, g_destroy_func, flags);
#line 293 "SurfaceCache.c"
}

static gpointer
_plank_surface_cache_surface_info_ref0 (gpointer self)
{
#line 170 "../lib/Drawing/SurfaceCache.vala"
	return self ? plank_surface_cache_surface_info_ref (self) : NULL;
#line 301 "SurfaceCache.c"
}

PlankSurface*
plank_surface_cache_get_surface (PlankSurfaceCache* self,
                                 GType g_type,
                                 GBoxedCopyFunc g_dup_func,
                                 GDestroyNotify g_destroy_func,
                                 gint width,
                                 gint height,
                                 PlankSurface* model,
                                 PlankDrawFunc draw_func,
                                 gpointer draw_func_target,
                                 PlankDrawDataFunc draw_data_func,
                                 gpointer draw_data_func_target)
{
	PlankSurfaceCacheSurfaceInfo* info = NULL;
	PlankSurfaceCacheSurfaceInfo* current_info = NULL;
	PlankSurface* surface = NULL;
	gboolean needs_scaling = FALSE;
	gboolean _tmp0_ = FALSE;
	PlankSurfaceCacheSurfaceInfo* _tmp1_;
	PlankSurfaceCacheSurfaceInfo* _tmp2_;
	PlankSurfaceCacheSurfaceInfo* _tmp3_;
	PlankSurfaceCacheSurfaceInfo* _tmp4_;
	gint64 access_time = 0LL;
	PlankSurfaceCacheSurfaceInfo* _tmp5_;
	PlankSurface* _tmp14_;
	gint64 finish_time = 0LL;
	gint64 time_elapsed = 0LL;
	gboolean _tmp15_ = FALSE;
	PlankSurfaceCacheSurfaceInfo* _tmp19_;
	PlankSurfaceCacheSurfaceInfo* _tmp20_;
	guint _tmp21_;
	GeeHashMap* _tmp22_;
	PlankSurfaceCacheSurfaceInfo* _tmp23_;
	PlankSurface* _tmp24_;
	GeeTreeSet* _tmp25_;
	PlankSurfaceCacheSurfaceInfo* _tmp26_;
	PlankSurface* result = NULL;
#line 158 "../lib/Drawing/SurfaceCache.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 158 "../lib/Drawing/SurfaceCache.vala"
	g_return_val_if_fail (model != NULL, NULL);
#line 158 "../lib/Drawing/SurfaceCache.vala"
	_vala_return_val_if_fail ((width >= 0) && (height >= 0), "width >= 0 && height >= 0", NULL);
#line 161 "../lib/Drawing/SurfaceCache.vala"
	g_mutex_lock (&self->priv->cache_mutex);
#line 164 "../lib/Drawing/SurfaceCache.vala"
	current_info = NULL;
#line 165 "../lib/Drawing/SurfaceCache.vala"
	surface = NULL;
#line 166 "../lib/Drawing/SurfaceCache.vala"
	needs_scaling = FALSE;
#line 168 "../lib/Drawing/SurfaceCache.vala"
	_tmp1_ = plank_surface_cache_find_match (self, (guint16) width, (guint16) height, &_tmp0_);
#line 168 "../lib/Drawing/SurfaceCache.vala"
	needs_scaling = _tmp0_;
#line 168 "../lib/Drawing/SurfaceCache.vala"
	info = _tmp1_;
#line 169 "../lib/Drawing/SurfaceCache.vala"
	_tmp2_ = info;
#line 169 "../lib/Drawing/SurfaceCache.vala"
	self->priv->last_info = _tmp2_;
#line 170 "../lib/Drawing/SurfaceCache.vala"
	_tmp3_ = info;
#line 170 "../lib/Drawing/SurfaceCache.vala"
	_tmp4_ = _plank_surface_cache_surface_info_ref0 (_tmp3_);
#line 170 "../lib/Drawing/SurfaceCache.vala"
	_plank_surface_cache_surface_info_unref0 (current_info);
#line 170 "../lib/Drawing/SurfaceCache.vala"
	current_info = _tmp4_;
#line 172 "../lib/Drawing/SurfaceCache.vala"
	access_time = g_get_monotonic_time ();
#line 174 "../lib/Drawing/SurfaceCache.vala"
	_tmp5_ = current_info;
#line 174 "../lib/Drawing/SurfaceCache.vala"
	if (_tmp5_ != NULL) {
#line 379 "SurfaceCache.c"
		PlankSurfaceCacheSurfaceInfo* _tmp6_;
		PlankSurfaceCacheSurfaceInfo* _tmp7_;
		guint _tmp8_;
		GeeHashMap* _tmp9_;
		PlankSurfaceCacheSurfaceInfo* _tmp10_;
		gpointer _tmp11_;
#line 175 "../lib/Drawing/SurfaceCache.vala"
		_tmp6_ = current_info;
#line 175 "../lib/Drawing/SurfaceCache.vala"
		_tmp6_->last_access_time = access_time;
#line 176 "../lib/Drawing/SurfaceCache.vala"
		_tmp7_ = current_info;
#line 176 "../lib/Drawing/SurfaceCache.vala"
		_tmp8_ = _tmp7_->access_count;
#line 176 "../lib/Drawing/SurfaceCache.vala"
		_tmp7_->access_count = _tmp8_ + 1;
#line 177 "../lib/Drawing/SurfaceCache.vala"
		_tmp9_ = self->priv->cache_map;
#line 177 "../lib/Drawing/SurfaceCache.vala"
		_tmp10_ = current_info;
#line 177 "../lib/Drawing/SurfaceCache.vala"
		_tmp11_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp9_, _tmp10_);
#line 177 "../lib/Drawing/SurfaceCache.vala"
		_g_object_unref0 (surface);
#line 177 "../lib/Drawing/SurfaceCache.vala"
		surface = (PlankSurface*) _tmp11_;
#line 179 "../lib/Drawing/SurfaceCache.vala"
		g_mutex_unlock (&self->priv->cache_mutex);
#line 181 "../lib/Drawing/SurfaceCache.vala"
		if (needs_scaling) {
#line 410 "SurfaceCache.c"
			PlankSurface* _tmp12_;
			PlankSurface* _tmp13_;
#line 182 "../lib/Drawing/SurfaceCache.vala"
			_tmp12_ = surface;
#line 182 "../lib/Drawing/SurfaceCache.vala"
			_tmp13_ = plank_surface_scaled_copy (_tmp12_, width, height);
#line 182 "../lib/Drawing/SurfaceCache.vala"
			result = _tmp13_;
#line 182 "../lib/Drawing/SurfaceCache.vala"
			_g_object_unref0 (surface);
#line 182 "../lib/Drawing/SurfaceCache.vala"
			_plank_surface_cache_surface_info_unref0 (current_info);
#line 182 "../lib/Drawing/SurfaceCache.vala"
			return result;
#line 425 "SurfaceCache.c"
		} else {
#line 184 "../lib/Drawing/SurfaceCache.vala"
			result = surface;
#line 184 "../lib/Drawing/SurfaceCache.vala"
			_plank_surface_cache_surface_info_unref0 (current_info);
#line 184 "../lib/Drawing/SurfaceCache.vala"
			return result;
#line 433 "SurfaceCache.c"
		}
	}
#line 187 "../lib/Drawing/SurfaceCache.vala"
	_tmp14_ = draw_func (width, height, model, draw_data_func, draw_data_func_target, draw_func_target);
#line 187 "../lib/Drawing/SurfaceCache.vala"
	_g_object_unref0 (surface);
#line 187 "../lib/Drawing/SurfaceCache.vala"
	surface = _tmp14_;
#line 189 "../lib/Drawing/SurfaceCache.vala"
	finish_time = g_get_monotonic_time ();
#line 190 "../lib/Drawing/SurfaceCache.vala"
	time_elapsed = finish_time - access_time;
#line 195 "../lib/Drawing/SurfaceCache.vala"
	if (time_elapsed >= PLANK_SURFACE_CACHE_INSANE_DRAWING_TIME) {
#line 448 "SurfaceCache.c"
		PlankSurfaceCacheFlags _tmp16_;
#line 195 "../lib/Drawing/SurfaceCache.vala"
		_tmp16_ = self->priv->_flags;
#line 195 "../lib/Drawing/SurfaceCache.vala"
		_tmp15_ = _tmp16_ == PLANK_SURFACE_CACHE_FLAGS_NONE;
#line 454 "SurfaceCache.c"
	} else {
#line 195 "../lib/Drawing/SurfaceCache.vala"
		_tmp15_ = FALSE;
#line 458 "SurfaceCache.c"
	}
#line 195 "../lib/Drawing/SurfaceCache.vala"
	if (_tmp15_) {
#line 462 "SurfaceCache.c"
		PlankSurface* _tmp17_;
		gchar* _tmp18_;
#line 196 "../lib/Drawing/SurfaceCache.vala"
		g_warning ("Creating surface took WAY TOO LONG (%" G_GINT64_FORMAT "ms), enabled downscaling for this cache!", time_elapsed / 1000);
#line 197 "../lib/Drawing/SurfaceCache.vala"
		plank_surface_cache_set_flags (self, PLANK_SURFACE_CACHE_FLAGS_ALLOW_DOWNSCALE);
#line 198 "../lib/Drawing/SurfaceCache.vala"
		_tmp17_ = surface;
#line 198 "../lib/Drawing/SurfaceCache.vala"
		_tmp18_ = g_strdup (PLANK_SURFACE_STATS_DRAWING_TIME_EXCEEDED);
#line 198 "../lib/Drawing/SurfaceCache.vala"
		g_object_set_qdata_full ((GObject*) _tmp17_, plank_quark_surface_stats, _tmp18_, g_free);
#line 475 "SurfaceCache.c"
	}
#line 201 "../lib/Drawing/SurfaceCache.vala"
	_tmp19_ = plank_surface_cache_surface_info_new ((guint16) width, (guint16) height, finish_time, time_elapsed);
#line 201 "../lib/Drawing/SurfaceCache.vala"
	_plank_surface_cache_surface_info_unref0 (current_info);
#line 201 "../lib/Drawing/SurfaceCache.vala"
	current_info = _tmp19_;
#line 202 "../lib/Drawing/SurfaceCache.vala"
	_tmp20_ = current_info;
#line 202 "../lib/Drawing/SurfaceCache.vala"
	_tmp21_ = _tmp20_->access_count;
#line 202 "../lib/Drawing/SurfaceCache.vala"
	_tmp20_->access_count = _tmp21_ + 1;
#line 204 "../lib/Drawing/SurfaceCache.vala"
	_tmp22_ = self->priv->cache_map;
#line 204 "../lib/Drawing/SurfaceCache.vala"
	_tmp23_ = current_info;
#line 204 "../lib/Drawing/SurfaceCache.vala"
	_tmp24_ = surface;
#line 204 "../lib/Drawing/SurfaceCache.vala"
	gee_abstract_map_set ((GeeAbstractMap*) _tmp22_, _tmp23_, _tmp24_);
#line 205 "../lib/Drawing/SurfaceCache.vala"
	_tmp25_ = self->priv->infos;
#line 205 "../lib/Drawing/SurfaceCache.vala"
	_tmp26_ = current_info;
#line 205 "../lib/Drawing/SurfaceCache.vala"
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp25_, _tmp26_);
#line 207 "../lib/Drawing/SurfaceCache.vala"
	g_mutex_unlock (&self->priv->cache_mutex);
#line 209 "../lib/Drawing/SurfaceCache.vala"
	result = surface;
#line 209 "../lib/Drawing/SurfaceCache.vala"
	_plank_surface_cache_surface_info_unref0 (current_info);
#line 209 "../lib/Drawing/SurfaceCache.vala"
	return result;
#line 511 "SurfaceCache.c"
}

static PlankSurfaceCacheSurfaceInfo*
plank_surface_cache_find_match (PlankSurfaceCache* self,
                                guint16 width,
                                guint16 height,
                                gboolean* needs_scaling)
{
	gboolean _vala_needs_scaling = FALSE;
	GeeTreeSet* _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	PlankSurfaceCacheSurfaceInfo* info = NULL;
	PlankSurfaceCacheSurfaceInfo* _tmp3_;
	GeeBidirIterator* infos_it = NULL;
	PlankSurfaceCacheSurfaceInfo* _tmp21_;
	gboolean _tmp27_ = FALSE;
	PlankSurfaceCacheSurfaceInfo* _tmp28_;
	PlankSurfaceCacheSurfaceInfo* result = NULL;
#line 212 "../lib/Drawing/SurfaceCache.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 214 "../lib/Drawing/SurfaceCache.vala"
	_vala_needs_scaling = FALSE;
#line 216 "../lib/Drawing/SurfaceCache.vala"
	_tmp0_ = self->priv->infos;
#line 216 "../lib/Drawing/SurfaceCache.vala"
	_tmp1_ = gee_collection_get_is_empty ((GeeCollection*) _tmp0_);
#line 216 "../lib/Drawing/SurfaceCache.vala"
	_tmp2_ = _tmp1_;
#line 216 "../lib/Drawing/SurfaceCache.vala"
	if (_tmp2_) {
#line 217 "../lib/Drawing/SurfaceCache.vala"
		result = NULL;
#line 217 "../lib/Drawing/SurfaceCache.vala"
		if (needs_scaling) {
#line 217 "../lib/Drawing/SurfaceCache.vala"
			*needs_scaling = _vala_needs_scaling;
#line 549 "SurfaceCache.c"
		}
#line 217 "../lib/Drawing/SurfaceCache.vala"
		return result;
#line 553 "SurfaceCache.c"
	}
#line 221 "../lib/Drawing/SurfaceCache.vala"
	_tmp3_ = self->priv->last_info;
#line 221 "../lib/Drawing/SurfaceCache.vala"
	if (_tmp3_ != NULL) {
#line 559 "SurfaceCache.c"
		PlankSurfaceCacheSurfaceInfo* _tmp4_;
		gboolean _tmp5_ = FALSE;
		PlankSurfaceCacheSurfaceInfo* _tmp6_;
		gboolean _tmp9_ = FALSE;
		gboolean _tmp10_ = FALSE;
		PlankSurfaceCacheFlags _tmp11_;
		gboolean _tmp15_ = FALSE;
		gboolean _tmp16_ = FALSE;
		PlankSurfaceCacheFlags _tmp17_;
#line 222 "../lib/Drawing/SurfaceCache.vala"
		_tmp4_ = self->priv->last_info;
#line 222 "../lib/Drawing/SurfaceCache.vala"
		info = _tmp4_;
#line 223 "../lib/Drawing/SurfaceCache.vala"
		_tmp6_ = info;
#line 223 "../lib/Drawing/SurfaceCache.vala"
		if (_tmp6_->width == width) {
#line 577 "SurfaceCache.c"
			PlankSurfaceCacheSurfaceInfo* _tmp7_;
#line 223 "../lib/Drawing/SurfaceCache.vala"
			_tmp7_ = info;
#line 223 "../lib/Drawing/SurfaceCache.vala"
			_tmp5_ = _tmp7_->height == height;
#line 583 "SurfaceCache.c"
		} else {
#line 223 "../lib/Drawing/SurfaceCache.vala"
			_tmp5_ = FALSE;
#line 587 "SurfaceCache.c"
		}
#line 223 "../lib/Drawing/SurfaceCache.vala"
		if (_tmp5_) {
#line 591 "SurfaceCache.c"
			PlankSurfaceCacheSurfaceInfo* _tmp8_;
#line 224 "../lib/Drawing/SurfaceCache.vala"
			_tmp8_ = info;
#line 224 "../lib/Drawing/SurfaceCache.vala"
			result = _tmp8_;
#line 224 "../lib/Drawing/SurfaceCache.vala"
			if (needs_scaling) {
#line 224 "../lib/Drawing/SurfaceCache.vala"
				*needs_scaling = _vala_needs_scaling;
#line 601 "SurfaceCache.c"
			}
#line 224 "../lib/Drawing/SurfaceCache.vala"
			return result;
#line 605 "SurfaceCache.c"
		}
#line 226 "../lib/Drawing/SurfaceCache.vala"
		_tmp11_ = self->priv->_flags;
#line 226 "../lib/Drawing/SurfaceCache.vala"
		if ((_tmp11_ & PLANK_SURFACE_CACHE_FLAGS_ALLOW_DOWNSCALE) != 0) {
#line 611 "SurfaceCache.c"
			PlankSurfaceCacheSurfaceInfo* _tmp12_;
#line 227 "../lib/Drawing/SurfaceCache.vala"
			_tmp12_ = info;
#line 227 "../lib/Drawing/SurfaceCache.vala"
			_tmp10_ = _tmp12_->width > width;
#line 617 "SurfaceCache.c"
		} else {
#line 226 "../lib/Drawing/SurfaceCache.vala"
			_tmp10_ = FALSE;
#line 621 "SurfaceCache.c"
		}
#line 226 "../lib/Drawing/SurfaceCache.vala"
		if (_tmp10_) {
#line 625 "SurfaceCache.c"
			PlankSurfaceCacheSurfaceInfo* _tmp13_;
#line 227 "../lib/Drawing/SurfaceCache.vala"
			_tmp13_ = info;
#line 227 "../lib/Drawing/SurfaceCache.vala"
			_tmp9_ = _tmp13_->height > height;
#line 631 "SurfaceCache.c"
		} else {
#line 226 "../lib/Drawing/SurfaceCache.vala"
			_tmp9_ = FALSE;
#line 635 "SurfaceCache.c"
		}
#line 226 "../lib/Drawing/SurfaceCache.vala"
		if (_tmp9_) {
#line 639 "SurfaceCache.c"
			PlankSurfaceCacheSurfaceInfo* _tmp14_;
#line 228 "../lib/Drawing/SurfaceCache.vala"
			_vala_needs_scaling = TRUE;
#line 229 "../lib/Drawing/SurfaceCache.vala"
			_tmp14_ = info;
#line 229 "../lib/Drawing/SurfaceCache.vala"
			result = _tmp14_;
#line 229 "../lib/Drawing/SurfaceCache.vala"
			if (needs_scaling) {
#line 229 "../lib/Drawing/SurfaceCache.vala"
				*needs_scaling = _vala_needs_scaling;
#line 651 "SurfaceCache.c"
			}
#line 229 "../lib/Drawing/SurfaceCache.vala"
			return result;
#line 655 "SurfaceCache.c"
		}
#line 232 "../lib/Drawing/SurfaceCache.vala"
		_tmp17_ = self->priv->_flags;
#line 232 "../lib/Drawing/SurfaceCache.vala"
		if ((_tmp17_ & PLANK_SURFACE_CACHE_FLAGS_ALLOW_UPSCALE) != 0) {
#line 661 "SurfaceCache.c"
			PlankSurfaceCacheSurfaceInfo* _tmp18_;
#line 233 "../lib/Drawing/SurfaceCache.vala"
			_tmp18_ = info;
#line 233 "../lib/Drawing/SurfaceCache.vala"
			_tmp16_ = _tmp18_->width < width;
#line 667 "SurfaceCache.c"
		} else {
#line 232 "../lib/Drawing/SurfaceCache.vala"
			_tmp16_ = FALSE;
#line 671 "SurfaceCache.c"
		}
#line 232 "../lib/Drawing/SurfaceCache.vala"
		if (_tmp16_) {
#line 675 "SurfaceCache.c"
			PlankSurfaceCacheSurfaceInfo* _tmp19_;
#line 233 "../lib/Drawing/SurfaceCache.vala"
			_tmp19_ = info;
#line 233 "../lib/Drawing/SurfaceCache.vala"
			_tmp15_ = _tmp19_->height < height;
#line 681 "SurfaceCache.c"
		} else {
#line 232 "../lib/Drawing/SurfaceCache.vala"
			_tmp15_ = FALSE;
#line 685 "SurfaceCache.c"
		}
#line 232 "../lib/Drawing/SurfaceCache.vala"
		if (_tmp15_) {
#line 689 "SurfaceCache.c"
			PlankSurfaceCacheSurfaceInfo* _tmp20_;
#line 234 "../lib/Drawing/SurfaceCache.vala"
			_vala_needs_scaling = TRUE;
#line 235 "../lib/Drawing/SurfaceCache.vala"
			_tmp20_ = info;
#line 235 "../lib/Drawing/SurfaceCache.vala"
			result = _tmp20_;
#line 235 "../lib/Drawing/SurfaceCache.vala"
			if (needs_scaling) {
#line 235 "../lib/Drawing/SurfaceCache.vala"
				*needs_scaling = _vala_needs_scaling;
#line 701 "SurfaceCache.c"
			}
#line 235 "../lib/Drawing/SurfaceCache.vala"
			return result;
#line 705 "SurfaceCache.c"
		}
	}
#line 240 "../lib/Drawing/SurfaceCache.vala"
	_tmp21_ = self->priv->last_info;
#line 240 "../lib/Drawing/SurfaceCache.vala"
	if (_tmp21_ != NULL) {
#line 712 "SurfaceCache.c"
		GeeTreeSet* _tmp22_;
		PlankSurfaceCacheSurfaceInfo* _tmp23_;
		GeeIterator* _tmp24_;
#line 241 "../lib/Drawing/SurfaceCache.vala"
		_tmp22_ = self->priv->infos;
#line 241 "../lib/Drawing/SurfaceCache.vala"
		_tmp23_ = self->priv->last_info;
#line 241 "../lib/Drawing/SurfaceCache.vala"
		_tmp24_ = gee_abstract_sorted_set_iterator_at ((GeeAbstractSortedSet*) _tmp22_, _tmp23_);
#line 241 "../lib/Drawing/SurfaceCache.vala"
		_g_object_unref0 (infos_it);
#line 241 "../lib/Drawing/SurfaceCache.vala"
		infos_it = G_TYPE_CHECK_INSTANCE_CAST (_tmp24_, GEE_TYPE_BIDIR_ITERATOR, GeeBidirIterator);
#line 726 "SurfaceCache.c"
	} else {
		GeeTreeSet* _tmp25_;
		GeeBidirIterator* _tmp26_;
#line 243 "../lib/Drawing/SurfaceCache.vala"
		_tmp25_ = self->priv->infos;
#line 243 "../lib/Drawing/SurfaceCache.vala"
		_tmp26_ = gee_abstract_bidir_sorted_set_bidir_iterator ((GeeAbstractBidirSortedSet*) _tmp25_);
#line 243 "../lib/Drawing/SurfaceCache.vala"
		_g_object_unref0 (infos_it);
#line 243 "../lib/Drawing/SurfaceCache.vala"
		infos_it = _tmp26_;
#line 738 "SurfaceCache.c"
	}
#line 245 "../lib/Drawing/SurfaceCache.vala"
	_tmp28_ = self->priv->last_info;
#line 245 "../lib/Drawing/SurfaceCache.vala"
	if (_tmp28_ != NULL) {
#line 744 "SurfaceCache.c"
		PlankSurfaceCacheSurfaceInfo* _tmp29_;
#line 245 "../lib/Drawing/SurfaceCache.vala"
		_tmp29_ = self->priv->last_info;
#line 245 "../lib/Drawing/SurfaceCache.vala"
		_tmp27_ = plank_surface_cache_surface_info_compare_with (_tmp29_, width, height) > 0;
#line 750 "SurfaceCache.c"
	} else {
#line 245 "../lib/Drawing/SurfaceCache.vala"
		_tmp27_ = FALSE;
#line 754 "SurfaceCache.c"
	}
#line 245 "../lib/Drawing/SurfaceCache.vala"
	if (_tmp27_) {
#line 246 "../lib/Drawing/SurfaceCache.vala"
		while (TRUE) {
#line 760 "SurfaceCache.c"
			GeeBidirIterator* _tmp30_;
			GeeBidirIterator* _tmp31_;
			gpointer _tmp32_;
			gboolean _tmp33_ = FALSE;
			PlankSurfaceCacheSurfaceInfo* _tmp34_;
			gboolean _tmp37_ = FALSE;
			gboolean _tmp38_ = FALSE;
			PlankSurfaceCacheFlags _tmp39_;
			gboolean _tmp43_ = FALSE;
			gboolean _tmp44_ = FALSE;
			PlankSurfaceCacheFlags _tmp45_;
#line 246 "../lib/Drawing/SurfaceCache.vala"
			_tmp30_ = infos_it;
#line 246 "../lib/Drawing/SurfaceCache.vala"
			if (!gee_bidir_iterator_previous (_tmp30_)) {
#line 246 "../lib/Drawing/SurfaceCache.vala"
				break;
#line 778 "SurfaceCache.c"
			}
#line 247 "../lib/Drawing/SurfaceCache.vala"
			_tmp31_ = infos_it;
#line 247 "../lib/Drawing/SurfaceCache.vala"
			_tmp32_ = gee_iterator_get ((GeeIterator*) _tmp31_);
#line 247 "../lib/Drawing/SurfaceCache.vala"
			info = (PlankSurfaceCacheSurfaceInfo*) _tmp32_;
#line 249 "../lib/Drawing/SurfaceCache.vala"
			_tmp34_ = info;
#line 249 "../lib/Drawing/SurfaceCache.vala"
			if (_tmp34_->width == width) {
#line 790 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp35_;
#line 249 "../lib/Drawing/SurfaceCache.vala"
				_tmp35_ = info;
#line 249 "../lib/Drawing/SurfaceCache.vala"
				_tmp33_ = _tmp35_->height == height;
#line 796 "SurfaceCache.c"
			} else {
#line 249 "../lib/Drawing/SurfaceCache.vala"
				_tmp33_ = FALSE;
#line 800 "SurfaceCache.c"
			}
#line 249 "../lib/Drawing/SurfaceCache.vala"
			if (_tmp33_) {
#line 804 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp36_;
#line 250 "../lib/Drawing/SurfaceCache.vala"
				_tmp36_ = info;
#line 250 "../lib/Drawing/SurfaceCache.vala"
				result = _tmp36_;
#line 250 "../lib/Drawing/SurfaceCache.vala"
				_g_object_unref0 (infos_it);
#line 250 "../lib/Drawing/SurfaceCache.vala"
				if (needs_scaling) {
#line 250 "../lib/Drawing/SurfaceCache.vala"
					*needs_scaling = _vala_needs_scaling;
#line 816 "SurfaceCache.c"
				}
#line 250 "../lib/Drawing/SurfaceCache.vala"
				return result;
#line 820 "SurfaceCache.c"
			}
#line 252 "../lib/Drawing/SurfaceCache.vala"
			_tmp39_ = self->priv->_flags;
#line 252 "../lib/Drawing/SurfaceCache.vala"
			if ((_tmp39_ & PLANK_SURFACE_CACHE_FLAGS_ALLOW_DOWNSCALE) != 0) {
#line 826 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp40_;
#line 253 "../lib/Drawing/SurfaceCache.vala"
				_tmp40_ = info;
#line 253 "../lib/Drawing/SurfaceCache.vala"
				_tmp38_ = _tmp40_->width > width;
#line 832 "SurfaceCache.c"
			} else {
#line 252 "../lib/Drawing/SurfaceCache.vala"
				_tmp38_ = FALSE;
#line 836 "SurfaceCache.c"
			}
#line 252 "../lib/Drawing/SurfaceCache.vala"
			if (_tmp38_) {
#line 840 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp41_;
#line 253 "../lib/Drawing/SurfaceCache.vala"
				_tmp41_ = info;
#line 253 "../lib/Drawing/SurfaceCache.vala"
				_tmp37_ = _tmp41_->height > height;
#line 846 "SurfaceCache.c"
			} else {
#line 252 "../lib/Drawing/SurfaceCache.vala"
				_tmp37_ = FALSE;
#line 850 "SurfaceCache.c"
			}
#line 252 "../lib/Drawing/SurfaceCache.vala"
			if (_tmp37_) {
#line 854 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp42_;
#line 254 "../lib/Drawing/SurfaceCache.vala"
				_vala_needs_scaling = TRUE;
#line 255 "../lib/Drawing/SurfaceCache.vala"
				_tmp42_ = info;
#line 255 "../lib/Drawing/SurfaceCache.vala"
				result = _tmp42_;
#line 255 "../lib/Drawing/SurfaceCache.vala"
				_g_object_unref0 (infos_it);
#line 255 "../lib/Drawing/SurfaceCache.vala"
				if (needs_scaling) {
#line 255 "../lib/Drawing/SurfaceCache.vala"
					*needs_scaling = _vala_needs_scaling;
#line 868 "SurfaceCache.c"
				}
#line 255 "../lib/Drawing/SurfaceCache.vala"
				return result;
#line 872 "SurfaceCache.c"
			}
#line 258 "../lib/Drawing/SurfaceCache.vala"
			_tmp45_ = self->priv->_flags;
#line 258 "../lib/Drawing/SurfaceCache.vala"
			if ((_tmp45_ & PLANK_SURFACE_CACHE_FLAGS_ALLOW_UPSCALE) != 0) {
#line 878 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp46_;
#line 259 "../lib/Drawing/SurfaceCache.vala"
				_tmp46_ = info;
#line 259 "../lib/Drawing/SurfaceCache.vala"
				_tmp44_ = _tmp46_->width < width;
#line 884 "SurfaceCache.c"
			} else {
#line 258 "../lib/Drawing/SurfaceCache.vala"
				_tmp44_ = FALSE;
#line 888 "SurfaceCache.c"
			}
#line 258 "../lib/Drawing/SurfaceCache.vala"
			if (_tmp44_) {
#line 892 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp47_;
#line 259 "../lib/Drawing/SurfaceCache.vala"
				_tmp47_ = info;
#line 259 "../lib/Drawing/SurfaceCache.vala"
				_tmp43_ = _tmp47_->height < height;
#line 898 "SurfaceCache.c"
			} else {
#line 258 "../lib/Drawing/SurfaceCache.vala"
				_tmp43_ = FALSE;
#line 902 "SurfaceCache.c"
			}
#line 258 "../lib/Drawing/SurfaceCache.vala"
			if (_tmp43_) {
#line 906 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp48_;
#line 260 "../lib/Drawing/SurfaceCache.vala"
				_vala_needs_scaling = TRUE;
#line 261 "../lib/Drawing/SurfaceCache.vala"
				_tmp48_ = info;
#line 261 "../lib/Drawing/SurfaceCache.vala"
				result = _tmp48_;
#line 261 "../lib/Drawing/SurfaceCache.vala"
				_g_object_unref0 (infos_it);
#line 261 "../lib/Drawing/SurfaceCache.vala"
				if (needs_scaling) {
#line 261 "../lib/Drawing/SurfaceCache.vala"
					*needs_scaling = _vala_needs_scaling;
#line 920 "SurfaceCache.c"
				}
#line 261 "../lib/Drawing/SurfaceCache.vala"
				return result;
#line 924 "SurfaceCache.c"
			}
		}
	} else {
#line 265 "../lib/Drawing/SurfaceCache.vala"
		while (TRUE) {
#line 930 "SurfaceCache.c"
			GeeBidirIterator* _tmp49_;
			GeeBidirIterator* _tmp50_;
			gpointer _tmp51_;
			gboolean _tmp52_ = FALSE;
			PlankSurfaceCacheSurfaceInfo* _tmp53_;
			gboolean _tmp56_ = FALSE;
			gboolean _tmp57_ = FALSE;
			PlankSurfaceCacheFlags _tmp58_;
			gboolean _tmp62_ = FALSE;
			gboolean _tmp63_ = FALSE;
			PlankSurfaceCacheFlags _tmp64_;
#line 265 "../lib/Drawing/SurfaceCache.vala"
			_tmp49_ = infos_it;
#line 265 "../lib/Drawing/SurfaceCache.vala"
			if (!gee_iterator_next ((GeeIterator*) _tmp49_)) {
#line 265 "../lib/Drawing/SurfaceCache.vala"
				break;
#line 948 "SurfaceCache.c"
			}
#line 266 "../lib/Drawing/SurfaceCache.vala"
			_tmp50_ = infos_it;
#line 266 "../lib/Drawing/SurfaceCache.vala"
			_tmp51_ = gee_iterator_get ((GeeIterator*) _tmp50_);
#line 266 "../lib/Drawing/SurfaceCache.vala"
			info = (PlankSurfaceCacheSurfaceInfo*) _tmp51_;
#line 268 "../lib/Drawing/SurfaceCache.vala"
			_tmp53_ = info;
#line 268 "../lib/Drawing/SurfaceCache.vala"
			if (_tmp53_->width == width) {
#line 960 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp54_;
#line 268 "../lib/Drawing/SurfaceCache.vala"
				_tmp54_ = info;
#line 268 "../lib/Drawing/SurfaceCache.vala"
				_tmp52_ = _tmp54_->height == height;
#line 966 "SurfaceCache.c"
			} else {
#line 268 "../lib/Drawing/SurfaceCache.vala"
				_tmp52_ = FALSE;
#line 970 "SurfaceCache.c"
			}
#line 268 "../lib/Drawing/SurfaceCache.vala"
			if (_tmp52_) {
#line 974 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp55_;
#line 269 "../lib/Drawing/SurfaceCache.vala"
				_tmp55_ = info;
#line 269 "../lib/Drawing/SurfaceCache.vala"
				result = _tmp55_;
#line 269 "../lib/Drawing/SurfaceCache.vala"
				_g_object_unref0 (infos_it);
#line 269 "../lib/Drawing/SurfaceCache.vala"
				if (needs_scaling) {
#line 269 "../lib/Drawing/SurfaceCache.vala"
					*needs_scaling = _vala_needs_scaling;
#line 986 "SurfaceCache.c"
				}
#line 269 "../lib/Drawing/SurfaceCache.vala"
				return result;
#line 990 "SurfaceCache.c"
			}
#line 271 "../lib/Drawing/SurfaceCache.vala"
			_tmp58_ = self->priv->_flags;
#line 271 "../lib/Drawing/SurfaceCache.vala"
			if ((_tmp58_ & PLANK_SURFACE_CACHE_FLAGS_ALLOW_DOWNSCALE) != 0) {
#line 996 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp59_;
#line 272 "../lib/Drawing/SurfaceCache.vala"
				_tmp59_ = info;
#line 272 "../lib/Drawing/SurfaceCache.vala"
				_tmp57_ = _tmp59_->width > width;
#line 1002 "SurfaceCache.c"
			} else {
#line 271 "../lib/Drawing/SurfaceCache.vala"
				_tmp57_ = FALSE;
#line 1006 "SurfaceCache.c"
			}
#line 271 "../lib/Drawing/SurfaceCache.vala"
			if (_tmp57_) {
#line 1010 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp60_;
#line 272 "../lib/Drawing/SurfaceCache.vala"
				_tmp60_ = info;
#line 272 "../lib/Drawing/SurfaceCache.vala"
				_tmp56_ = _tmp60_->height > height;
#line 1016 "SurfaceCache.c"
			} else {
#line 271 "../lib/Drawing/SurfaceCache.vala"
				_tmp56_ = FALSE;
#line 1020 "SurfaceCache.c"
			}
#line 271 "../lib/Drawing/SurfaceCache.vala"
			if (_tmp56_) {
#line 1024 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp61_;
#line 273 "../lib/Drawing/SurfaceCache.vala"
				_vala_needs_scaling = TRUE;
#line 274 "../lib/Drawing/SurfaceCache.vala"
				_tmp61_ = info;
#line 274 "../lib/Drawing/SurfaceCache.vala"
				result = _tmp61_;
#line 274 "../lib/Drawing/SurfaceCache.vala"
				_g_object_unref0 (infos_it);
#line 274 "../lib/Drawing/SurfaceCache.vala"
				if (needs_scaling) {
#line 274 "../lib/Drawing/SurfaceCache.vala"
					*needs_scaling = _vala_needs_scaling;
#line 1038 "SurfaceCache.c"
				}
#line 274 "../lib/Drawing/SurfaceCache.vala"
				return result;
#line 1042 "SurfaceCache.c"
			}
#line 277 "../lib/Drawing/SurfaceCache.vala"
			_tmp64_ = self->priv->_flags;
#line 277 "../lib/Drawing/SurfaceCache.vala"
			if ((_tmp64_ & PLANK_SURFACE_CACHE_FLAGS_ALLOW_UPSCALE) != 0) {
#line 1048 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp65_;
#line 278 "../lib/Drawing/SurfaceCache.vala"
				_tmp65_ = info;
#line 278 "../lib/Drawing/SurfaceCache.vala"
				_tmp63_ = _tmp65_->width < width;
#line 1054 "SurfaceCache.c"
			} else {
#line 277 "../lib/Drawing/SurfaceCache.vala"
				_tmp63_ = FALSE;
#line 1058 "SurfaceCache.c"
			}
#line 277 "../lib/Drawing/SurfaceCache.vala"
			if (_tmp63_) {
#line 1062 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp66_;
#line 278 "../lib/Drawing/SurfaceCache.vala"
				_tmp66_ = info;
#line 278 "../lib/Drawing/SurfaceCache.vala"
				_tmp62_ = _tmp66_->height < height;
#line 1068 "SurfaceCache.c"
			} else {
#line 277 "../lib/Drawing/SurfaceCache.vala"
				_tmp62_ = FALSE;
#line 1072 "SurfaceCache.c"
			}
#line 277 "../lib/Drawing/SurfaceCache.vala"
			if (_tmp62_) {
#line 1076 "SurfaceCache.c"
				PlankSurfaceCacheSurfaceInfo* _tmp67_;
#line 279 "../lib/Drawing/SurfaceCache.vala"
				_vala_needs_scaling = TRUE;
#line 280 "../lib/Drawing/SurfaceCache.vala"
				_tmp67_ = info;
#line 280 "../lib/Drawing/SurfaceCache.vala"
				result = _tmp67_;
#line 280 "../lib/Drawing/SurfaceCache.vala"
				_g_object_unref0 (infos_it);
#line 280 "../lib/Drawing/SurfaceCache.vala"
				if (needs_scaling) {
#line 280 "../lib/Drawing/SurfaceCache.vala"
					*needs_scaling = _vala_needs_scaling;
#line 1090 "SurfaceCache.c"
				}
#line 280 "../lib/Drawing/SurfaceCache.vala"
				return result;
#line 1094 "SurfaceCache.c"
			}
		}
	}
#line 285 "../lib/Drawing/SurfaceCache.vala"
	result = NULL;
#line 285 "../lib/Drawing/SurfaceCache.vala"
	_g_object_unref0 (infos_it);
#line 285 "../lib/Drawing/SurfaceCache.vala"
	if (needs_scaling) {
#line 285 "../lib/Drawing/SurfaceCache.vala"
		*needs_scaling = _vala_needs_scaling;
#line 1106 "SurfaceCache.c"
	}
#line 285 "../lib/Drawing/SurfaceCache.vala"
	return result;
#line 1110 "SurfaceCache.c"
}

void
plank_surface_cache_clear (PlankSurfaceCache* self)
{
	GeeTreeSet* _tmp0_;
	GeeHashMap* _tmp1_;
#line 288 "../lib/Drawing/SurfaceCache.vala"
	g_return_if_fail (self != NULL);
#line 290 "../lib/Drawing/SurfaceCache.vala"
	g_mutex_lock (&self->priv->cache_mutex);
#line 292 "../lib/Drawing/SurfaceCache.vala"
	_tmp0_ = self->priv->infos;
#line 292 "../lib/Drawing/SurfaceCache.vala"
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp0_);
#line 293 "../lib/Drawing/SurfaceCache.vala"
	_tmp1_ = self->priv->cache_map;
#line 293 "../lib/Drawing/SurfaceCache.vala"
	gee_abstract_map_clear ((GeeAbstractMap*) _tmp1_);
#line 294 "../lib/Drawing/SurfaceCache.vala"
	self->priv->last_info = NULL;
#line 296 "../lib/Drawing/SurfaceCache.vala"
	g_mutex_unlock (&self->priv->cache_mutex);
#line 1134 "SurfaceCache.c"
}

static void
plank_surface_cache_clean_up (PlankSurfaceCache* self)
{
	GeeHashMap* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint64 now = 0LL;
	gint size_before = 0;
	GeeHashMap* _tmp3_;
	gint _tmp4_;
	gint _tmp5_;
	gint size_current = 0;
	GeeMapIterator* cache_it = NULL;
	GeeHashMap* _tmp6_;
	GeeMapIterator* _tmp7_;
	GeeHashMap* _tmp18_;
	gint _tmp19_;
	gint _tmp20_;
#line 299 "../lib/Drawing/SurfaceCache.vala"
	g_return_if_fail (self != NULL);
#line 301 "../lib/Drawing/SurfaceCache.vala"
	g_mutex_lock (&self->priv->cache_mutex);
#line 303 "../lib/Drawing/SurfaceCache.vala"
	_tmp0_ = self->priv->cache_map;
#line 303 "../lib/Drawing/SurfaceCache.vala"
	_tmp1_ = gee_abstract_map_get_size ((GeeAbstractMap*) _tmp0_);
#line 303 "../lib/Drawing/SurfaceCache.vala"
	_tmp2_ = _tmp1_;
#line 303 "../lib/Drawing/SurfaceCache.vala"
	if (_tmp2_ <= 1) {
#line 304 "../lib/Drawing/SurfaceCache.vala"
		g_mutex_unlock (&self->priv->cache_mutex);
#line 305 "../lib/Drawing/SurfaceCache.vala"
		return;
#line 1171 "SurfaceCache.c"
	}
#line 308 "../lib/Drawing/SurfaceCache.vala"
	now = g_get_monotonic_time ();
#line 309 "../lib/Drawing/SurfaceCache.vala"
	_tmp3_ = self->priv->cache_map;
#line 309 "../lib/Drawing/SurfaceCache.vala"
	_tmp4_ = gee_abstract_map_get_size ((GeeAbstractMap*) _tmp3_);
#line 309 "../lib/Drawing/SurfaceCache.vala"
	_tmp5_ = _tmp4_;
#line 309 "../lib/Drawing/SurfaceCache.vala"
	size_before = _tmp5_;
#line 310 "../lib/Drawing/SurfaceCache.vala"
	size_current = size_before;
#line 312 "../lib/Drawing/SurfaceCache.vala"
	_tmp6_ = self->priv->cache_map;
#line 312 "../lib/Drawing/SurfaceCache.vala"
	_tmp7_ = gee_abstract_map_map_iterator ((GeeAbstractMap*) _tmp6_);
#line 312 "../lib/Drawing/SurfaceCache.vala"
	cache_it = _tmp7_;
#line 313 "../lib/Drawing/SurfaceCache.vala"
	while (TRUE) {
#line 1193 "SurfaceCache.c"
		GeeMapIterator* _tmp8_;
		PlankSurfaceCacheSurfaceInfo* info = NULL;
		GeeMapIterator* _tmp9_;
		gpointer _tmp10_;
		PlankSurfaceCacheSurfaceInfo* _tmp11_;
		PlankSurfaceCacheSurfaceInfo* _tmp12_;
		PlankSurfaceCacheSurfaceInfo* _tmp13_;
		GeeTreeSet* _tmp14_;
		PlankSurfaceCacheSurfaceInfo* _tmp15_;
		GeeMapIterator* _tmp16_;
		gint _tmp17_;
#line 313 "../lib/Drawing/SurfaceCache.vala"
		_tmp8_ = cache_it;
#line 313 "../lib/Drawing/SurfaceCache.vala"
		if (!gee_map_iterator_next (_tmp8_)) {
#line 313 "../lib/Drawing/SurfaceCache.vala"
			break;
#line 1211 "SurfaceCache.c"
		}
#line 314 "../lib/Drawing/SurfaceCache.vala"
		_tmp9_ = cache_it;
#line 314 "../lib/Drawing/SurfaceCache.vala"
		_tmp10_ = gee_map_iterator_get_key (_tmp9_);
#line 314 "../lib/Drawing/SurfaceCache.vala"
		info = (PlankSurfaceCacheSurfaceInfo*) _tmp10_;
#line 316 "../lib/Drawing/SurfaceCache.vala"
		_tmp11_ = info;
#line 316 "../lib/Drawing/SurfaceCache.vala"
		_tmp12_ = info;
#line 316 "../lib/Drawing/SurfaceCache.vala"
		if ((now - _tmp11_->last_access_time) < (PLANK_SURFACE_CACHE_ACCESS_REWARD * _tmp12_->access_count)) {
#line 317 "../lib/Drawing/SurfaceCache.vala"
			_plank_surface_cache_surface_info_unref0 (info);
#line 317 "../lib/Drawing/SurfaceCache.vala"
			continue;
#line 1229 "SurfaceCache.c"
		}
#line 319 "../lib/Drawing/SurfaceCache.vala"
		_tmp13_ = info;
#line 319 "../lib/Drawing/SurfaceCache.vala"
		if (_tmp13_->drawing_time > PLANK_SURFACE_CACHE_MIN_DRAWING_TIME) {
#line 320 "../lib/Drawing/SurfaceCache.vala"
			_plank_surface_cache_surface_info_unref0 (info);
#line 320 "../lib/Drawing/SurfaceCache.vala"
			continue;
#line 1239 "SurfaceCache.c"
		}
#line 322 "../lib/Drawing/SurfaceCache.vala"
		if (size_current <= 1) {
#line 323 "../lib/Drawing/SurfaceCache.vala"
			_plank_surface_cache_surface_info_unref0 (info);
#line 323 "../lib/Drawing/SurfaceCache.vala"
			break;
#line 1247 "SurfaceCache.c"
		}
#line 325 "../lib/Drawing/SurfaceCache.vala"
		_tmp14_ = self->priv->infos;
#line 325 "../lib/Drawing/SurfaceCache.vala"
		_tmp15_ = info;
#line 325 "../lib/Drawing/SurfaceCache.vala"
		gee_abstract_collection_remove ((GeeAbstractCollection*) _tmp14_, _tmp15_);
#line 326 "../lib/Drawing/SurfaceCache.vala"
		_tmp16_ = cache_it;
#line 326 "../lib/Drawing/SurfaceCache.vala"
		gee_map_iterator_unset (_tmp16_);
#line 327 "../lib/Drawing/SurfaceCache.vala"
		_tmp17_ = size_current;
#line 327 "../lib/Drawing/SurfaceCache.vala"
		size_current = _tmp17_ - 1;
#line 313 "../lib/Drawing/SurfaceCache.vala"
		_plank_surface_cache_surface_info_unref0 (info);
#line 1265 "SurfaceCache.c"
	}
#line 330 "../lib/Drawing/SurfaceCache.vala"
	self->priv->last_info = NULL;
#line 332 "../lib/Drawing/SurfaceCache.vala"
	_tmp18_ = self->priv->cache_map;
#line 332 "../lib/Drawing/SurfaceCache.vala"
	_tmp19_ = gee_abstract_map_get_size ((GeeAbstractMap*) _tmp18_);
#line 332 "../lib/Drawing/SurfaceCache.vala"
	_tmp20_ = _tmp19_;
#line 332 "../lib/Drawing/SurfaceCache.vala"
	plank_logger_verbose ("SurfaceCache.clean_up (%i -> %i) ", size_before, _tmp20_, NULL);
#line 334 "../lib/Drawing/SurfaceCache.vala"
	g_mutex_unlock (&self->priv->cache_mutex);
#line 299 "../lib/Drawing/SurfaceCache.vala"
	_g_object_unref0 (cache_it);
#line 1281 "SurfaceCache.c"
}

PlankSurfaceCacheFlags
plank_surface_cache_get_flags (PlankSurfaceCache* self)
{
	PlankSurfaceCacheFlags result;
	PlankSurfaceCacheFlags _tmp0_;
#line 119 "../lib/Drawing/SurfaceCache.vala"
	g_return_val_if_fail (self != NULL, 0U);
#line 119 "../lib/Drawing/SurfaceCache.vala"
	_tmp0_ = self->priv->_flags;
#line 119 "../lib/Drawing/SurfaceCache.vala"
	result = _tmp0_;
#line 119 "../lib/Drawing/SurfaceCache.vala"
	return result;
#line 1297 "SurfaceCache.c"
}

void
plank_surface_cache_set_flags (PlankSurfaceCache* self,
                               PlankSurfaceCacheFlags value)
{
	PlankSurfaceCacheFlags old_value;
#line 119 "../lib/Drawing/SurfaceCache.vala"
	g_return_if_fail (self != NULL);
#line 119 "../lib/Drawing/SurfaceCache.vala"
	old_value = plank_surface_cache_get_flags (self);
#line 119 "../lib/Drawing/SurfaceCache.vala"
	if (old_value != value) {
#line 119 "../lib/Drawing/SurfaceCache.vala"
		self->priv->_flags = value;
#line 119 "../lib/Drawing/SurfaceCache.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_surface_cache_properties[PLANK_SURFACE_CACHE_FLAGS_PROPERTY]);
#line 1315 "SurfaceCache.c"
	}
}

static PlankSurfaceCacheSurfaceInfo*
plank_surface_cache_surface_info_construct (GType object_type,
                                            guint16 width,
                                            guint16 height,
                                            gint64 last_access_time,
                                            gint64 drawing_time)
{
	PlankSurfaceCacheSurfaceInfo* self = NULL;
#line 89 "../lib/Drawing/SurfaceCache.vala"
	self = (PlankSurfaceCacheSurfaceInfo*) g_type_create_instance (object_type);
#line 91 "../lib/Drawing/SurfaceCache.vala"
	self->width = width;
#line 92 "../lib/Drawing/SurfaceCache.vala"
	self->height = height;
#line 93 "../lib/Drawing/SurfaceCache.vala"
	self->last_access_time = last_access_time;
#line 94 "../lib/Drawing/SurfaceCache.vala"
	self->drawing_time = drawing_time;
#line 95 "../lib/Drawing/SurfaceCache.vala"
	self->access_count = (guint) 0;
#line 96 "../lib/Drawing/SurfaceCache.vala"
	self->scale = 1.0;
#line 89 "../lib/Drawing/SurfaceCache.vala"
	return self;
#line 1343 "SurfaceCache.c"
}

static PlankSurfaceCacheSurfaceInfo*
plank_surface_cache_surface_info_new (guint16 width,
                                      guint16 height,
                                      gint64 last_access_time,
                                      gint64 drawing_time)
{
#line 89 "../lib/Drawing/SurfaceCache.vala"
	return plank_surface_cache_surface_info_construct (PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO, width, height, last_access_time, drawing_time);
#line 1354 "SurfaceCache.c"
}

static guint
plank_surface_cache_surface_info_hash (PlankSurfaceCacheSurfaceInfo* s)
{
	guint n1 = 0U;
	guint n2 = 0U;
	guint _tmp0_ = 0U;
	guint result = 0U;
#line 99 "../lib/Drawing/SurfaceCache.vala"
	g_return_val_if_fail (s != NULL, 0U);
#line 101 "../lib/Drawing/SurfaceCache.vala"
	n1 = (guint) s->width;
#line 101 "../lib/Drawing/SurfaceCache.vala"
	n2 = (guint) s->height;
#line 102 "../lib/Drawing/SurfaceCache.vala"
	if (n1 >= n2) {
#line 102 "../lib/Drawing/SurfaceCache.vala"
		_tmp0_ = ((n1 * n1) + n1) + n2;
#line 1374 "SurfaceCache.c"
	} else {
#line 102 "../lib/Drawing/SurfaceCache.vala"
		_tmp0_ = n1 + (n2 * n2);
#line 1378 "SurfaceCache.c"
	}
#line 102 "../lib/Drawing/SurfaceCache.vala"
	result = _tmp0_;
#line 102 "../lib/Drawing/SurfaceCache.vala"
	return result;
#line 1384 "SurfaceCache.c"
}

static gint
plank_surface_cache_surface_info_compare (PlankSurfaceCacheSurfaceInfo* s1,
                                          PlankSurfaceCacheSurfaceInfo* s2)
{
	gint result = 0;
#line 105 "../lib/Drawing/SurfaceCache.vala"
	g_return_val_if_fail (s1 != NULL, 0);
#line 105 "../lib/Drawing/SurfaceCache.vala"
	g_return_val_if_fail (s2 != NULL, 0);
#line 107 "../lib/Drawing/SurfaceCache.vala"
	if (s1 == s2) {
#line 108 "../lib/Drawing/SurfaceCache.vala"
		result = 0;
#line 108 "../lib/Drawing/SurfaceCache.vala"
		return result;
#line 1402 "SurfaceCache.c"
	}
#line 110 "../lib/Drawing/SurfaceCache.vala"
	result = ((2 * (s1->width - s2->width)) + s2->height) - s2->height;
#line 110 "../lib/Drawing/SurfaceCache.vala"
	return result;
#line 1408 "SurfaceCache.c"
}

static gint
plank_surface_cache_surface_info_compare_with (PlankSurfaceCacheSurfaceInfo* self,
                                               guint16 width,
                                               guint16 height)
{
	gint result = 0;
#line 113 "../lib/Drawing/SurfaceCache.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 115 "../lib/Drawing/SurfaceCache.vala"
	result = ((2 * (self->width - width)) + self->height) - height;
#line 115 "../lib/Drawing/SurfaceCache.vala"
	return result;
#line 1423 "SurfaceCache.c"
}

static void
plank_surface_cache_value_surface_info_init (GValue* value)
{
#line 80 "../lib/Drawing/SurfaceCache.vala"
	value->data[0].v_pointer = NULL;
#line 1431 "SurfaceCache.c"
}

static void
plank_surface_cache_value_surface_info_free_value (GValue* value)
{
#line 80 "../lib/Drawing/SurfaceCache.vala"
	if (value->data[0].v_pointer) {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		plank_surface_cache_surface_info_unref (value->data[0].v_pointer);
#line 1441 "SurfaceCache.c"
	}
}

static void
plank_surface_cache_value_surface_info_copy_value (const GValue* src_value,
                                                   GValue* dest_value)
{
#line 80 "../lib/Drawing/SurfaceCache.vala"
	if (src_value->data[0].v_pointer) {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		dest_value->data[0].v_pointer = plank_surface_cache_surface_info_ref (src_value->data[0].v_pointer);
#line 1453 "SurfaceCache.c"
	} else {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		dest_value->data[0].v_pointer = NULL;
#line 1457 "SurfaceCache.c"
	}
}

static gpointer
plank_surface_cache_value_surface_info_peek_pointer (const GValue* value)
{
#line 80 "../lib/Drawing/SurfaceCache.vala"
	return value->data[0].v_pointer;
#line 1466 "SurfaceCache.c"
}

static gchar*
plank_surface_cache_value_surface_info_collect_value (GValue* value,
                                                      guint n_collect_values,
                                                      GTypeCValue* collect_values,
                                                      guint collect_flags)
{
#line 80 "../lib/Drawing/SurfaceCache.vala"
	if (collect_values[0].v_pointer) {
#line 1477 "SurfaceCache.c"
		PlankSurfaceCacheSurfaceInfo * object;
		object = collect_values[0].v_pointer;
#line 80 "../lib/Drawing/SurfaceCache.vala"
		if (object->parent_instance.g_class == NULL) {
#line 80 "../lib/Drawing/SurfaceCache.vala"
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
#line 1484 "SurfaceCache.c"
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
#line 80 "../lib/Drawing/SurfaceCache.vala"
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
#line 1488 "SurfaceCache.c"
		}
#line 80 "../lib/Drawing/SurfaceCache.vala"
		value->data[0].v_pointer = plank_surface_cache_surface_info_ref (object);
#line 1492 "SurfaceCache.c"
	} else {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		value->data[0].v_pointer = NULL;
#line 1496 "SurfaceCache.c"
	}
#line 80 "../lib/Drawing/SurfaceCache.vala"
	return NULL;
#line 1500 "SurfaceCache.c"
}

static gchar*
plank_surface_cache_value_surface_info_lcopy_value (const GValue* value,
                                                    guint n_collect_values,
                                                    GTypeCValue* collect_values,
                                                    guint collect_flags)
{
	PlankSurfaceCacheSurfaceInfo ** object_p;
	object_p = collect_values[0].v_pointer;
#line 80 "../lib/Drawing/SurfaceCache.vala"
	if (!object_p) {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
#line 1515 "SurfaceCache.c"
	}
#line 80 "../lib/Drawing/SurfaceCache.vala"
	if (!value->data[0].v_pointer) {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		*object_p = NULL;
#line 1521 "SurfaceCache.c"
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		*object_p = value->data[0].v_pointer;
#line 1525 "SurfaceCache.c"
	} else {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		*object_p = plank_surface_cache_surface_info_ref (value->data[0].v_pointer);
#line 1529 "SurfaceCache.c"
	}
#line 80 "../lib/Drawing/SurfaceCache.vala"
	return NULL;
#line 1533 "SurfaceCache.c"
}

static GParamSpec*
plank_surface_cache_param_spec_surface_info (const gchar* name,
                                             const gchar* nick,
                                             const gchar* blurb,
                                             GType object_type,
                                             GParamFlags flags)
{
	PlankSurfaceCacheParamSpecSurfaceInfo* spec;
#line 80 "../lib/Drawing/SurfaceCache.vala"
	g_return_val_if_fail (g_type_is_a (object_type, PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO), NULL);
#line 80 "../lib/Drawing/SurfaceCache.vala"
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
#line 80 "../lib/Drawing/SurfaceCache.vala"
	G_PARAM_SPEC (spec)->value_type = object_type;
#line 80 "../lib/Drawing/SurfaceCache.vala"
	return G_PARAM_SPEC (spec);
#line 1552 "SurfaceCache.c"
}

static gpointer
plank_surface_cache_value_get_surface_info (const GValue* value)
{
#line 80 "../lib/Drawing/SurfaceCache.vala"
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO), NULL);
#line 80 "../lib/Drawing/SurfaceCache.vala"
	return value->data[0].v_pointer;
#line 1562 "SurfaceCache.c"
}

static void
plank_surface_cache_value_set_surface_info (GValue* value,
                                            gpointer v_object)
{
	PlankSurfaceCacheSurfaceInfo * old;
#line 80 "../lib/Drawing/SurfaceCache.vala"
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO));
#line 80 "../lib/Drawing/SurfaceCache.vala"
	old = value->data[0].v_pointer;
#line 80 "../lib/Drawing/SurfaceCache.vala"
	if (v_object) {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO));
#line 80 "../lib/Drawing/SurfaceCache.vala"
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
#line 80 "../lib/Drawing/SurfaceCache.vala"
		value->data[0].v_pointer = v_object;
#line 80 "../lib/Drawing/SurfaceCache.vala"
		plank_surface_cache_surface_info_ref (value->data[0].v_pointer);
#line 1584 "SurfaceCache.c"
	} else {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		value->data[0].v_pointer = NULL;
#line 1588 "SurfaceCache.c"
	}
#line 80 "../lib/Drawing/SurfaceCache.vala"
	if (old) {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		plank_surface_cache_surface_info_unref (old);
#line 1594 "SurfaceCache.c"
	}
}

static void
plank_surface_cache_value_take_surface_info (GValue* value,
                                             gpointer v_object)
{
	PlankSurfaceCacheSurfaceInfo * old;
#line 80 "../lib/Drawing/SurfaceCache.vala"
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO));
#line 80 "../lib/Drawing/SurfaceCache.vala"
	old = value->data[0].v_pointer;
#line 80 "../lib/Drawing/SurfaceCache.vala"
	if (v_object) {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO));
#line 80 "../lib/Drawing/SurfaceCache.vala"
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
#line 80 "../lib/Drawing/SurfaceCache.vala"
		value->data[0].v_pointer = v_object;
#line 1615 "SurfaceCache.c"
	} else {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		value->data[0].v_pointer = NULL;
#line 1619 "SurfaceCache.c"
	}
#line 80 "../lib/Drawing/SurfaceCache.vala"
	if (old) {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		plank_surface_cache_surface_info_unref (old);
#line 1625 "SurfaceCache.c"
	}
}

static void
plank_surface_cache_surface_info_class_init (PlankSurfaceCacheSurfaceInfoClass * klass,
                                             gpointer klass_data)
{
#line 80 "../lib/Drawing/SurfaceCache.vala"
	plank_surface_cache_surface_info_parent_class = g_type_class_peek_parent (klass);
#line 80 "../lib/Drawing/SurfaceCache.vala"
	((PlankSurfaceCacheSurfaceInfoClass *) klass)->finalize = plank_surface_cache_surface_info_finalize;
#line 1637 "SurfaceCache.c"
}

static void
plank_surface_cache_surface_info_instance_init (PlankSurfaceCacheSurfaceInfo * self,
                                                gpointer klass)
{
#line 80 "../lib/Drawing/SurfaceCache.vala"
	self->ref_count = 1;
#line 1646 "SurfaceCache.c"
}

static void
plank_surface_cache_surface_info_finalize (PlankSurfaceCacheSurfaceInfo * obj)
{
	PlankSurfaceCacheSurfaceInfo * self;
#line 80 "../lib/Drawing/SurfaceCache.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO, PlankSurfaceCacheSurfaceInfo);
#line 80 "../lib/Drawing/SurfaceCache.vala"
	g_signal_handlers_destroy (self);
#line 1657 "SurfaceCache.c"
}

static GType
plank_surface_cache_surface_info_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { plank_surface_cache_value_surface_info_init, plank_surface_cache_value_surface_info_free_value, plank_surface_cache_value_surface_info_copy_value, plank_surface_cache_value_surface_info_peek_pointer, "p", plank_surface_cache_value_surface_info_collect_value, "p", plank_surface_cache_value_surface_info_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (PlankSurfaceCacheSurfaceInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_surface_cache_surface_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankSurfaceCacheSurfaceInfo), 0, (GInstanceInitFunc) plank_surface_cache_surface_info_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType plank_surface_cache_surface_info_type_id;
	plank_surface_cache_surface_info_type_id = g_type_register_fundamental (g_type_fundamental_next (), "PlankSurfaceCacheSurfaceInfo", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return plank_surface_cache_surface_info_type_id;
}

static GType
plank_surface_cache_surface_info_get_type (void)
{
	static volatile gsize plank_surface_cache_surface_info_type_id__volatile = 0;
	if (g_once_init_enter (&plank_surface_cache_surface_info_type_id__volatile)) {
		GType plank_surface_cache_surface_info_type_id;
		plank_surface_cache_surface_info_type_id = plank_surface_cache_surface_info_get_type_once ();
		g_once_init_leave (&plank_surface_cache_surface_info_type_id__volatile, plank_surface_cache_surface_info_type_id);
	}
	return plank_surface_cache_surface_info_type_id__volatile;
}

static gpointer
plank_surface_cache_surface_info_ref (gpointer instance)
{
	PlankSurfaceCacheSurfaceInfo * self;
	self = instance;
#line 80 "../lib/Drawing/SurfaceCache.vala"
	g_atomic_int_inc (&self->ref_count);
#line 80 "../lib/Drawing/SurfaceCache.vala"
	return instance;
#line 1692 "SurfaceCache.c"
}

static void
plank_surface_cache_surface_info_unref (gpointer instance)
{
	PlankSurfaceCacheSurfaceInfo * self;
	self = instance;
#line 80 "../lib/Drawing/SurfaceCache.vala"
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
#line 80 "../lib/Drawing/SurfaceCache.vala"
		PLANK_SURFACE_CACHE_SURFACE_INFO_GET_CLASS (self)->finalize (self);
#line 80 "../lib/Drawing/SurfaceCache.vala"
		g_type_free_instance ((GTypeInstance *) self);
#line 1706 "SurfaceCache.c"
	}
}

static gboolean
_plank_surface_cache___lambda8_ (PlankSurfaceCache* self)
{
	gboolean result = FALSE;
#line 141 "../lib/Drawing/SurfaceCache.vala"
	plank_surface_cache_clean_up (self);
#line 142 "../lib/Drawing/SurfaceCache.vala"
	result = TRUE;
#line 142 "../lib/Drawing/SurfaceCache.vala"
	return result;
#line 1720 "SurfaceCache.c"
}

static gboolean
__plank_surface_cache___lambda8__gsource_func (gpointer self)
{
	gboolean result;
	result = _plank_surface_cache___lambda8_ ((PlankSurfaceCache*) self);
#line 140 "../lib/Drawing/SurfaceCache.vala"
	return result;
#line 1730 "SurfaceCache.c"
}

static GObject *
plank_surface_cache_constructor (GType type,
                                 guint n_construct_properties,
                                 GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	PlankSurfaceCache * self;
	GeeTreeSet* _tmp0_;
	GeeHashMap* _tmp1_;
#line 133 "../lib/Drawing/SurfaceCache.vala"
	parent_class = G_OBJECT_CLASS (plank_surface_cache_parent_class);
#line 133 "../lib/Drawing/SurfaceCache.vala"
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
#line 133 "../lib/Drawing/SurfaceCache.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_SURFACE_CACHE, PlankSurfaceCache);
#line 135 "../lib/Drawing/SurfaceCache.vala"
	_tmp0_ = gee_tree_set_new (PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO, NULL, NULL, (GCompareDataFunc) plank_surface_cache_surface_info_compare, NULL, NULL);
#line 135 "../lib/Drawing/SurfaceCache.vala"
	_g_object_unref0 (self->priv->infos);
#line 135 "../lib/Drawing/SurfaceCache.vala"
	self->priv->infos = _tmp0_;
#line 136 "../lib/Drawing/SurfaceCache.vala"
	_tmp1_ = gee_hash_map_new (PLANK_SURFACE_CACHE_TYPE_SURFACE_INFO, (GBoxedCopyFunc) plank_surface_cache_surface_info_ref, (GDestroyNotify) plank_surface_cache_surface_info_unref, PLANK_TYPE_SURFACE, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, (GeeHashDataFunc) plank_surface_cache_surface_info_hash, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
#line 136 "../lib/Drawing/SurfaceCache.vala"
	_g_object_unref0 (self->priv->cache_map);
#line 136 "../lib/Drawing/SurfaceCache.vala"
	self->priv->cache_map = _tmp1_;
#line 137 "../lib/Drawing/SurfaceCache.vala"
	self->priv->last_info = NULL;
#line 140 "../lib/Drawing/SurfaceCache.vala"
	self->priv->clean_up_timer_id = gdk_threads_add_timeout ((guint) ((5 * 60) * 1000), __plank_surface_cache___lambda8__gsource_func, self);
#line 133 "../lib/Drawing/SurfaceCache.vala"
	return obj;
#line 1767 "SurfaceCache.c"
}

static void
plank_surface_cache_class_init (PlankSurfaceCacheClass * klass,
                                gpointer klass_data)
{
#line 73 "../lib/Drawing/SurfaceCache.vala"
	plank_surface_cache_parent_class = g_type_class_peek_parent (klass);
#line 73 "../lib/Drawing/SurfaceCache.vala"
	g_type_class_adjust_private_offset (klass, &PlankSurfaceCache_private_offset);
#line 73 "../lib/Drawing/SurfaceCache.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_plank_surface_cache_get_property;
#line 73 "../lib/Drawing/SurfaceCache.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_plank_surface_cache_set_property;
#line 73 "../lib/Drawing/SurfaceCache.vala"
	G_OBJECT_CLASS (klass)->constructor = plank_surface_cache_constructor;
#line 73 "../lib/Drawing/SurfaceCache.vala"
	G_OBJECT_CLASS (klass)->finalize = plank_surface_cache_finalize;
#line 73 "../lib/Drawing/SurfaceCache.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_SURFACE_CACHE_G_TYPE, g_param_spec_gtype ("g-type", "type", "type", G_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
#line 73 "../lib/Drawing/SurfaceCache.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_SURFACE_CACHE_G_DUP_FUNC, g_param_spec_pointer ("g-dup-func", "dup func", "dup func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
#line 73 "../lib/Drawing/SurfaceCache.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_SURFACE_CACHE_G_DESTROY_FUNC, g_param_spec_pointer ("g-destroy-func", "destroy func", "destroy func", G_PARAM_STATIC_STRINGS | G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
#line 73 "../lib/Drawing/SurfaceCache.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_SURFACE_CACHE_FLAGS_PROPERTY, plank_surface_cache_properties[PLANK_SURFACE_CACHE_FLAGS_PROPERTY] = g_param_spec_flags ("flags", "flags", "flags", PLANK_TYPE_SURFACE_CACHE_FLAGS, 0U, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT));
#line 1794 "SurfaceCache.c"
}

static void
plank_surface_cache_instance_init (PlankSurfaceCache * self,
                                   gpointer klass)
{
#line 73 "../lib/Drawing/SurfaceCache.vala"
	self->priv = plank_surface_cache_get_instance_private (self);
#line 126 "../lib/Drawing/SurfaceCache.vala"
	self->priv->clean_up_timer_id = 0U;
#line 1805 "SurfaceCache.c"
}

static void
plank_surface_cache_finalize (GObject * obj)
{
	PlankSurfaceCache * self;
	GeeHashMap* _tmp0_;
	GeeTreeSet* _tmp1_;
#line 73 "../lib/Drawing/SurfaceCache.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_SURFACE_CACHE, PlankSurfaceCache);
#line 148 "../lib/Drawing/SurfaceCache.vala"
	if (self->priv->clean_up_timer_id > 0U) {
#line 149 "../lib/Drawing/SurfaceCache.vala"
		g_source_remove (self->priv->clean_up_timer_id);
#line 150 "../lib/Drawing/SurfaceCache.vala"
		self->priv->clean_up_timer_id = 0U;
#line 1822 "SurfaceCache.c"
	}
#line 153 "../lib/Drawing/SurfaceCache.vala"
	_tmp0_ = self->priv->cache_map;
#line 153 "../lib/Drawing/SurfaceCache.vala"
	gee_abstract_map_clear ((GeeAbstractMap*) _tmp0_);
#line 154 "../lib/Drawing/SurfaceCache.vala"
	_tmp1_ = self->priv->infos;
#line 154 "../lib/Drawing/SurfaceCache.vala"
	gee_abstract_collection_clear ((GeeAbstractCollection*) _tmp1_);
#line 155 "../lib/Drawing/SurfaceCache.vala"
	self->priv->last_info = NULL;
#line 121 "../lib/Drawing/SurfaceCache.vala"
	_g_object_unref0 (self->priv->infos);
#line 122 "../lib/Drawing/SurfaceCache.vala"
	_g_object_unref0 (self->priv->cache_map);
#line 124 "../lib/Drawing/SurfaceCache.vala"
	_vala_clear_GMutex (&self->priv->cache_mutex);
#line 73 "../lib/Drawing/SurfaceCache.vala"
	G_OBJECT_CLASS (plank_surface_cache_parent_class)->finalize (obj);
#line 1842 "SurfaceCache.c"
}

/**
 * Cache multiple sizes of the assumed same image
 */
static GType
plank_surface_cache_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankSurfaceCacheClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_surface_cache_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankSurfaceCache), 0, (GInstanceInitFunc) plank_surface_cache_instance_init, NULL };
	GType plank_surface_cache_type_id;
	plank_surface_cache_type_id = g_type_register_static (G_TYPE_OBJECT, "PlankSurfaceCache", &g_define_type_info, 0);
	PlankSurfaceCache_private_offset = g_type_add_instance_private (plank_surface_cache_type_id, sizeof (PlankSurfaceCachePrivate));
	return plank_surface_cache_type_id;
}

GType
plank_surface_cache_get_type (void)
{
	static volatile gsize plank_surface_cache_type_id__volatile = 0;
	if (g_once_init_enter (&plank_surface_cache_type_id__volatile)) {
		GType plank_surface_cache_type_id;
		plank_surface_cache_type_id = plank_surface_cache_get_type_once ();
		g_once_init_leave (&plank_surface_cache_type_id__volatile, plank_surface_cache_type_id);
	}
	return plank_surface_cache_type_id__volatile;
}

static void
_vala_plank_surface_cache_get_property (GObject * object,
                                        guint property_id,
                                        GValue * value,
                                        GParamSpec * pspec)
{
	PlankSurfaceCache * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_SURFACE_CACHE, PlankSurfaceCache);
#line 73 "../lib/Drawing/SurfaceCache.vala"
	switch (property_id) {
#line 73 "../lib/Drawing/SurfaceCache.vala"
		case PLANK_SURFACE_CACHE_FLAGS_PROPERTY:
#line 73 "../lib/Drawing/SurfaceCache.vala"
		g_value_set_flags (value, plank_surface_cache_get_flags (self));
#line 73 "../lib/Drawing/SurfaceCache.vala"
		break;
#line 73 "../lib/Drawing/SurfaceCache.vala"
		case PLANK_SURFACE_CACHE_G_TYPE:
#line 73 "../lib/Drawing/SurfaceCache.vala"
		g_value_set_gtype (value, self->priv->g_type);
#line 73 "../lib/Drawing/SurfaceCache.vala"
		break;
#line 73 "../lib/Drawing/SurfaceCache.vala"
		case PLANK_SURFACE_CACHE_G_DUP_FUNC:
#line 73 "../lib/Drawing/SurfaceCache.vala"
		g_value_set_pointer (value, self->priv->g_dup_func);
#line 73 "../lib/Drawing/SurfaceCache.vala"
		break;
#line 73 "../lib/Drawing/SurfaceCache.vala"
		case PLANK_SURFACE_CACHE_G_DESTROY_FUNC:
#line 73 "../lib/Drawing/SurfaceCache.vala"
		g_value_set_pointer (value, self->priv->g_destroy_func);
#line 73 "../lib/Drawing/SurfaceCache.vala"
		break;
#line 1904 "SurfaceCache.c"
		default:
#line 73 "../lib/Drawing/SurfaceCache.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 73 "../lib/Drawing/SurfaceCache.vala"
		break;
#line 1910 "SurfaceCache.c"
	}
}

static void
_vala_plank_surface_cache_set_property (GObject * object,
                                        guint property_id,
                                        const GValue * value,
                                        GParamSpec * pspec)
{
	PlankSurfaceCache * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_SURFACE_CACHE, PlankSurfaceCache);
#line 73 "../lib/Drawing/SurfaceCache.vala"
	switch (property_id) {
#line 73 "../lib/Drawing/SurfaceCache.vala"
		case PLANK_SURFACE_CACHE_FLAGS_PROPERTY:
#line 73 "../lib/Drawing/SurfaceCache.vala"
		plank_surface_cache_set_flags (self, g_value_get_flags (value));
#line 73 "../lib/Drawing/SurfaceCache.vala"
		break;
#line 73 "../lib/Drawing/SurfaceCache.vala"
		case PLANK_SURFACE_CACHE_G_TYPE:
#line 73 "../lib/Drawing/SurfaceCache.vala"
		self->priv->g_type = g_value_get_gtype (value);
#line 73 "../lib/Drawing/SurfaceCache.vala"
		break;
#line 73 "../lib/Drawing/SurfaceCache.vala"
		case PLANK_SURFACE_CACHE_G_DUP_FUNC:
#line 73 "../lib/Drawing/SurfaceCache.vala"
		self->priv->g_dup_func = g_value_get_pointer (value);
#line 73 "../lib/Drawing/SurfaceCache.vala"
		break;
#line 73 "../lib/Drawing/SurfaceCache.vala"
		case PLANK_SURFACE_CACHE_G_DESTROY_FUNC:
#line 73 "../lib/Drawing/SurfaceCache.vala"
		self->priv->g_destroy_func = g_value_get_pointer (value);
#line 73 "../lib/Drawing/SurfaceCache.vala"
		break;
#line 1948 "SurfaceCache.c"
		default:
#line 73 "../lib/Drawing/SurfaceCache.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 73 "../lib/Drawing/SurfaceCache.vala"
		break;
#line 1954 "SurfaceCache.c"
	}
}

static void
_vala_clear_GMutex (GMutex * mutex)
{
	GMutex zero_mutex = { 0 };
#line 52 "../lib/Docklets/DockletManager.vala"
	if (memcmp (mutex, &zero_mutex, sizeof (GMutex))) {
#line 52 "../lib/Docklets/DockletManager.vala"
		g_mutex_clear (mutex);
#line 52 "../lib/Docklets/DockletManager.vala"
		memset (mutex, 0, sizeof (GMutex));
#line 1968 "SurfaceCache.c"
	}
}

static void
_vala_clear_GRecMutex (GRecMutex * mutex)
{
	GRecMutex zero_mutex = { 0 };
#line 52 "../lib/Docklets/DockletManager.vala"
	if (memcmp (mutex, &zero_mutex, sizeof (GRecMutex))) {
#line 52 "../lib/Docklets/DockletManager.vala"
		g_rec_mutex_clear (mutex);
#line 52 "../lib/Docklets/DockletManager.vala"
		memset (mutex, 0, sizeof (GRecMutex));
#line 1982 "SurfaceCache.c"
	}
}

static void
_vala_clear_GRWLock (GRWLock * mutex)
{
	GRWLock zero_mutex = { 0 };
#line 52 "../lib/Docklets/DockletManager.vala"
	if (memcmp (mutex, &zero_mutex, sizeof (GRWLock))) {
#line 52 "../lib/Docklets/DockletManager.vala"
		g_rw_lock_clear (mutex);
#line 52 "../lib/Docklets/DockletManager.vala"
		memset (mutex, 0, sizeof (GRWLock));
#line 1996 "SurfaceCache.c"
	}
}

static void
_vala_clear_GCond (GCond * mutex)
{
	GCond zero_mutex = { 0 };
#line 52 "../lib/Docklets/DockletManager.vala"
	if (memcmp (mutex, &zero_mutex, sizeof (GCond))) {
#line 52 "../lib/Docklets/DockletManager.vala"
		g_cond_clear (mutex);
#line 52 "../lib/Docklets/DockletManager.vala"
		memset (mutex, 0, sizeof (GCond));
#line 2010 "SurfaceCache.c"
	}
}

