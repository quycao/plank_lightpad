/* PlaceholderDockItem.c generated by valac 0.48.17, the Vala compiler
 * generated from PlaceholderDockItem.vala, do not modify */

/**/
/*  Copyright (C) 2014 Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <gdk/gdk.h>
#include <glib.h>
#include <gee.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gi18n-lib.h>

#define PLANK_TYPE_DOCK_ELEMENT (plank_dock_element_get_type ())
#define PLANK_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElement))
#define PLANK_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))
#define PLANK_IS_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_IS_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_DOCK_ELEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))

typedef struct _PlankDockElement PlankDockElement;
typedef struct _PlankDockElementClass PlankDockElementClass;
typedef struct _PlankDockElementPrivate PlankDockElementPrivate;
typedef enum  {
	PLANK_POPUP_BUTTON_NONE = 1 << 0,
	PLANK_POPUP_BUTTON_LEFT = 1 << 1,
	PLANK_POPUP_BUTTON_MIDDLE = 1 << 2,
	PLANK_POPUP_BUTTON_RIGHT = 1 << 3
} PlankPopupButton;

#define PLANK_TYPE_POPUP_BUTTON (plank_popup_button_get_type ())
typedef enum  {
	PLANK_ANIMATION_TYPE_NONE,
	PLANK_ANIMATION_TYPE_BOUNCE,
	PLANK_ANIMATION_TYPE_DARKEN,
	PLANK_ANIMATION_TYPE_LIGHTEN
} PlankAnimationType;

#define PLANK_TYPE_ANIMATION_TYPE (plank_animation_type_get_type ())

#define PLANK_TYPE_DOCK_ITEM (plank_dock_item_get_type ())
#define PLANK_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ITEM, PlankDockItem))
#define PLANK_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ITEM, PlankDockItemClass))
#define PLANK_IS_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ITEM))
#define PLANK_IS_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ITEM))
#define PLANK_DOCK_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ITEM, PlankDockItemClass))

typedef struct _PlankDockItem PlankDockItem;
typedef struct _PlankDockItemClass PlankDockItemClass;
typedef struct _PlankDockItemPrivate PlankDockItemPrivate;

#define PLANK_TYPE_SURFACE (plank_surface_get_type ())
#define PLANK_SURFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_SURFACE, PlankSurface))
#define PLANK_SURFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_SURFACE, PlankSurfaceClass))
#define PLANK_IS_SURFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_SURFACE))
#define PLANK_IS_SURFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_SURFACE))
#define PLANK_SURFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_SURFACE, PlankSurfaceClass))

typedef struct _PlankSurface PlankSurface;
typedef struct _PlankSurfaceClass PlankSurfaceClass;

#define PLANK_TYPE_PLACEHOLDER_DOCK_ITEM (plank_placeholder_dock_item_get_type ())
#define PLANK_PLACEHOLDER_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_PLACEHOLDER_DOCK_ITEM, PlankPlaceholderDockItem))
#define PLANK_PLACEHOLDER_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_PLACEHOLDER_DOCK_ITEM, PlankPlaceholderDockItemClass))
#define PLANK_IS_PLACEHOLDER_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_PLACEHOLDER_DOCK_ITEM))
#define PLANK_IS_PLACEHOLDER_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_PLACEHOLDER_DOCK_ITEM))
#define PLANK_PLACEHOLDER_DOCK_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_PLACEHOLDER_DOCK_ITEM, PlankPlaceholderDockItemClass))

typedef struct _PlankPlaceholderDockItem PlankPlaceholderDockItem;
typedef struct _PlankPlaceholderDockItemClass PlankPlaceholderDockItemClass;
typedef struct _PlankPlaceholderDockItemPrivate PlankPlaceholderDockItemPrivate;
enum  {
	PLANK_PLACEHOLDER_DOCK_ITEM_0_PROPERTY,
	PLANK_PLACEHOLDER_DOCK_ITEM_NUM_PROPERTIES
};
static GParamSpec* plank_placeholder_dock_item_properties[PLANK_PLACEHOLDER_DOCK_ITEM_NUM_PROPERTIES];
typedef enum  {
	PLANK_INDICATOR_STATE_NONE,
	PLANK_INDICATOR_STATE_SINGLE,
	PLANK_INDICATOR_STATE_SINGLE_PLUS
} PlankIndicatorState;

#define PLANK_TYPE_INDICATOR_STATE (plank_indicator_state_get_type ())

struct _PlankDockElement {
	GObject parent_instance;
	PlankDockElementPrivate * priv;
};

struct _PlankDockElementClass {
	GObjectClass parent_class;
	PlankAnimationType (*on_clicked) (PlankDockElement* self, PlankPopupButton button, GdkModifierType mod, guint32 event_time);
	PlankAnimationType (*on_hovered) (PlankDockElement* self);
	PlankAnimationType (*on_scrolled) (PlankDockElement* self, GdkScrollDirection direction, GdkModifierType mod, guint32 event_time);
	GeeArrayList* (*get_menu_items) (PlankDockElement* self);
	gchar* (*get_drop_text) (PlankDockElement* self);
	gboolean (*can_be_removed) (PlankDockElement* self);
	gboolean (*can_accept_drop) (PlankDockElement* self, GeeArrayList* uris);
	gboolean (*accept_drop) (PlankDockElement* self, GeeArrayList* uris);
	gchar* (*unique_id) (PlankDockElement* self);
	void (*reset_buffers) (PlankDockElement* self);
};

struct _PlankDockItem {
	PlankDockElement parent_instance;
	PlankDockItemPrivate * priv;
};

struct _PlankDockItemClass {
	PlankDockElementClass parent_class;
	void (*load_from_launcher) (PlankDockItem* self);
	void (*draw_icon) (PlankDockItem* self, PlankSurface* surface);
	void (*draw_icon_fast) (PlankDockItem* self, PlankSurface* surface);
	gboolean (*is_valid) (PlankDockItem* self);
};

struct _PlankPlaceholderDockItem {
	PlankDockItem parent_instance;
	PlankPlaceholderDockItemPrivate * priv;
};

struct _PlankPlaceholderDockItemClass {
	PlankDockItemClass parent_class;
};

static gpointer plank_placeholder_dock_item_parent_class = NULL;

GType plank_dock_element_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockElement, g_object_unref)
GType plank_popup_button_get_type (void) G_GNUC_CONST;
GType plank_animation_type_get_type (void) G_GNUC_CONST;
GType plank_dock_item_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockItem, g_object_unref)
GType plank_surface_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankSurface, g_object_unref)
GType plank_placeholder_dock_item_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankPlaceholderDockItem, g_object_unref)
PlankAnimationType plank_dock_element_on_clicked (PlankDockElement* self,
                                                  PlankPopupButton button,
                                                  GdkModifierType mod,
                                                  guint32 event_time);
gchar* plank_dock_element_get_drop_text (PlankDockElement* self);
gboolean plank_dock_element_can_be_removed (PlankDockElement* self);
gboolean plank_dock_item_is_valid (PlankDockItem* self);
PlankPlaceholderDockItem* plank_placeholder_dock_item_new (void);
PlankPlaceholderDockItem* plank_placeholder_dock_item_construct (GType object_type);
PlankDockItem* plank_dock_item_construct (GType object_type);
static PlankAnimationType plank_placeholder_dock_item_real_on_clicked (PlankDockElement* base,
                                                                PlankPopupButton button,
                                                                GdkModifierType mod,
                                                                guint32 event_time);
static gchar* plank_placeholder_dock_item_real_get_drop_text (PlankDockElement* base);
static gboolean plank_placeholder_dock_item_real_can_be_removed (PlankDockElement* base);
static gboolean plank_placeholder_dock_item_real_is_valid (PlankDockItem* base);
static GObject * plank_placeholder_dock_item_constructor (GType type,
                                                   guint n_construct_properties,
                                                   GObjectConstructParam * construct_properties);
GType plank_indicator_state_get_type (void) G_GNUC_CONST;
void plank_dock_item_set_Indicator (PlankDockItem* self,
                                    PlankIndicatorState value);
void plank_dock_element_set_Text (PlankDockElement* self,
                                  const gchar* value);
void plank_dock_item_set_Icon (PlankDockItem* self,
                               const gchar* value);
static GType plank_placeholder_dock_item_get_type_once (void);

/**
 * Create a new placeholder dock-item
 */
PlankPlaceholderDockItem*
plank_placeholder_dock_item_construct (GType object_type)
{
	PlankPlaceholderDockItem * self = NULL;
#line 30 "../lib/Items/PlaceholderDockItem.vala"
	self = (PlankPlaceholderDockItem*) plank_dock_item_construct (object_type);
#line 30 "../lib/Items/PlaceholderDockItem.vala"
	return self;
#line 197 "PlaceholderDockItem.c"
}

PlankPlaceholderDockItem*
plank_placeholder_dock_item_new (void)
{
#line 30 "../lib/Items/PlaceholderDockItem.vala"
	return plank_placeholder_dock_item_construct (PLANK_TYPE_PLACEHOLDER_DOCK_ITEM);
#line 205 "PlaceholderDockItem.c"
}

/**
 * {@inheritDoc}
 */
static PlankAnimationType
plank_placeholder_dock_item_real_on_clicked (PlankDockElement* base,
                                             PlankPopupButton button,
                                             GdkModifierType mod,
                                             guint32 event_time)
{
	PlankPlaceholderDockItem * self;
	PlankAnimationType result = 0;
#line 44 "../lib/Items/PlaceholderDockItem.vala"
	self = (PlankPlaceholderDockItem*) base;
#line 46 "../lib/Items/PlaceholderDockItem.vala"
	result = PLANK_ANIMATION_TYPE_NONE;
#line 46 "../lib/Items/PlaceholderDockItem.vala"
	return result;
#line 225 "PlaceholderDockItem.c"
}

static gchar*
plank_placeholder_dock_item_real_get_drop_text (PlankDockElement* base)
{
	PlankPlaceholderDockItem * self;
	gchar* _tmp0_;
	gchar* result = NULL;
#line 49 "../lib/Items/PlaceholderDockItem.vala"
	self = (PlankPlaceholderDockItem*) base;
#line 51 "../lib/Items/PlaceholderDockItem.vala"
	_tmp0_ = g_strdup (_ ("Drop to add to dock"));
#line 51 "../lib/Items/PlaceholderDockItem.vala"
	result = _tmp0_;
#line 51 "../lib/Items/PlaceholderDockItem.vala"
	return result;
#line 242 "PlaceholderDockItem.c"
}

/**
 * {@inheritDoc}
 */
static gboolean
plank_placeholder_dock_item_real_can_be_removed (PlankDockElement* base)
{
	PlankPlaceholderDockItem * self;
	gboolean result = FALSE;
#line 57 "../lib/Items/PlaceholderDockItem.vala"
	self = (PlankPlaceholderDockItem*) base;
#line 59 "../lib/Items/PlaceholderDockItem.vala"
	result = FALSE;
#line 59 "../lib/Items/PlaceholderDockItem.vala"
	return result;
#line 259 "PlaceholderDockItem.c"
}

/**
 * {@inheritDoc}
 */
static gboolean
plank_placeholder_dock_item_real_is_valid (PlankDockItem* base)
{
	PlankPlaceholderDockItem * self;
	gboolean result = FALSE;
#line 65 "../lib/Items/PlaceholderDockItem.vala"
	self = (PlankPlaceholderDockItem*) base;
#line 67 "../lib/Items/PlaceholderDockItem.vala"
	result = TRUE;
#line 67 "../lib/Items/PlaceholderDockItem.vala"
	return result;
#line 276 "PlaceholderDockItem.c"
}

static GObject *
plank_placeholder_dock_item_constructor (GType type,
                                         guint n_construct_properties,
                                         GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	PlankPlaceholderDockItem * self;
#line 34 "../lib/Items/PlaceholderDockItem.vala"
	parent_class = G_OBJECT_CLASS (plank_placeholder_dock_item_parent_class);
#line 34 "../lib/Items/PlaceholderDockItem.vala"
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
#line 34 "../lib/Items/PlaceholderDockItem.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_PLACEHOLDER_DOCK_ITEM, PlankPlaceholderDockItem);
#line 36 "../lib/Items/PlaceholderDockItem.vala"
	plank_dock_item_set_Indicator ((PlankDockItem*) self, PLANK_INDICATOR_STATE_NONE);
#line 37 "../lib/Items/PlaceholderDockItem.vala"
	plank_dock_element_set_Text ((PlankDockElement*) self, _ ("Drop applications or files here"));
#line 38 "../lib/Items/PlaceholderDockItem.vala"
	plank_dock_item_set_Icon ((PlankDockItem*) self, "add");
#line 34 "../lib/Items/PlaceholderDockItem.vala"
	return obj;
#line 301 "PlaceholderDockItem.c"
}

static void
plank_placeholder_dock_item_class_init (PlankPlaceholderDockItemClass * klass,
                                        gpointer klass_data)
{
#line 25 "../lib/Items/PlaceholderDockItem.vala"
	plank_placeholder_dock_item_parent_class = g_type_class_peek_parent (klass);
#line 25 "../lib/Items/PlaceholderDockItem.vala"
	((PlankDockElementClass *) klass)->on_clicked = (PlankAnimationType (*) (PlankDockElement*, PlankPopupButton, GdkModifierType, guint32)) plank_placeholder_dock_item_real_on_clicked;
#line 25 "../lib/Items/PlaceholderDockItem.vala"
	((PlankDockElementClass *) klass)->get_drop_text = (gchar* (*) (PlankDockElement*)) plank_placeholder_dock_item_real_get_drop_text;
#line 25 "../lib/Items/PlaceholderDockItem.vala"
	((PlankDockElementClass *) klass)->can_be_removed = (gboolean (*) (PlankDockElement*)) plank_placeholder_dock_item_real_can_be_removed;
#line 25 "../lib/Items/PlaceholderDockItem.vala"
	((PlankDockItemClass *) klass)->is_valid = (gboolean (*) (PlankDockItem*)) plank_placeholder_dock_item_real_is_valid;
#line 25 "../lib/Items/PlaceholderDockItem.vala"
	G_OBJECT_CLASS (klass)->constructor = plank_placeholder_dock_item_constructor;
#line 320 "PlaceholderDockItem.c"
}

static void
plank_placeholder_dock_item_instance_init (PlankPlaceholderDockItem * self,
                                           gpointer klass)
{
}

/**
 * A dock item as a placeholder for the dock itself if nothing was added yet.
 */
static GType
plank_placeholder_dock_item_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankPlaceholderDockItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_placeholder_dock_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankPlaceholderDockItem), 0, (GInstanceInitFunc) plank_placeholder_dock_item_instance_init, NULL };
	GType plank_placeholder_dock_item_type_id;
	plank_placeholder_dock_item_type_id = g_type_register_static (PLANK_TYPE_DOCK_ITEM, "PlankPlaceholderDockItem", &g_define_type_info, 0);
	return plank_placeholder_dock_item_type_id;
}

GType
plank_placeholder_dock_item_get_type (void)
{
	static volatile gsize plank_placeholder_dock_item_type_id__volatile = 0;
	if (g_once_init_enter (&plank_placeholder_dock_item_type_id__volatile)) {
		GType plank_placeholder_dock_item_type_id;
		plank_placeholder_dock_item_type_id = plank_placeholder_dock_item_get_type_once ();
		g_once_init_leave (&plank_placeholder_dock_item_type_id__volatile, plank_placeholder_dock_item_type_id);
	}
	return plank_placeholder_dock_item_type_id__volatile;
}

