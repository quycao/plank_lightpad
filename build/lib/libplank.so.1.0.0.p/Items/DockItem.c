/* DockItem.c generated by valac 0.48.17, the Vala compiler
 * generated from DockItem.vala, do not modify */

/**/
/*  Copyright (C) 2011-2012 Robert Dyer, Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <gdk/gdk.h>
#include <glib.h>
#include <gee.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <float.h>
#include <math.h>
#include <gio/gio.h>
#include "plank-internal.h"
#include <cairo-gobject.h>

#define PLANK_TYPE_DOCK_ELEMENT (plank_dock_element_get_type ())
#define PLANK_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElement))
#define PLANK_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))
#define PLANK_IS_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_IS_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_DOCK_ELEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))

typedef struct _PlankDockElement PlankDockElement;
typedef struct _PlankDockElementClass PlankDockElementClass;
typedef struct _PlankDockElementPrivate PlankDockElementPrivate;
typedef enum  {
	PLANK_POPUP_BUTTON_NONE = 1 << 0,
	PLANK_POPUP_BUTTON_LEFT = 1 << 1,
	PLANK_POPUP_BUTTON_MIDDLE = 1 << 2,
	PLANK_POPUP_BUTTON_RIGHT = 1 << 3
} PlankPopupButton;

#define PLANK_TYPE_POPUP_BUTTON (plank_popup_button_get_type ())
typedef enum  {
	PLANK_ANIMATION_TYPE_NONE,
	PLANK_ANIMATION_TYPE_BOUNCE,
	PLANK_ANIMATION_TYPE_DARKEN,
	PLANK_ANIMATION_TYPE_LIGHTEN
} PlankAnimationType;

#define PLANK_TYPE_ANIMATION_TYPE (plank_animation_type_get_type ())

#define PLANK_TYPE_DOCK_ITEM (plank_dock_item_get_type ())
#define PLANK_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ITEM, PlankDockItem))
#define PLANK_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ITEM, PlankDockItemClass))
#define PLANK_IS_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ITEM))
#define PLANK_IS_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ITEM))
#define PLANK_DOCK_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ITEM, PlankDockItemClass))

typedef struct _PlankDockItem PlankDockItem;
typedef struct _PlankDockItemClass PlankDockItemClass;
typedef struct _PlankDockItemPrivate PlankDockItemPrivate;

#define PLANK_TYPE_SURFACE (plank_surface_get_type ())
#define PLANK_SURFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_SURFACE, PlankSurface))
#define PLANK_SURFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_SURFACE, PlankSurfaceClass))
#define PLANK_IS_SURFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_SURFACE))
#define PLANK_IS_SURFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_SURFACE))
#define PLANK_SURFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_SURFACE, PlankSurfaceClass))

typedef struct _PlankSurface PlankSurface;
typedef struct _PlankSurfaceClass PlankSurfaceClass;
typedef enum  {
	PLANK_ITEM_STATE_NORMAL = 1 << 0,
	PLANK_ITEM_STATE_ACTIVE = 1 << 1,
	PLANK_ITEM_STATE_URGENT = 1 << 2,
	PLANK_ITEM_STATE_MOVE = 1 << 3,
	PLANK_ITEM_STATE_INVALID = 1 << 4
} PlankItemState;

#define PLANK_TYPE_ITEM_STATE (plank_item_state_get_type ())
typedef enum  {
	PLANK_INDICATOR_STATE_NONE,
	PLANK_INDICATOR_STATE_SINGLE,
	PLANK_INDICATOR_STATE_SINGLE_PLUS
} PlankIndicatorState;

#define PLANK_TYPE_INDICATOR_STATE (plank_indicator_state_get_type ())

#define PLANK_TYPE_COLOR (plank_color_get_type ())
typedef GdkRGBA PlankColor;

#define PLANK_TYPE_PREFERENCES (plank_preferences_get_type ())
#define PLANK_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_PREFERENCES, PlankPreferences))
#define PLANK_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_PREFERENCES, PlankPreferencesClass))
#define PLANK_IS_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_PREFERENCES))
#define PLANK_IS_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_PREFERENCES))
#define PLANK_PREFERENCES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_PREFERENCES, PlankPreferencesClass))

typedef struct _PlankPreferences PlankPreferences;
typedef struct _PlankPreferencesClass PlankPreferencesClass;

#define PLANK_TYPE_DOCK_ITEM_PREFERENCES (plank_dock_item_preferences_get_type ())
#define PLANK_DOCK_ITEM_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ITEM_PREFERENCES, PlankDockItemPreferences))
#define PLANK_DOCK_ITEM_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ITEM_PREFERENCES, PlankDockItemPreferencesClass))
#define PLANK_IS_DOCK_ITEM_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ITEM_PREFERENCES))
#define PLANK_IS_DOCK_ITEM_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ITEM_PREFERENCES))
#define PLANK_DOCK_ITEM_PREFERENCES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ITEM_PREFERENCES, PlankDockItemPreferencesClass))

typedef struct _PlankDockItemPreferences PlankDockItemPreferences;
typedef struct _PlankDockItemPreferencesClass PlankDockItemPreferencesClass;

#define PLANK_TYPE_SURFACE_CACHE (plank_surface_cache_get_type ())
#define PLANK_SURFACE_CACHE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_SURFACE_CACHE, PlankSurfaceCache))
#define PLANK_SURFACE_CACHE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_SURFACE_CACHE, PlankSurfaceCacheClass))
#define PLANK_IS_SURFACE_CACHE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_SURFACE_CACHE))
#define PLANK_IS_SURFACE_CACHE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_SURFACE_CACHE))
#define PLANK_SURFACE_CACHE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_SURFACE_CACHE, PlankSurfaceCacheClass))

typedef struct _PlankSurfaceCache PlankSurfaceCache;
typedef struct _PlankSurfaceCacheClass PlankSurfaceCacheClass;
enum  {
	PLANK_DOCK_ITEM_0_PROPERTY,
	PLANK_DOCK_ITEM_ICON_PROPERTY,
	PLANK_DOCK_ITEM_FORCE_PIXBUF_PROPERTY,
	PLANK_DOCK_ITEM_COUNT_PROPERTY,
	PLANK_DOCK_ITEM_COUNT_VISIBLE_PROPERTY,
	PLANK_DOCK_ITEM_PROGRESS_PROPERTY,
	PLANK_DOCK_ITEM_PROGRESS_VISIBLE_PROPERTY,
	PLANK_DOCK_ITEM_POSITION_PROPERTY,
	PLANK_DOCK_ITEM_LAST_POSITION_PROPERTY,
	PLANK_DOCK_ITEM_STATE_PROPERTY,
	PLANK_DOCK_ITEM_INDICATOR_PROPERTY,
	PLANK_DOCK_ITEM_AVERAGE_ICON_COLOR_PROPERTY,
	PLANK_DOCK_ITEM_DOCK_ITEM_FILENAME_PROPERTY,
	PLANK_DOCK_ITEM_LAUNCHER_PROPERTY,
	PLANK_DOCK_ITEM_PREFS_PROPERTY,
	PLANK_DOCK_ITEM_NUM_PROPERTIES
};
static GParamSpec* plank_dock_item_properties[PLANK_DOCK_ITEM_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef PlankSurface* (*PlankDrawDataFunc) (gint width, gint height, PlankSurface* model, gconstpointer data, gpointer user_data);
typedef PlankSurface* (*PlankDrawFunc) (gint width, gint height, PlankSurface* model, PlankDrawDataFunc draw_data_func, gpointer draw_data_func_target, gpointer user_data);
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _cairo_pattern_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_pattern_destroy (var), NULL)))
typedef enum  {
	PLANK_SURFACE_CACHE_FLAGS_NONE = 0,
	PLANK_SURFACE_CACHE_FLAGS_ALLOW_DOWNSCALE = 1 << 0,
	PLANK_SURFACE_CACHE_FLAGS_ALLOW_UPSCALE = 1 << 1,
	PLANK_SURFACE_CACHE_FLAGS_ALLOW_SCALE = PLANK_SURFACE_CACHE_FLAGS_ALLOW_UPSCALE | PLANK_SURFACE_CACHE_FLAGS_ALLOW_DOWNSCALE,
	PLANK_SURFACE_CACHE_FLAGS_ADAPTIVE_SCALE = 1 << 2
} PlankSurfaceCacheFlags;

#define PLANK_TYPE_SURFACE_CACHE_FLAGS (plank_surface_cache_flags_get_type ())
enum  {
	PLANK_DOCK_ITEM_DELETED_SIGNAL,
	PLANK_DOCK_ITEM_NUM_SIGNALS
};
static guint plank_dock_item_signals[PLANK_DOCK_ITEM_NUM_SIGNALS] = {0};

struct _PlankDockElement {
	GObject parent_instance;
	PlankDockElementPrivate * priv;
};

struct _PlankDockElementClass {
	GObjectClass parent_class;
	PlankAnimationType (*on_clicked) (PlankDockElement* self, PlankPopupButton button, GdkModifierType mod, guint32 event_time);
	PlankAnimationType (*on_hovered) (PlankDockElement* self);
	PlankAnimationType (*on_scrolled) (PlankDockElement* self, GdkScrollDirection direction, GdkModifierType mod, guint32 event_time);
	GeeArrayList* (*get_menu_items) (PlankDockElement* self);
	gchar* (*get_drop_text) (PlankDockElement* self);
	gboolean (*can_be_removed) (PlankDockElement* self);
	gboolean (*can_accept_drop) (PlankDockElement* self, GeeArrayList* uris);
	gboolean (*accept_drop) (PlankDockElement* self, GeeArrayList* uris);
	gchar* (*unique_id) (PlankDockElement* self);
	void (*reset_buffers) (PlankDockElement* self);
};

struct _PlankDockItem {
	PlankDockElement parent_instance;
	PlankDockItemPrivate * priv;
};

struct _PlankDockItemClass {
	PlankDockElementClass parent_class;
	void (*load_from_launcher) (PlankDockItem* self);
	void (*draw_icon) (PlankDockItem* self, PlankSurface* surface);
	void (*draw_icon_fast) (PlankDockItem* self, PlankSurface* surface);
	gboolean (*is_valid) (PlankDockItem* self);
};

struct _PlankDockItemPrivate {
	gchar* _Icon;
	GdkPixbuf* _ForcePixbuf;
	gint64 _Count;
	gboolean _CountVisible;
	gdouble _Progress;
	gboolean _ProgressVisible;
	gint position;
	gint _LastPosition;
	PlankItemState _State;
	PlankIndicatorState _Indicator;
	PlankColor _AverageIconColor;
	PlankDockItemPreferences* _Prefs;
	PlankSurfaceCache* buffer;
	PlankSurfaceCache* background_buffer;
	PlankSurface* foreground_surface;
	GFileMonitor* launcher_file_monitor;
	GFileMonitor* icon_file_monitor;
	gboolean launcher_exists;
	guint removal_timer_id;
};

static gint PlankDockItem_private_offset;
static gpointer plank_dock_item_parent_class = NULL;

GType plank_dock_element_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockElement, g_object_unref)
GType plank_popup_button_get_type (void) G_GNUC_CONST;
GType plank_animation_type_get_type (void) G_GNUC_CONST;
GType plank_dock_item_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockItem, g_object_unref)
GType plank_surface_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankSurface, g_object_unref)
GType plank_item_state_get_type (void) G_GNUC_CONST;
GType plank_indicator_state_get_type (void) G_GNUC_CONST;
GType plank_color_get_type (void) G_GNUC_CONST;
PlankColor* plank_color_dup (const PlankColor* self);
void plank_color_free (PlankColor* self);
GType plank_preferences_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankPreferences, g_object_unref)
GType plank_dock_item_preferences_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockItemPreferences, g_object_unref)
GType plank_surface_cache_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankSurfaceCache, g_object_unref)
void plank_dock_item_load_from_launcher (PlankDockItem* self);
void plank_dock_element_reset_buffers (PlankDockElement* self);
void plank_dock_item_draw_icon (PlankDockItem* self,
                                PlankSurface* surface);
void plank_dock_item_draw_icon_fast (PlankDockItem* self,
                                     PlankSurface* surface);
gboolean plank_dock_item_is_valid (PlankDockItem* self);
void plank_surface_cache_clear (PlankSurfaceCache* self);
PlankDockItemPreferences* plank_dock_item_get_Prefs (PlankDockItem* self);
static void plank_dock_item_handle_deleted (PlankDockItem* self);
static void _plank_dock_item_handle_deleted_plank_preferences_deleted (PlankPreferences* _sender,
                                                                gpointer self);
static void plank_dock_item_handle_launcher_changed (PlankDockItem* self);
static void _plank_dock_item_handle_launcher_changed_g_object_notify (GObject* _sender,
                                                               GParamSpec* pspec,
                                                               gpointer self);
GtkIconTheme* plank_drawing_service_get_icon_theme (void);
static void plank_dock_item_icon_theme_changed (PlankDockItem* self);
static void _plank_dock_item_icon_theme_changed_gtk_icon_theme_changed (GtkIconTheme* _sender,
                                                                 gpointer self);
static void plank_dock_item_icon_changed (PlankDockItem* self);
static void _plank_dock_item_icon_changed_g_object_notify (GObject* _sender,
                                                    GParamSpec* pspec,
                                                    gpointer self);
static void plank_dock_item_reset_foreground_buffer (PlankDockItem* self);
static void _plank_dock_item_reset_foreground_buffer_g_object_notify (GObject* _sender,
                                                               GParamSpec* pspec,
                                                               gpointer self);
static void plank_dock_item_launcher_file_monitor_stop (PlankDockItem* self);
static void plank_dock_item_icon_file_monitor_stop (PlankDockItem* self);
static gboolean plank_dock_item_stop_removal (PlankDockItem* self);
void plank_dock_item_delete (PlankDockItem* self);
PlankDockItem* plank_dock_item_construct (GType object_type);
PlankDockItemPreferences* plank_dock_item_preferences_new (void);
PlankDockItemPreferences* plank_dock_item_preferences_construct (GType object_type);
static void plank_dock_item_real_load_from_launcher (PlankDockItem* self);
static void plank_dock_item_launcher_file_monitor_start (PlankDockItem* self);
void plank_preferences_delete (PlankPreferences* self);
void plank_dock_item_reset_icon_buffer (PlankDockItem* self);
static void plank_dock_item_real_reset_buffers (PlankDockElement* base);
void plank_dock_item_unset_move_state (PlankDockItem* self);
PlankItemState plank_dock_item_get_State (PlankDockItem* self);
void plank_dock_item_set_State (PlankDockItem* self,
                                PlankItemState value);
static gboolean __lambda10_ (PlankDockItem* self);
static gboolean ___lambda10__gsource_func (gpointer self);
GdkPixbuf* plank_dock_item_get_ForcePixbuf (PlankDockItem* self);
static void plank_dock_item_icon_file_monitor_start (PlankDockItem* self);
static void plank_dock_item_icon_file_changed (GFile* f,
                                        GFile* other,
                                        GFileMonitorEvent event,
                                        PlankDockItem* self);
GFile* plank_drawing_service_try_get_icon_file (const gchar* name);
const gchar* plank_dock_item_get_Icon (PlankDockItem* self);
static void _plank_dock_item_icon_file_changed_g_file_monitor_changed (GFileMonitor* _sender,
                                                                GFile* file,
                                                                GFile* other_file,
                                                                GFileMonitorEvent event_type,
                                                                gpointer self);
static void plank_dock_item_launcher_file_changed (GFile* f,
                                            GFile* other,
                                            GFileMonitorEvent event,
                                            PlankDockItem* self);
void plank_logger_verbose (const gchar* msg,
                           ...);
static void plank_dock_item_replace_launcher (PlankDockItem* self,
                                       const gchar* launcher);
void plank_dock_element_set_LastValid (PlankDockElement* self,
                                       gint64 value);
static gboolean plank_dock_item_schedule_removal_if_needed (PlankDockItem* self);
const gchar* plank_dock_item_preferences_get_Launcher (PlankDockItemPreferences* self);
static void _plank_dock_item_launcher_file_changed_g_file_monitor_changed (GFileMonitor* _sender,
                                                                    GFile* file,
                                                                    GFile* other_file,
                                                                    GFileMonitorEvent event_type,
                                                                    gpointer self);
void plank_dock_item_preferences_set_Launcher (PlankDockItemPreferences* self,
                                               const gchar* value);
static gboolean __lambda9_ (PlankDockItem* self);
static gboolean ___lambda9__gsource_func (gpointer self);
PlankSurface* plank_dock_item_get_surface (PlankDockItem* self,
                                           gint width,
                                           gint height,
                                           PlankSurface* model);
PlankSurface* plank_surface_cache_get_surface (PlankSurfaceCache* self,
                                               GType g_type,
                                               GBoxedCopyFunc g_dup_func,
                                               GDestroyNotify g_destroy_func,
                                               gint width,
                                               gint height,
                                               PlankSurface* model,
                                               PlankDrawFunc draw_func,
                                               gpointer draw_func_target,
                                               PlankDrawDataFunc draw_data_func,
                                               gpointer draw_data_func_target);
static PlankSurface* plank_dock_item_internal_get_surface (gint width,
                                                    gint height,
                                                    PlankSurface* model,
                                                    PlankDrawDataFunc draw_data_func,
                                                    gpointer draw_data_func_target,
                                                    PlankDockItem* self);
PlankSurface* plank_surface_new_with_surface (gint width,
                                              gint height,
                                              PlankSurface* model);
PlankSurface* plank_surface_construct_with_surface (GType object_type,
                                                    gint width,
                                                    gint height,
                                                    PlankSurface* model);
void plank_surface_average_color (PlankSurface* self,
                                  PlankColor* result);
void plank_dock_item_set_AverageIconColor (PlankDockItem* self,
                                           PlankColor * value);
PlankSurface* plank_dock_item_get_background_surface (PlankDockItem* self,
                                                      gint width,
                                                      gint height,
                                                      PlankSurface* model,
                                                      PlankDrawDataFunc draw_data_func,
                                                      gpointer draw_data_func_target);
static PlankSurface* plank_dock_item_internal_get_background_surface (gint width,
                                                               gint height,
                                                               PlankSurface* model,
                                                               PlankDrawDataFunc draw_data_func,
                                                               gpointer draw_data_func_target,
                                                               PlankDockItem* self);
PlankSurface* plank_dock_item_get_foreground_surface (PlankDockItem* self,
                                                      gint width,
                                                      gint height,
                                                      PlankSurface* model,
                                                      PlankDrawDataFunc draw_data_func,
                                                      gpointer draw_data_func_target);
gint plank_surface_get_Width (PlankSurface* self);
gint plank_surface_get_Height (PlankSurface* self);
PlankSurface* plank_dock_item_get_surface_copy (PlankDockItem* self,
                                                gint width,
                                                gint height,
                                                PlankSurface* model);
PlankSurface* plank_surface_copy (PlankSurface* self);
static void plank_dock_item_real_draw_icon (PlankDockItem* self,
                                     PlankSurface* surface);
cairo_surface_t* plank_surface_get_Internal (PlankSurface* self);
cairo_surface_t* plank_drawing_service_load_icon_for_scale (const gchar* names,
                                                            gint width,
                                                            gint height,
                                                            gint scale);
GdkPixbuf* plank_drawing_service_ar_scale (GdkPixbuf* source,
                                           gint width,
                                           gint height);
cairo_t* plank_surface_get_Context (PlankSurface* self);
static void plank_dock_item_real_draw_icon_fast (PlankDockItem* self,
                                          PlankSurface* surface);
static gboolean plank_dock_item_real_is_valid (PlankDockItem* self);
void plank_dock_item_copy_values_to (PlankDockItem* self,
                                     PlankDockItem* target);
void plank_dock_item_set_Icon (PlankDockItem* self,
                               const gchar* value);
void plank_dock_item_set_ForcePixbuf (PlankDockItem* self,
                                      GdkPixbuf* value);
gint64 plank_dock_item_get_Count (PlankDockItem* self);
void plank_dock_item_set_Count (PlankDockItem* self,
                                gint64 value);
gboolean plank_dock_item_get_CountVisible (PlankDockItem* self);
void plank_dock_item_set_CountVisible (PlankDockItem* self,
                                       gboolean value);
gdouble plank_dock_item_get_Progress (PlankDockItem* self);
void plank_dock_item_set_Progress (PlankDockItem* self,
                                   gdouble value);
gboolean plank_dock_item_get_ProgressVisible (PlankDockItem* self);
void plank_dock_item_set_ProgressVisible (PlankDockItem* self,
                                          gboolean value);
gint plank_dock_item_get_Position (PlankDockItem* self);
void plank_dock_item_set_Position (PlankDockItem* self,
                                   gint value);
gint plank_dock_item_get_LastPosition (PlankDockItem* self);
void plank_dock_item_set_LastPosition (PlankDockItem* self,
                                       gint value);
void plank_dock_element_set_LastMove (PlankDockElement* self,
                                      gint64 value);
PlankIndicatorState plank_dock_item_get_Indicator (PlankDockItem* self);
void plank_dock_item_set_Indicator (PlankDockItem* self,
                                    PlankIndicatorState value);
void plank_dock_item_get_AverageIconColor (PlankDockItem* self,
                                           PlankColor * result);
static gboolean _gdk_rgba_equal (const GdkRGBA * s1,
                          const GdkRGBA * s2);
gchar* plank_dock_item_get_DockItemFilename (PlankDockItem* self);
gchar* plank_preferences_get_filename (PlankPreferences* self);
const gchar* plank_dock_item_get_Launcher (PlankDockItem* self);
static void plank_dock_item_set_Prefs (PlankDockItem* self,
                                PlankDockItemPreferences* value);
static GObject * plank_dock_item_constructor (GType type,
                                       guint n_construct_properties,
                                       GObjectConstructParam * construct_properties);
GType plank_surface_cache_flags_get_type (void) G_GNUC_CONST;
PlankSurfaceCache* plank_surface_cache_new (GType g_type,
                                            GBoxedCopyFunc g_dup_func,
                                            GDestroyNotify g_destroy_func,
                                            PlankSurfaceCacheFlags flags);
PlankSurfaceCache* plank_surface_cache_construct (GType object_type,
                                                  GType g_type,
                                                  GBoxedCopyFunc g_dup_func,
                                                  GDestroyNotify g_destroy_func,
                                                  PlankSurfaceCacheFlags flags);
static void plank_dock_item_finalize (GObject * obj);
static GType plank_dock_item_get_type_once (void);
static void _vala_plank_dock_item_get_property (GObject * object,
                                         guint property_id,
                                         GValue * value,
                                         GParamSpec * pspec);
static void _vala_plank_dock_item_set_property (GObject * object,
                                         guint property_id,
                                         const GValue * value,
                                         GParamSpec * pspec);

static inline gpointer
plank_dock_item_get_instance_private (PlankDockItem* self)
{
	return G_STRUCT_MEMBER_P (self, PlankDockItem_private_offset);
}

static void
_plank_dock_item_handle_deleted_plank_preferences_deleted (PlankPreferences* _sender,
                                                           gpointer self)
{
#line 168 "../lib/Items/DockItem.vala"
	plank_dock_item_handle_deleted ((PlankDockItem*) self);
#line 476 "DockItem.c"
}

static void
_plank_dock_item_handle_launcher_changed_g_object_notify (GObject* _sender,
                                                          GParamSpec* pspec,
                                                          gpointer self)
{
#line 169 "../lib/Items/DockItem.vala"
	plank_dock_item_handle_launcher_changed ((PlankDockItem*) self);
#line 486 "DockItem.c"
}

static void
_plank_dock_item_icon_theme_changed_gtk_icon_theme_changed (GtkIconTheme* _sender,
                                                            gpointer self)
{
#line 171 "../lib/Items/DockItem.vala"
	plank_dock_item_icon_theme_changed ((PlankDockItem*) self);
#line 495 "DockItem.c"
}

static void
_plank_dock_item_icon_changed_g_object_notify (GObject* _sender,
                                               GParamSpec* pspec,
                                               gpointer self)
{
#line 172 "../lib/Items/DockItem.vala"
	plank_dock_item_icon_changed ((PlankDockItem*) self);
#line 505 "DockItem.c"
}

static void
_plank_dock_item_reset_foreground_buffer_g_object_notify (GObject* _sender,
                                                          GParamSpec* pspec,
                                                          gpointer self)
{
#line 175 "../lib/Items/DockItem.vala"
	plank_dock_item_reset_foreground_buffer ((PlankDockItem*) self);
#line 515 "DockItem.c"
}

/**
 * Creates a new dock item.
 */
PlankDockItem*
plank_dock_item_construct (GType object_type)
{
	PlankDockItem * self = NULL;
	PlankDockItemPreferences* _tmp0_;
	PlankDockItemPreferences* _tmp1_;
#line 138 "../lib/Items/DockItem.vala"
	_tmp0_ = plank_dock_item_preferences_new ();
#line 138 "../lib/Items/DockItem.vala"
	_tmp1_ = _tmp0_;
#line 138 "../lib/Items/DockItem.vala"
	self = (PlankDockItem*) g_object_new (object_type, "Prefs", _tmp1_, NULL);
#line 138 "../lib/Items/DockItem.vala"
	_g_object_unref0 (_tmp1_);
#line 136 "../lib/Items/DockItem.vala"
	return self;
#line 537 "DockItem.c"
}

/**
 * Signal handler called when the underlying preferences file is deleted.
 */
static void
plank_dock_item_handle_deleted (PlankDockItem* self)
{
#line 190 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 192 "../lib/Items/DockItem.vala"
	g_signal_emit (self, plank_dock_item_signals[PLANK_DOCK_ITEM_DELETED_SIGNAL], 0);
#line 550 "DockItem.c"
}

/**
 * Parses the associated launcher and e.g. sets the icon and text from it.
 */
static void
plank_dock_item_real_load_from_launcher (PlankDockItem* self)
{
}

void
plank_dock_item_load_from_launcher (PlankDockItem* self)
{
#line 198 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 198 "../lib/Items/DockItem.vala"
	PLANK_DOCK_ITEM_GET_CLASS (self)->load_from_launcher (self);
#line 568 "DockItem.c"
}

static void
plank_dock_item_handle_launcher_changed (PlankDockItem* self)
{
#line 203 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 205 "../lib/Items/DockItem.vala"
	plank_dock_item_launcher_file_monitor_stop (self);
#line 207 "../lib/Items/DockItem.vala"
	plank_dock_item_load_from_launcher (self);
#line 209 "../lib/Items/DockItem.vala"
	plank_dock_item_launcher_file_monitor_start (self);
#line 582 "DockItem.c"
}

/**
 * Deletes the underlying preferences file.
 */
void
plank_dock_item_delete (PlankDockItem* self)
{
	PlankDockItemPreferences* _tmp0_;
#line 215 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 217 "../lib/Items/DockItem.vala"
	plank_dock_item_launcher_file_monitor_stop (self);
#line 219 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_Prefs;
#line 219 "../lib/Items/DockItem.vala"
	plank_preferences_delete ((PlankPreferences*) _tmp0_);
#line 600 "DockItem.c"
}

/**
 * Resets the buffer for this item's icon and requests a redraw.
 */
void
plank_dock_item_reset_icon_buffer (PlankDockItem* self)
{
	PlankSurfaceCache* _tmp0_;
	PlankSurfaceCache* _tmp1_;
#line 225 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 227 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->buffer;
#line 227 "../lib/Items/DockItem.vala"
	plank_surface_cache_clear (_tmp0_);
#line 228 "../lib/Items/DockItem.vala"
	_tmp1_ = self->priv->background_buffer;
#line 228 "../lib/Items/DockItem.vala"
	plank_surface_cache_clear (_tmp1_);
#line 229 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->foreground_surface);
#line 229 "../lib/Items/DockItem.vala"
	self->priv->foreground_surface = NULL;
#line 231 "../lib/Items/DockItem.vala"
	g_signal_emit_by_name ((PlankDockElement*) self, "needs-redraw");
#line 627 "DockItem.c"
}

/**
 * Resets the buffers for this item's icon.
 */
static void
plank_dock_item_real_reset_buffers (PlankDockElement* base)
{
	PlankDockItem * self;
	PlankSurfaceCache* _tmp0_;
#line 237 "../lib/Items/DockItem.vala"
	self = (PlankDockItem*) base;
#line 239 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->background_buffer;
#line 239 "../lib/Items/DockItem.vala"
	plank_surface_cache_clear (_tmp0_);
#line 240 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->foreground_surface);
#line 240 "../lib/Items/DockItem.vala"
	self->priv->foreground_surface = NULL;
#line 648 "DockItem.c"
}

void
plank_dock_item_unset_move_state (PlankDockItem* self)
{
	PlankItemState _tmp0_;
#line 243 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 245 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_State;
#line 245 "../lib/Items/DockItem.vala"
	plank_dock_item_set_State (self, _tmp0_ & (~PLANK_ITEM_STATE_MOVE));
#line 661 "DockItem.c"
}

static void
plank_dock_item_reset_foreground_buffer (PlankDockItem* self)
{
#line 248 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 250 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->foreground_surface);
#line 250 "../lib/Items/DockItem.vala"
	self->priv->foreground_surface = NULL;
#line 252 "../lib/Items/DockItem.vala"
	g_signal_emit_by_name ((PlankDockElement*) self, "needs-redraw");
#line 675 "DockItem.c"
}

static gboolean
__lambda10_ (PlankDockItem* self)
{
	gboolean result = FALSE;
#line 260 "../lib/Items/DockItem.vala"
	plank_dock_item_reset_icon_buffer (self);
#line 261 "../lib/Items/DockItem.vala"
	result = FALSE;
#line 261 "../lib/Items/DockItem.vala"
	return result;
#line 688 "DockItem.c"
}

static gboolean
___lambda10__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda10_ ((PlankDockItem*) self);
#line 259 "../lib/Items/DockItem.vala"
	return result;
#line 698 "DockItem.c"
}

static void
plank_dock_item_icon_theme_changed (PlankDockItem* self)
{
#line 255 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 259 "../lib/Items/DockItem.vala"
	gdk_threads_add_idle_full (G_PRIORITY_LOW, ___lambda10__gsource_func, g_object_ref (self), g_object_unref);
#line 708 "DockItem.c"
}

static void
plank_dock_item_icon_changed (PlankDockItem* self)
{
	GdkPixbuf* _tmp0_;
#line 265 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 267 "../lib/Items/DockItem.vala"
	plank_dock_item_icon_file_monitor_stop (self);
#line 269 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_ForcePixbuf;
#line 269 "../lib/Items/DockItem.vala"
	if (_tmp0_ == NULL) {
#line 270 "../lib/Items/DockItem.vala"
		plank_dock_item_icon_file_monitor_start (self);
#line 725 "DockItem.c"
	}
#line 272 "../lib/Items/DockItem.vala"
	plank_dock_item_reset_icon_buffer (self);
#line 729 "DockItem.c"
}

static void
plank_dock_item_icon_file_changed (GFile* f,
                                   GFile* other,
                                   GFileMonitorEvent event,
                                   PlankDockItem* self)
{
#line 276 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 276 "../lib/Items/DockItem.vala"
	g_return_if_fail (f != NULL);
#line 278 "../lib/Items/DockItem.vala"
	switch (event) {
#line 278 "../lib/Items/DockItem.vala"
		case G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT:
#line 746 "DockItem.c"
		{
#line 280 "../lib/Items/DockItem.vala"
			plank_dock_item_reset_icon_buffer (self);
#line 281 "../lib/Items/DockItem.vala"
			break;
#line 752 "DockItem.c"
		}
		default:
		{
#line 283 "../lib/Items/DockItem.vala"
			break;
#line 758 "DockItem.c"
		}
	}
}

static void
_plank_dock_item_icon_file_changed_g_file_monitor_changed (GFileMonitor* _sender,
                                                           GFile* file,
                                                           GFile* other_file,
                                                           GFileMonitorEvent event_type,
                                                           gpointer self)
{
#line 295 "../lib/Items/DockItem.vala"
	plank_dock_item_icon_file_changed (file, other_file, event_type, (PlankDockItem*) self);
#line 772 "DockItem.c"
}

static void
plank_dock_item_icon_file_monitor_start (PlankDockItem* self)
{
	GFile* icon_file = NULL;
	const gchar* _tmp0_;
	GFile* _tmp1_;
	gboolean _tmp2_ = FALSE;
	GFile* _tmp3_;
	GError* _inner_error0_ = NULL;
#line 287 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 289 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_Icon;
#line 289 "../lib/Items/DockItem.vala"
	_tmp1_ = plank_drawing_service_try_get_icon_file (_tmp0_);
#line 289 "../lib/Items/DockItem.vala"
	icon_file = _tmp1_;
#line 290 "../lib/Items/DockItem.vala"
	_tmp3_ = icon_file;
#line 290 "../lib/Items/DockItem.vala"
	if (_tmp3_ == NULL) {
#line 290 "../lib/Items/DockItem.vala"
		_tmp2_ = TRUE;
#line 798 "DockItem.c"
	} else {
		GFile* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
#line 290 "../lib/Items/DockItem.vala"
		_tmp4_ = icon_file;
#line 290 "../lib/Items/DockItem.vala"
		_tmp5_ = g_file_get_uri_scheme (_tmp4_);
#line 290 "../lib/Items/DockItem.vala"
		_tmp6_ = _tmp5_;
#line 290 "../lib/Items/DockItem.vala"
		_tmp2_ = g_strcmp0 (_tmp6_, "file") != 0;
#line 290 "../lib/Items/DockItem.vala"
		_g_free0 (_tmp6_);
#line 813 "DockItem.c"
	}
#line 290 "../lib/Items/DockItem.vala"
	if (_tmp2_) {
#line 291 "../lib/Items/DockItem.vala"
		_g_object_unref0 (icon_file);
#line 291 "../lib/Items/DockItem.vala"
		return;
#line 821 "DockItem.c"
	}
	{
		GFileMonitor* _tmp7_ = NULL;
		GFile* _tmp8_;
		GFileMonitor* _tmp9_;
		GFileMonitor* _tmp10_;
		GFileMonitor* _tmp11_;
#line 294 "../lib/Items/DockItem.vala"
		_tmp8_ = icon_file;
#line 294 "../lib/Items/DockItem.vala"
		_tmp9_ = g_file_monitor_file (_tmp8_, 0, NULL, &_inner_error0_);
#line 294 "../lib/Items/DockItem.vala"
		_tmp7_ = _tmp9_;
#line 294 "../lib/Items/DockItem.vala"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 837 "DockItem.c"
			goto __catch0_g_error;
		}
#line 294 "../lib/Items/DockItem.vala"
		_tmp10_ = _tmp7_;
#line 294 "../lib/Items/DockItem.vala"
		_tmp7_ = NULL;
#line 294 "../lib/Items/DockItem.vala"
		_g_object_unref0 (self->priv->icon_file_monitor);
#line 294 "../lib/Items/DockItem.vala"
		self->priv->icon_file_monitor = _tmp10_;
#line 295 "../lib/Items/DockItem.vala"
		_tmp11_ = self->priv->icon_file_monitor;
#line 295 "../lib/Items/DockItem.vala"
		g_signal_connect_object (_tmp11_, "changed", (GCallback) _plank_dock_item_icon_file_changed_g_file_monitor_changed, self, 0);
#line 293 "../lib/Items/DockItem.vala"
		_g_object_unref0 (_tmp7_);
#line 854 "DockItem.c"
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		gchar* _tmp12_ = NULL;
		GFile* _tmp13_;
		gchar* _tmp14_;
		GError* _tmp16_;
		const gchar* _tmp17_;
#line 293 "../lib/Items/DockItem.vala"
		e = _inner_error0_;
#line 293 "../lib/Items/DockItem.vala"
		_inner_error0_ = NULL;
#line 297 "../lib/Items/DockItem.vala"
		_tmp13_ = icon_file;
#line 297 "../lib/Items/DockItem.vala"
		_tmp14_ = g_file_get_path (_tmp13_);
#line 297 "../lib/Items/DockItem.vala"
		_tmp12_ = _tmp14_;
#line 297 "../lib/Items/DockItem.vala"
		if (_tmp12_ == NULL) {
#line 877 "DockItem.c"
			gchar* _tmp15_;
#line 297 "../lib/Items/DockItem.vala"
			_tmp15_ = g_strdup ("");
#line 297 "../lib/Items/DockItem.vala"
			_g_free0 (_tmp12_);
#line 297 "../lib/Items/DockItem.vala"
			_tmp12_ = _tmp15_;
#line 885 "DockItem.c"
		}
#line 297 "../lib/Items/DockItem.vala"
		g_critical ("DockItem.vala:297: Unable to watch the icon file '%s'", _tmp12_);
#line 298 "../lib/Items/DockItem.vala"
		_tmp16_ = e;
#line 298 "../lib/Items/DockItem.vala"
		_tmp17_ = _tmp16_->message;
#line 298 "../lib/Items/DockItem.vala"
		g_debug ("DockItem.vala:298: %s", _tmp17_);
#line 293 "../lib/Items/DockItem.vala"
		_g_free0 (_tmp12_);
#line 293 "../lib/Items/DockItem.vala"
		_g_error_free0 (e);
#line 899 "DockItem.c"
	}
	__finally0:
#line 293 "../lib/Items/DockItem.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 293 "../lib/Items/DockItem.vala"
		_g_object_unref0 (icon_file);
#line 293 "../lib/Items/DockItem.vala"
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 293 "../lib/Items/DockItem.vala"
		g_clear_error (&_inner_error0_);
#line 293 "../lib/Items/DockItem.vala"
		return;
#line 912 "DockItem.c"
	}
#line 287 "../lib/Items/DockItem.vala"
	_g_object_unref0 (icon_file);
#line 916 "DockItem.c"
}

static void
plank_dock_item_icon_file_monitor_stop (PlankDockItem* self)
{
	GFileMonitor* _tmp0_;
	GFileMonitor* _tmp1_;
	guint _tmp2_;
	GFileMonitor* _tmp3_;
#line 302 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 304 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->icon_file_monitor;
#line 304 "../lib/Items/DockItem.vala"
	if (_tmp0_ == NULL) {
#line 305 "../lib/Items/DockItem.vala"
		return;
#line 934 "DockItem.c"
	}
#line 307 "../lib/Items/DockItem.vala"
	_tmp1_ = self->priv->icon_file_monitor;
#line 307 "../lib/Items/DockItem.vala"
	g_signal_parse_name ("changed", g_file_monitor_get_type (), &_tmp2_, NULL, FALSE);
#line 307 "../lib/Items/DockItem.vala"
	g_signal_handlers_disconnect_matched (_tmp1_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, 0, NULL, (GCallback) _plank_dock_item_icon_file_changed_g_file_monitor_changed, self);
#line 308 "../lib/Items/DockItem.vala"
	_tmp3_ = self->priv->icon_file_monitor;
#line 308 "../lib/Items/DockItem.vala"
	g_file_monitor_cancel (_tmp3_);
#line 309 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->icon_file_monitor);
#line 309 "../lib/Items/DockItem.vala"
	self->priv->icon_file_monitor = NULL;
#line 950 "DockItem.c"
}

static void
plank_dock_item_launcher_file_changed (GFile* f,
                                       GFile* other,
                                       GFileMonitorEvent event,
                                       PlankDockItem* self)
{
#line 313 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 313 "../lib/Items/DockItem.vala"
	g_return_if_fail (f != NULL);
#line 315 "../lib/Items/DockItem.vala"
	switch (event) {
#line 315 "../lib/Items/DockItem.vala"
		case G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT:
#line 967 "DockItem.c"
		{
			gchar* _tmp0_;
			gchar* _tmp1_;
#line 317 "../lib/Items/DockItem.vala"
			_tmp0_ = g_file_get_uri (f);
#line 317 "../lib/Items/DockItem.vala"
			_tmp1_ = _tmp0_;
#line 317 "../lib/Items/DockItem.vala"
			plank_logger_verbose ("Launcher file '%s' changed, reloading", _tmp1_, NULL);
#line 317 "../lib/Items/DockItem.vala"
			_g_free0 (_tmp1_);
#line 319 "../lib/Items/DockItem.vala"
			plank_dock_item_load_from_launcher (self);
#line 320 "../lib/Items/DockItem.vala"
			break;
#line 983 "DockItem.c"
		}
#line 315 "../lib/Items/DockItem.vala"
		case G_FILE_MONITOR_EVENT_MOVED:
#line 987 "DockItem.c"
		{
			gchar* launcher = NULL;
			gchar* _tmp2_;
			gchar* _tmp3_;
			gchar* _tmp4_;
			const gchar* _tmp5_;
			const gchar* _tmp6_;
#line 322 "../lib/Items/DockItem.vala"
			if (other == NULL) {
#line 323 "../lib/Items/DockItem.vala"
				break;
#line 999 "DockItem.c"
			}
#line 324 "../lib/Items/DockItem.vala"
			_tmp2_ = g_file_get_uri (other);
#line 324 "../lib/Items/DockItem.vala"
			launcher = _tmp2_;
#line 325 "../lib/Items/DockItem.vala"
			_tmp3_ = g_file_get_uri (f);
#line 325 "../lib/Items/DockItem.vala"
			_tmp4_ = _tmp3_;
#line 325 "../lib/Items/DockItem.vala"
			_tmp5_ = launcher;
#line 325 "../lib/Items/DockItem.vala"
			plank_logger_verbose ("Launcher file '%s' moved to '%s'", _tmp4_, _tmp5_, NULL);
#line 325 "../lib/Items/DockItem.vala"
			_g_free0 (_tmp4_);
#line 327 "../lib/Items/DockItem.vala"
			_tmp6_ = launcher;
#line 327 "../lib/Items/DockItem.vala"
			plank_dock_item_replace_launcher (self, _tmp6_);
#line 329 "../lib/Items/DockItem.vala"
			plank_dock_item_load_from_launcher (self);
#line 330 "../lib/Items/DockItem.vala"
			_g_free0 (launcher);
#line 330 "../lib/Items/DockItem.vala"
			break;
#line 1025 "DockItem.c"
		}
#line 315 "../lib/Items/DockItem.vala"
		case G_FILE_MONITOR_EVENT_DELETED:
#line 1029 "DockItem.c"
		{
			gchar* _tmp7_;
			gchar* _tmp8_;
			PlankItemState _tmp9_;
#line 332 "../lib/Items/DockItem.vala"
			_tmp7_ = g_file_get_uri (f);
#line 332 "../lib/Items/DockItem.vala"
			_tmp8_ = _tmp7_;
#line 332 "../lib/Items/DockItem.vala"
			g_debug ("DockItem.vala:332: Launcher file '%s' deleted, item is invalid now", _tmp8_);
#line 332 "../lib/Items/DockItem.vala"
			_g_free0 (_tmp8_);
#line 334 "../lib/Items/DockItem.vala"
			self->priv->launcher_exists = FALSE;
#line 335 "../lib/Items/DockItem.vala"
			plank_dock_element_set_LastValid ((PlankDockElement*) self, g_get_monotonic_time ());
#line 336 "../lib/Items/DockItem.vala"
			_tmp9_ = self->priv->_State;
#line 336 "../lib/Items/DockItem.vala"
			plank_dock_item_set_State (self, _tmp9_ | PLANK_ITEM_STATE_INVALID);
#line 338 "../lib/Items/DockItem.vala"
			plank_dock_item_schedule_removal_if_needed (self);
#line 339 "../lib/Items/DockItem.vala"
			break;
#line 1054 "DockItem.c"
		}
#line 315 "../lib/Items/DockItem.vala"
		case G_FILE_MONITOR_EVENT_CREATED:
#line 1058 "DockItem.c"
		{
			gchar* _tmp10_;
			gchar* _tmp11_;
			PlankItemState _tmp12_;
#line 341 "../lib/Items/DockItem.vala"
			_tmp10_ = g_file_get_uri (f);
#line 341 "../lib/Items/DockItem.vala"
			_tmp11_ = _tmp10_;
#line 341 "../lib/Items/DockItem.vala"
			g_debug ("DockItem.vala:341: Launcher file '%s' created, item is valid again", _tmp11_);
#line 341 "../lib/Items/DockItem.vala"
			_g_free0 (_tmp11_);
#line 343 "../lib/Items/DockItem.vala"
			self->priv->launcher_exists = TRUE;
#line 344 "../lib/Items/DockItem.vala"
			_tmp12_ = self->priv->_State;
#line 344 "../lib/Items/DockItem.vala"
			plank_dock_item_set_State (self, _tmp12_ & (~PLANK_ITEM_STATE_INVALID));
#line 346 "../lib/Items/DockItem.vala"
			plank_dock_item_stop_removal (self);
#line 347 "../lib/Items/DockItem.vala"
			break;
#line 1081 "DockItem.c"
		}
		default:
		{
#line 349 "../lib/Items/DockItem.vala"
			break;
#line 1087 "DockItem.c"
		}
	}
#line 352 "../lib/Items/DockItem.vala"
	g_signal_emit_by_name ((PlankDockElement*) self, "needs-redraw");
#line 1092 "DockItem.c"
}

static void
_plank_dock_item_launcher_file_changed_g_file_monitor_changed (GFileMonitor* _sender,
                                                               GFile* file,
                                                               GFile* other_file,
                                                               GFileMonitorEvent event_type,
                                                               gpointer self)
{
#line 370 "../lib/Items/DockItem.vala"
	plank_dock_item_launcher_file_changed (file, other_file, event_type, (PlankDockItem*) self);
#line 1104 "DockItem.c"
}

static void
plank_dock_item_launcher_file_monitor_start (PlankDockItem* self)
{
	GFileMonitor* _tmp0_;
	const gchar* launcher = NULL;
	PlankDockItemPreferences* _tmp1_;
	const gchar* _tmp2_;
	const gchar* _tmp3_;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp5_;
	GError* _inner_error0_ = NULL;
#line 355 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 357 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->launcher_file_monitor;
#line 357 "../lib/Items/DockItem.vala"
	if (_tmp0_ != NULL) {
#line 358 "../lib/Items/DockItem.vala"
		return;
#line 1126 "DockItem.c"
	}
#line 360 "../lib/Items/DockItem.vala"
	_tmp1_ = self->priv->_Prefs;
#line 360 "../lib/Items/DockItem.vala"
	_tmp2_ = plank_dock_item_preferences_get_Launcher (_tmp1_);
#line 360 "../lib/Items/DockItem.vala"
	_tmp3_ = _tmp2_;
#line 360 "../lib/Items/DockItem.vala"
	launcher = _tmp3_;
#line 361 "../lib/Items/DockItem.vala"
	_tmp5_ = launcher;
#line 361 "../lib/Items/DockItem.vala"
	if (_tmp5_ == NULL) {
#line 361 "../lib/Items/DockItem.vala"
		_tmp4_ = TRUE;
#line 1142 "DockItem.c"
	} else {
		const gchar* _tmp6_;
#line 361 "../lib/Items/DockItem.vala"
		_tmp6_ = launcher;
#line 361 "../lib/Items/DockItem.vala"
		_tmp4_ = g_strcmp0 (_tmp6_, "") == 0;
#line 1149 "DockItem.c"
	}
#line 361 "../lib/Items/DockItem.vala"
	if (_tmp4_) {
#line 1153 "DockItem.c"
		PlankItemState _tmp7_;
#line 362 "../lib/Items/DockItem.vala"
		_tmp7_ = self->priv->_State;
#line 362 "../lib/Items/DockItem.vala"
		plank_dock_item_set_State (self, _tmp7_ & (~PLANK_ITEM_STATE_INVALID));
#line 363 "../lib/Items/DockItem.vala"
		return;
#line 1161 "DockItem.c"
	}
	{
		GFile* launcher_file = NULL;
		const gchar* _tmp8_;
		GFile* _tmp9_;
		GFile* _tmp10_;
		GFileMonitor* _tmp11_ = NULL;
		GFile* _tmp12_;
		GFileMonitor* _tmp13_;
		GFileMonitor* _tmp14_;
		GFileMonitor* _tmp15_;
#line 367 "../lib/Items/DockItem.vala"
		_tmp8_ = launcher;
#line 367 "../lib/Items/DockItem.vala"
		_tmp9_ = g_file_new_for_uri (_tmp8_);
#line 367 "../lib/Items/DockItem.vala"
		launcher_file = _tmp9_;
#line 368 "../lib/Items/DockItem.vala"
		_tmp10_ = launcher_file;
#line 368 "../lib/Items/DockItem.vala"
		self->priv->launcher_exists = g_file_query_exists (_tmp10_, NULL);
#line 369 "../lib/Items/DockItem.vala"
		_tmp12_ = launcher_file;
#line 369 "../lib/Items/DockItem.vala"
		_tmp13_ = g_file_monitor_file (_tmp12_, G_FILE_MONITOR_SEND_MOVED, NULL, &_inner_error0_);
#line 369 "../lib/Items/DockItem.vala"
		_tmp11_ = _tmp13_;
#line 369 "../lib/Items/DockItem.vala"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 369 "../lib/Items/DockItem.vala"
			_g_object_unref0 (launcher_file);
#line 1193 "DockItem.c"
			goto __catch0_g_error;
		}
#line 369 "../lib/Items/DockItem.vala"
		_tmp14_ = _tmp11_;
#line 369 "../lib/Items/DockItem.vala"
		_tmp11_ = NULL;
#line 369 "../lib/Items/DockItem.vala"
		_g_object_unref0 (self->priv->launcher_file_monitor);
#line 369 "../lib/Items/DockItem.vala"
		self->priv->launcher_file_monitor = _tmp14_;
#line 370 "../lib/Items/DockItem.vala"
		_tmp15_ = self->priv->launcher_file_monitor;
#line 370 "../lib/Items/DockItem.vala"
		g_signal_connect_object (_tmp15_, "changed", (GCallback) _plank_dock_item_launcher_file_changed_g_file_monitor_changed, self, 0);
#line 366 "../lib/Items/DockItem.vala"
		_g_object_unref0 (_tmp11_);
#line 366 "../lib/Items/DockItem.vala"
		_g_object_unref0 (launcher_file);
#line 1212 "DockItem.c"
	}
	goto __finally0;
	__catch0_g_error:
	{
		const gchar* _tmp16_;
#line 366 "../lib/Items/DockItem.vala"
		g_clear_error (&_inner_error0_);
#line 372 "../lib/Items/DockItem.vala"
		_tmp16_ = launcher;
#line 372 "../lib/Items/DockItem.vala"
		g_warning ("DockItem.vala:372: Unable to watch the launcher file '%s'", _tmp16_);
#line 1224 "DockItem.c"
	}
	__finally0:
#line 366 "../lib/Items/DockItem.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 366 "../lib/Items/DockItem.vala"
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 366 "../lib/Items/DockItem.vala"
		g_clear_error (&_inner_error0_);
#line 366 "../lib/Items/DockItem.vala"
		return;
#line 1235 "DockItem.c"
	}
}

static void
plank_dock_item_launcher_file_monitor_stop (PlankDockItem* self)
{
	GFileMonitor* _tmp0_;
	GFileMonitor* _tmp1_;
	guint _tmp2_;
	GFileMonitor* _tmp3_;
#line 376 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 378 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->launcher_file_monitor;
#line 378 "../lib/Items/DockItem.vala"
	if (_tmp0_ == NULL) {
#line 379 "../lib/Items/DockItem.vala"
		return;
#line 1254 "DockItem.c"
	}
#line 381 "../lib/Items/DockItem.vala"
	_tmp1_ = self->priv->launcher_file_monitor;
#line 381 "../lib/Items/DockItem.vala"
	g_signal_parse_name ("changed", g_file_monitor_get_type (), &_tmp2_, NULL, FALSE);
#line 381 "../lib/Items/DockItem.vala"
	g_signal_handlers_disconnect_matched (_tmp1_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, 0, NULL, (GCallback) _plank_dock_item_launcher_file_changed_g_file_monitor_changed, self);
#line 382 "../lib/Items/DockItem.vala"
	_tmp3_ = self->priv->launcher_file_monitor;
#line 382 "../lib/Items/DockItem.vala"
	g_file_monitor_cancel (_tmp3_);
#line 383 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->launcher_file_monitor);
#line 383 "../lib/Items/DockItem.vala"
	self->priv->launcher_file_monitor = NULL;
#line 1270 "DockItem.c"
}

static void
plank_dock_item_replace_launcher (PlankDockItem* self,
                                  const gchar* launcher)
{
	PlankDockItemPreferences* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
	PlankDockItemPreferences* _tmp3_;
	guint _tmp4_;
	GQuark _tmp5_;
	PlankDockItemPreferences* _tmp6_;
	PlankDockItemPreferences* _tmp7_;
#line 386 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 386 "../lib/Items/DockItem.vala"
	g_return_if_fail (launcher != NULL);
#line 388 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_Prefs;
#line 388 "../lib/Items/DockItem.vala"
	_tmp1_ = plank_dock_item_preferences_get_Launcher (_tmp0_);
#line 388 "../lib/Items/DockItem.vala"
	_tmp2_ = _tmp1_;
#line 388 "../lib/Items/DockItem.vala"
	if (g_strcmp0 (launcher, _tmp2_) == 0) {
#line 389 "../lib/Items/DockItem.vala"
		return;
#line 1299 "DockItem.c"
	}
#line 391 "../lib/Items/DockItem.vala"
	plank_dock_item_launcher_file_monitor_stop (self);
#line 392 "../lib/Items/DockItem.vala"
	_tmp3_ = self->priv->_Prefs;
#line 392 "../lib/Items/DockItem.vala"
	g_signal_parse_name ("notify::Launcher", G_TYPE_OBJECT, &_tmp4_, &_tmp5_, TRUE);
#line 392 "../lib/Items/DockItem.vala"
	g_signal_handlers_disconnect_matched ((GObject*) _tmp3_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp4_, _tmp5_, NULL, (GCallback) _plank_dock_item_handle_launcher_changed_g_object_notify, self);
#line 393 "../lib/Items/DockItem.vala"
	_tmp6_ = self->priv->_Prefs;
#line 393 "../lib/Items/DockItem.vala"
	plank_dock_item_preferences_set_Launcher (_tmp6_, launcher);
#line 394 "../lib/Items/DockItem.vala"
	_tmp7_ = self->priv->_Prefs;
#line 394 "../lib/Items/DockItem.vala"
	g_signal_connect_object ((GObject*) _tmp7_, "notify::Launcher", (GCallback) _plank_dock_item_handle_launcher_changed_g_object_notify, self, 0);
#line 395 "../lib/Items/DockItem.vala"
	plank_dock_item_launcher_file_monitor_start (self);
#line 1319 "DockItem.c"
}

static gboolean
__lambda9_ (PlankDockItem* self)
{
	gboolean result = FALSE;
#line 407 "../lib/Items/DockItem.vala"
	self->priv->removal_timer_id = 0U;
#line 408 "../lib/Items/DockItem.vala"
	if (!plank_dock_item_is_valid (self)) {
#line 409 "../lib/Items/DockItem.vala"
		plank_dock_item_delete (self);
#line 1332 "DockItem.c"
	}
#line 410 "../lib/Items/DockItem.vala"
	result = FALSE;
#line 410 "../lib/Items/DockItem.vala"
	return result;
#line 1338 "DockItem.c"
}

static gboolean
___lambda9__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda9_ ((PlankDockItem*) self);
#line 406 "../lib/Items/DockItem.vala"
	return result;
#line 1348 "DockItem.c"
}

static gboolean
plank_dock_item_schedule_removal_if_needed (PlankDockItem* self)
{
	gboolean _tmp0_ = FALSE;
	GFileMonitor* _tmp1_;
	gboolean result = FALSE;
#line 398 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 400 "../lib/Items/DockItem.vala"
	if (self->priv->removal_timer_id > 0U) {
#line 401 "../lib/Items/DockItem.vala"
		result = TRUE;
#line 401 "../lib/Items/DockItem.vala"
		return result;
#line 1365 "DockItem.c"
	}
#line 403 "../lib/Items/DockItem.vala"
	_tmp1_ = self->priv->launcher_file_monitor;
#line 403 "../lib/Items/DockItem.vala"
	if (_tmp1_ == NULL) {
#line 403 "../lib/Items/DockItem.vala"
		_tmp0_ = TRUE;
#line 1373 "DockItem.c"
	} else {
#line 403 "../lib/Items/DockItem.vala"
		_tmp0_ = plank_dock_item_is_valid (self);
#line 1377 "DockItem.c"
	}
#line 403 "../lib/Items/DockItem.vala"
	if (_tmp0_) {
#line 404 "../lib/Items/DockItem.vala"
		result = FALSE;
#line 404 "../lib/Items/DockItem.vala"
		return result;
#line 1385 "DockItem.c"
	}
#line 406 "../lib/Items/DockItem.vala"
	self->priv->removal_timer_id = gdk_threads_add_timeout (PLANK_ITEM_INVALID_DURATION, ___lambda9__gsource_func, self);
#line 413 "../lib/Items/DockItem.vala"
	result = TRUE;
#line 413 "../lib/Items/DockItem.vala"
	return result;
#line 1393 "DockItem.c"
}

static gboolean
plank_dock_item_stop_removal (PlankDockItem* self)
{
	gboolean result = FALSE;
#line 416 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 418 "../lib/Items/DockItem.vala"
	if (self->priv->removal_timer_id == 0U) {
#line 419 "../lib/Items/DockItem.vala"
		result = FALSE;
#line 419 "../lib/Items/DockItem.vala"
		return result;
#line 1408 "DockItem.c"
	}
#line 421 "../lib/Items/DockItem.vala"
	g_source_remove (self->priv->removal_timer_id);
#line 422 "../lib/Items/DockItem.vala"
	self->priv->removal_timer_id = 0U;
#line 424 "../lib/Items/DockItem.vala"
	result = TRUE;
#line 424 "../lib/Items/DockItem.vala"
	return result;
#line 1418 "DockItem.c"
}

/**
 * Returns the surface for this item.
 *
 * It might trigger an internal redraw if the requested size
 * isn't cached yet.
 *
 * @param width width of the icon surface
 * @param height height of the icon surface
 * @param model existing surface to use as basis of new surface
 * @return the surface for this item which may not be changed
 */
PlankSurface*
plank_dock_item_get_surface (PlankDockItem* self,
                             gint width,
                             gint height,
                             PlankSurface* model)
{
	PlankSurfaceCache* _tmp0_;
	PlankSurface* _tmp1_;
	PlankSurface* result = NULL;
#line 438 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 438 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (model != NULL, NULL);
#line 440 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->buffer;
#line 440 "../lib/Items/DockItem.vala"
	_tmp1_ = plank_surface_cache_get_surface (_tmp0_, PLANK_TYPE_DOCK_ITEM, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, width, height, model, (PlankDrawFunc) plank_dock_item_internal_get_surface, self, NULL, NULL);
#line 440 "../lib/Items/DockItem.vala"
	result = _tmp1_;
#line 440 "../lib/Items/DockItem.vala"
	return result;
#line 1453 "DockItem.c"
}

static PlankSurface*
plank_dock_item_internal_get_surface (gint width,
                                      gint height,
                                      PlankSurface* model,
                                      PlankDrawDataFunc draw_data_func,
                                      gpointer draw_data_func_target,
                                      PlankDockItem* self)
{
	PlankSurface* surface = NULL;
	PlankSurface* _tmp0_;
	PlankColor _tmp1_ = {0};
	PlankSurface* result = NULL;
#line 444 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 444 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (model != NULL, NULL);
#line 446 "../lib/Items/DockItem.vala"
	_tmp0_ = plank_surface_new_with_surface (width, height, model);
#line 446 "../lib/Items/DockItem.vala"
	surface = _tmp0_;
#line 448 "../lib/Items/DockItem.vala"
	plank_logger_verbose ("DockItem.draw_icon (width = %i, height = %i)", width, height, NULL);
#line 449 "../lib/Items/DockItem.vala"
	plank_dock_item_draw_icon (self, surface);
#line 451 "../lib/Items/DockItem.vala"
	plank_surface_average_color (surface, &_tmp1_);
#line 451 "../lib/Items/DockItem.vala"
	plank_dock_item_set_AverageIconColor (self, &_tmp1_);
#line 453 "../lib/Items/DockItem.vala"
	result = surface;
#line 453 "../lib/Items/DockItem.vala"
	return result;
#line 1488 "DockItem.c"
}

/**
 * Returns the background surface for this item.
 *
 * The draw_func may pass through the given previously computed surface
 * or change it as needed. This surface will be buffered internally.
 *
 * Passing null as draw_func will destroy the internal background buffer.
 *
 * @param draw_data_func function which creates/changes the background surface
 * @return the background surface of this item which may not be changed
 */
PlankSurface*
plank_dock_item_get_background_surface (PlankDockItem* self,
                                        gint width,
                                        gint height,
                                        PlankSurface* model,
                                        PlankDrawDataFunc draw_data_func,
                                        gpointer draw_data_func_target)
{
	PlankSurfaceCache* _tmp0_;
	PlankSurface* _tmp1_;
	PlankSurface* result = NULL;
#line 467 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 467 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (model != NULL, NULL);
#line 469 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->background_buffer;
#line 469 "../lib/Items/DockItem.vala"
	_tmp1_ = plank_surface_cache_get_surface (_tmp0_, PLANK_TYPE_DOCK_ITEM, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, width, height, model, (PlankDrawFunc) plank_dock_item_internal_get_background_surface, self, (PlankDrawDataFunc) draw_data_func, draw_data_func_target);
#line 469 "../lib/Items/DockItem.vala"
	result = _tmp1_;
#line 469 "../lib/Items/DockItem.vala"
	return result;
#line 1525 "DockItem.c"
}

static PlankSurface*
plank_dock_item_internal_get_background_surface (gint width,
                                                 gint height,
                                                 PlankSurface* model,
                                                 PlankDrawDataFunc draw_data_func,
                                                 gpointer draw_data_func_target,
                                                 PlankDockItem* self)
{
	PlankSurface* _tmp0_;
	PlankSurface* result = NULL;
#line 473 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 473 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (model != NULL, NULL);
#line 475 "../lib/Items/DockItem.vala"
	if (draw_data_func == NULL) {
#line 476 "../lib/Items/DockItem.vala"
		result = NULL;
#line 476 "../lib/Items/DockItem.vala"
		return result;
#line 1548 "DockItem.c"
	}
#line 478 "../lib/Items/DockItem.vala"
	_tmp0_ = draw_data_func (width, height, model, self, draw_data_func_target);
#line 478 "../lib/Items/DockItem.vala"
	result = _tmp0_;
#line 478 "../lib/Items/DockItem.vala"
	return result;
#line 1556 "DockItem.c"
}

/**
 * Returns the foreground surface for this item.
 *
 * The draw_func may pass through the given previously computed surface
 * or change it as needed. This surface will be buffered internally.
 *
 * Passing null as draw_func will destroy the internal foreground buffer.
 *
 * @param draw_data_func function which creates/changes the foreground surface
 * @return the background surface of this item which may not be changed
 */
static gpointer
_g_object_ref0 (gpointer self)
{
#line 501 "../lib/Items/DockItem.vala"
	return self ? g_object_ref (self) : NULL;
#line 1575 "DockItem.c"
}

PlankSurface*
plank_dock_item_get_foreground_surface (PlankDockItem* self,
                                        gint width,
                                        gint height,
                                        PlankSurface* model,
                                        PlankDrawDataFunc draw_data_func,
                                        gpointer draw_data_func_target)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	PlankSurface* _tmp2_;
	PlankSurface* _tmp11_;
	PlankSurface* _tmp12_;
	PlankSurface* _tmp13_;
	PlankSurface* result = NULL;
#line 492 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 492 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (model != NULL, NULL);
#line 494 "../lib/Items/DockItem.vala"
	if (draw_data_func == NULL) {
#line 495 "../lib/Items/DockItem.vala"
		_g_object_unref0 (self->priv->foreground_surface);
#line 495 "../lib/Items/DockItem.vala"
		self->priv->foreground_surface = NULL;
#line 496 "../lib/Items/DockItem.vala"
		result = NULL;
#line 496 "../lib/Items/DockItem.vala"
		return result;
#line 1607 "DockItem.c"
	}
#line 499 "../lib/Items/DockItem.vala"
	_tmp2_ = self->priv->foreground_surface;
#line 499 "../lib/Items/DockItem.vala"
	if (_tmp2_ != NULL) {
#line 1613 "DockItem.c"
		PlankSurface* _tmp3_;
		gint _tmp4_;
		gint _tmp5_;
#line 500 "../lib/Items/DockItem.vala"
		_tmp3_ = self->priv->foreground_surface;
#line 500 "../lib/Items/DockItem.vala"
		_tmp4_ = plank_surface_get_Width (_tmp3_);
#line 500 "../lib/Items/DockItem.vala"
		_tmp5_ = _tmp4_;
#line 500 "../lib/Items/DockItem.vala"
		_tmp1_ = _tmp5_ == width;
#line 1625 "DockItem.c"
	} else {
#line 499 "../lib/Items/DockItem.vala"
		_tmp1_ = FALSE;
#line 1629 "DockItem.c"
	}
#line 499 "../lib/Items/DockItem.vala"
	if (_tmp1_) {
#line 1633 "DockItem.c"
		PlankSurface* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
#line 500 "../lib/Items/DockItem.vala"
		_tmp6_ = self->priv->foreground_surface;
#line 500 "../lib/Items/DockItem.vala"
		_tmp7_ = plank_surface_get_Height (_tmp6_);
#line 500 "../lib/Items/DockItem.vala"
		_tmp8_ = _tmp7_;
#line 500 "../lib/Items/DockItem.vala"
		_tmp0_ = _tmp8_ == height;
#line 1645 "DockItem.c"
	} else {
#line 499 "../lib/Items/DockItem.vala"
		_tmp0_ = FALSE;
#line 1649 "DockItem.c"
	}
#line 499 "../lib/Items/DockItem.vala"
	if (_tmp0_) {
#line 1653 "DockItem.c"
		PlankSurface* _tmp9_;
		PlankSurface* _tmp10_;
#line 501 "../lib/Items/DockItem.vala"
		_tmp9_ = self->priv->foreground_surface;
#line 501 "../lib/Items/DockItem.vala"
		_tmp10_ = _g_object_ref0 (_tmp9_);
#line 501 "../lib/Items/DockItem.vala"
		result = _tmp10_;
#line 501 "../lib/Items/DockItem.vala"
		return result;
#line 1664 "DockItem.c"
	}
#line 503 "../lib/Items/DockItem.vala"
	_tmp11_ = draw_data_func (width, height, model, self, draw_data_func_target);
#line 503 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->foreground_surface);
#line 503 "../lib/Items/DockItem.vala"
	self->priv->foreground_surface = _tmp11_;
#line 505 "../lib/Items/DockItem.vala"
	_tmp12_ = self->priv->foreground_surface;
#line 505 "../lib/Items/DockItem.vala"
	_tmp13_ = _g_object_ref0 (_tmp12_);
#line 505 "../lib/Items/DockItem.vala"
	result = _tmp13_;
#line 505 "../lib/Items/DockItem.vala"
	return result;
#line 1680 "DockItem.c"
}

/**
 * Returns a copy of the surface for this item.
 *
 * It will trigger an internal redraw if the requested size
 * isn't matching the cache.
 *
 * @param width width of the icon surface
 * @param height height of the icon surface
 * @param model existing surface to use as basis of new surface
 * @return the copied surface for this item
 */
PlankSurface*
plank_dock_item_get_surface_copy (PlankDockItem* self,
                                  gint width,
                                  gint height,
                                  PlankSurface* model)
{
	PlankSurface* _tmp0_;
	PlankSurface* _tmp1_;
	PlankSurface* _tmp2_;
	PlankSurface* _tmp3_;
	PlankSurface* result = NULL;
#line 519 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 519 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (model != NULL, NULL);
#line 521 "../lib/Items/DockItem.vala"
	_tmp0_ = plank_dock_item_get_surface (self, width, height, model);
#line 521 "../lib/Items/DockItem.vala"
	_tmp1_ = _tmp0_;
#line 521 "../lib/Items/DockItem.vala"
	_tmp2_ = plank_surface_copy (_tmp1_);
#line 521 "../lib/Items/DockItem.vala"
	_tmp3_ = _tmp2_;
#line 521 "../lib/Items/DockItem.vala"
	_g_object_unref0 (_tmp1_);
#line 521 "../lib/Items/DockItem.vala"
	result = _tmp3_;
#line 521 "../lib/Items/DockItem.vala"
	return result;
#line 1723 "DockItem.c"
}

/**
 * Draws the item's icon onto a surface.
 *
 * @param surface the surface to draw on
 */
static void
plank_dock_item_real_draw_icon (PlankDockItem* self,
                                PlankSurface* surface)
{
	cairo_surface_t* icon = NULL;
	GdkPixbuf* pbuf = NULL;
	GdkPixbuf* _tmp0_;
	GdkPixbuf* _tmp1_;
	GdkPixbuf* _tmp2_;
	cairo_t* cr = NULL;
	cairo_t* _tmp21_;
	cairo_t* _tmp22_;
	GdkPixbuf* _tmp23_;
#line 529 "../lib/Items/DockItem.vala"
	g_return_if_fail (surface != NULL);
#line 531 "../lib/Items/DockItem.vala"
	icon = NULL;
#line 532 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_ForcePixbuf;
#line 532 "../lib/Items/DockItem.vala"
	_tmp1_ = _g_object_ref0 (_tmp0_);
#line 532 "../lib/Items/DockItem.vala"
	pbuf = _tmp1_;
#line 533 "../lib/Items/DockItem.vala"
	_tmp2_ = pbuf;
#line 533 "../lib/Items/DockItem.vala"
	if (_tmp2_ == NULL) {
#line 1758 "DockItem.c"
		gdouble x_scale = 0.0;
		gdouble y_scale = 0.0;
		cairo_surface_t* _tmp3_;
		cairo_surface_t* _tmp4_;
		gdouble _tmp5_ = 0.0;
		gdouble _tmp6_ = 0.0;
		const gchar* _tmp7_;
		gint _tmp8_;
		gint _tmp9_;
		gint _tmp10_;
		gint _tmp11_;
		cairo_surface_t* _tmp12_;
		cairo_surface_t* _tmp13_;
#line 534 "../lib/Items/DockItem.vala"
		x_scale = 1.0;
#line 534 "../lib/Items/DockItem.vala"
		y_scale = 1.0;
#line 535 "../lib/Items/DockItem.vala"
		_tmp3_ = plank_surface_get_Internal (surface);
#line 535 "../lib/Items/DockItem.vala"
		_tmp4_ = _tmp3_;
#line 535 "../lib/Items/DockItem.vala"
		cairo_surface_get_device_scale (_tmp4_, &_tmp5_, &_tmp6_);
#line 535 "../lib/Items/DockItem.vala"
		x_scale = _tmp5_;
#line 535 "../lib/Items/DockItem.vala"
		y_scale = _tmp6_;
#line 536 "../lib/Items/DockItem.vala"
		_tmp7_ = self->priv->_Icon;
#line 536 "../lib/Items/DockItem.vala"
		_tmp8_ = plank_surface_get_Width (surface);
#line 536 "../lib/Items/DockItem.vala"
		_tmp9_ = _tmp8_;
#line 536 "../lib/Items/DockItem.vala"
		_tmp10_ = plank_surface_get_Height (surface);
#line 536 "../lib/Items/DockItem.vala"
		_tmp11_ = _tmp10_;
#line 536 "../lib/Items/DockItem.vala"
		_tmp12_ = plank_drawing_service_load_icon_for_scale (_tmp7_, _tmp9_, _tmp11_, (gint) MAX (x_scale, y_scale));
#line 536 "../lib/Items/DockItem.vala"
		_cairo_surface_destroy0 (icon);
#line 536 "../lib/Items/DockItem.vala"
		icon = _tmp12_;
#line 537 "../lib/Items/DockItem.vala"
		_tmp13_ = icon;
#line 537 "../lib/Items/DockItem.vala"
		if (_tmp13_ != NULL) {
#line 1806 "DockItem.c"
			cairo_surface_t* _tmp14_;
#line 538 "../lib/Items/DockItem.vala"
			_tmp14_ = icon;
#line 538 "../lib/Items/DockItem.vala"
			cairo_surface_set_device_scale (_tmp14_, 1.0, 1.0);
#line 1812 "DockItem.c"
		}
	} else {
		GdkPixbuf* _tmp15_;
		gint _tmp16_;
		gint _tmp17_;
		gint _tmp18_;
		gint _tmp19_;
		GdkPixbuf* _tmp20_;
#line 540 "../lib/Items/DockItem.vala"
		_tmp15_ = pbuf;
#line 540 "../lib/Items/DockItem.vala"
		_tmp16_ = plank_surface_get_Width (surface);
#line 540 "../lib/Items/DockItem.vala"
		_tmp17_ = _tmp16_;
#line 540 "../lib/Items/DockItem.vala"
		_tmp18_ = plank_surface_get_Height (surface);
#line 540 "../lib/Items/DockItem.vala"
		_tmp19_ = _tmp18_;
#line 540 "../lib/Items/DockItem.vala"
		_tmp20_ = plank_drawing_service_ar_scale (_tmp15_, _tmp17_, _tmp19_);
#line 540 "../lib/Items/DockItem.vala"
		_g_object_unref0 (pbuf);
#line 540 "../lib/Items/DockItem.vala"
		pbuf = _tmp20_;
#line 1837 "DockItem.c"
	}
#line 543 "../lib/Items/DockItem.vala"
	_tmp21_ = plank_surface_get_Context (surface);
#line 543 "../lib/Items/DockItem.vala"
	_tmp22_ = _tmp21_;
#line 543 "../lib/Items/DockItem.vala"
	cr = _tmp22_;
#line 545 "../lib/Items/DockItem.vala"
	_tmp23_ = pbuf;
#line 545 "../lib/Items/DockItem.vala"
	if (_tmp23_ != NULL) {
#line 1849 "DockItem.c"
		cairo_t* _tmp24_;
		GdkPixbuf* _tmp25_;
		gint _tmp26_;
		gint _tmp27_;
		GdkPixbuf* _tmp28_;
		gint _tmp29_;
		gint _tmp30_;
		gint _tmp31_;
		gint _tmp32_;
		GdkPixbuf* _tmp33_;
		gint _tmp34_;
		gint _tmp35_;
		cairo_t* _tmp36_;
#line 546 "../lib/Items/DockItem.vala"
		_tmp24_ = cr;
#line 546 "../lib/Items/DockItem.vala"
		_tmp25_ = pbuf;
#line 546 "../lib/Items/DockItem.vala"
		_tmp26_ = plank_surface_get_Width (surface);
#line 546 "../lib/Items/DockItem.vala"
		_tmp27_ = _tmp26_;
#line 546 "../lib/Items/DockItem.vala"
		_tmp28_ = pbuf;
#line 546 "../lib/Items/DockItem.vala"
		_tmp29_ = gdk_pixbuf_get_width (_tmp28_);
#line 546 "../lib/Items/DockItem.vala"
		_tmp30_ = _tmp29_;
#line 546 "../lib/Items/DockItem.vala"
		_tmp31_ = plank_surface_get_Height (surface);
#line 546 "../lib/Items/DockItem.vala"
		_tmp32_ = _tmp31_;
#line 546 "../lib/Items/DockItem.vala"
		_tmp33_ = pbuf;
#line 546 "../lib/Items/DockItem.vala"
		_tmp34_ = gdk_pixbuf_get_height (_tmp33_);
#line 546 "../lib/Items/DockItem.vala"
		_tmp35_ = _tmp34_;
#line 546 "../lib/Items/DockItem.vala"
		gdk_cairo_set_source_pixbuf (_tmp24_, _tmp25_, (gdouble) ((_tmp27_ - _tmp30_) / 2), (gdouble) ((_tmp32_ - _tmp35_) / 2));
#line 547 "../lib/Items/DockItem.vala"
		_tmp36_ = cr;
#line 547 "../lib/Items/DockItem.vala"
		cairo_paint (_tmp36_);
#line 1893 "DockItem.c"
	} else {
		cairo_surface_t* _tmp37_;
#line 548 "../lib/Items/DockItem.vala"
		_tmp37_ = icon;
#line 548 "../lib/Items/DockItem.vala"
		if (_tmp37_ != NULL) {
#line 1900 "DockItem.c"
			cairo_t* _tmp38_;
			cairo_surface_t* _tmp39_;
			cairo_t* _tmp40_;
#line 549 "../lib/Items/DockItem.vala"
			_tmp38_ = cr;
#line 549 "../lib/Items/DockItem.vala"
			_tmp39_ = icon;
#line 549 "../lib/Items/DockItem.vala"
			cairo_set_source_surface (_tmp38_, _tmp39_, (gdouble) 0, (gdouble) 0);
#line 550 "../lib/Items/DockItem.vala"
			_tmp40_ = cr;
#line 550 "../lib/Items/DockItem.vala"
			cairo_paint (_tmp40_);
#line 1914 "DockItem.c"
		} else {
#line 552 "../lib/Items/DockItem.vala"
			g_warn_if_reached ();
#line 1918 "DockItem.c"
		}
	}
#line 529 "../lib/Items/DockItem.vala"
	_g_object_unref0 (pbuf);
#line 529 "../lib/Items/DockItem.vala"
	_cairo_surface_destroy0 (icon);
#line 1925 "DockItem.c"
}

void
plank_dock_item_draw_icon (PlankDockItem* self,
                           PlankSurface* surface)
{
#line 529 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 529 "../lib/Items/DockItem.vala"
	PLANK_DOCK_ITEM_GET_CLASS (self)->draw_icon (self, surface);
#line 1936 "DockItem.c"
}

/**
 * Draws a placeholder icon onto a surface.
 * This method should be considered time-critical!
 * Make sure to only use simple drawing routines, and do not rely on external resources!
 *
 * @param surface the surface to draw on
 */
static void
plank_dock_item_real_draw_icon_fast (PlankDockItem* self,
                                     PlankSurface* surface)
{
	cairo_t* cr = NULL;
	cairo_t* _tmp0_;
	cairo_t* _tmp1_;
	gint width = 0;
	gint _tmp2_;
	gint _tmp3_;
	gint height = 0;
	gint _tmp4_;
	gint _tmp5_;
	gint radius = 0;
	gint line_width_half = 0;
	cairo_pattern_t* rg = NULL;
	cairo_pattern_t* _tmp6_;
#line 563 "../lib/Items/DockItem.vala"
	g_return_if_fail (surface != NULL);
#line 565 "../lib/Items/DockItem.vala"
	_tmp0_ = plank_surface_get_Context (surface);
#line 565 "../lib/Items/DockItem.vala"
	_tmp1_ = _tmp0_;
#line 565 "../lib/Items/DockItem.vala"
	cr = _tmp1_;
#line 566 "../lib/Items/DockItem.vala"
	_tmp2_ = plank_surface_get_Width (surface);
#line 566 "../lib/Items/DockItem.vala"
	_tmp3_ = _tmp2_;
#line 566 "../lib/Items/DockItem.vala"
	width = _tmp3_;
#line 567 "../lib/Items/DockItem.vala"
	_tmp4_ = plank_surface_get_Height (surface);
#line 567 "../lib/Items/DockItem.vala"
	_tmp5_ = _tmp4_;
#line 567 "../lib/Items/DockItem.vala"
	height = _tmp5_;
#line 568 "../lib/Items/DockItem.vala"
	radius = (width / 2) - 1;
#line 570 "../lib/Items/DockItem.vala"
	line_width_half = 1;
#line 572 "../lib/Items/DockItem.vala"
	cairo_move_to (cr, (gdouble) radius, (gdouble) line_width_half);
#line 573 "../lib/Items/DockItem.vala"
	cairo_arc (cr, (gdouble) (radius + line_width_half), (gdouble) (radius + line_width_half), (gdouble) radius, (gdouble) 0, 2 * G_PI);
#line 574 "../lib/Items/DockItem.vala"
	cairo_close_path (cr);
#line 576 "../lib/Items/DockItem.vala"
	cairo_set_source_rgba (cr, (gdouble) 1, (gdouble) 1, (gdouble) 1, 0.2);
#line 577 "../lib/Items/DockItem.vala"
	cairo_set_line_width (cr, (gdouble) (2 * line_width_half));
#line 578 "../lib/Items/DockItem.vala"
	cairo_stroke_preserve (cr);
#line 580 "../lib/Items/DockItem.vala"
	_tmp6_ = cairo_pattern_create_radial ((gdouble) (width / 2), (gdouble) height, (gdouble) (height / 8), (gdouble) (width / 2), (gdouble) height, (gdouble) height);
#line 580 "../lib/Items/DockItem.vala"
	rg = _tmp6_;
#line 581 "../lib/Items/DockItem.vala"
	cairo_pattern_add_color_stop_rgba (rg, (gdouble) 0, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.6);
#line 582 "../lib/Items/DockItem.vala"
	cairo_pattern_add_color_stop_rgba (rg, (gdouble) 1, (gdouble) 0, (gdouble) 0, (gdouble) 0, 0.3);
#line 584 "../lib/Items/DockItem.vala"
	cairo_set_source (cr, rg);
#line 585 "../lib/Items/DockItem.vala"
	cairo_fill (cr);
#line 563 "../lib/Items/DockItem.vala"
	_cairo_pattern_destroy0 (rg);
#line 2013 "DockItem.c"
}

void
plank_dock_item_draw_icon_fast (PlankDockItem* self,
                                PlankSurface* surface)
{
#line 563 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 563 "../lib/Items/DockItem.vala"
	PLANK_DOCK_ITEM_GET_CLASS (self)->draw_icon_fast (self, surface);
#line 2024 "DockItem.c"
}

/**
 * Check the validity of this item.
 *
 * @return Whether or not this item is valid for the .dockitem given
 */
static gboolean
plank_dock_item_real_is_valid (PlankDockItem* self)
{
	gboolean _tmp0_ = FALSE;
	gboolean result = FALSE;
#line 595 "../lib/Items/DockItem.vala"
	if (self->priv->launcher_exists) {
#line 595 "../lib/Items/DockItem.vala"
		_tmp0_ = TRUE;
#line 2041 "DockItem.c"
	} else {
		PlankDockItemPreferences* _tmp1_;
		const gchar* _tmp2_;
		const gchar* _tmp3_;
#line 595 "../lib/Items/DockItem.vala"
		_tmp1_ = self->priv->_Prefs;
#line 595 "../lib/Items/DockItem.vala"
		_tmp2_ = plank_dock_item_preferences_get_Launcher (_tmp1_);
#line 595 "../lib/Items/DockItem.vala"
		_tmp3_ = _tmp2_;
#line 595 "../lib/Items/DockItem.vala"
		_tmp0_ = g_strcmp0 (_tmp3_, "") == 0;
#line 2054 "DockItem.c"
	}
#line 595 "../lib/Items/DockItem.vala"
	result = _tmp0_;
#line 595 "../lib/Items/DockItem.vala"
	return result;
#line 2060 "DockItem.c"
}

gboolean
plank_dock_item_is_valid (PlankDockItem* self)
{
#line 593 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 593 "../lib/Items/DockItem.vala"
	return PLANK_DOCK_ITEM_GET_CLASS (self)->is_valid (self);
#line 2070 "DockItem.c"
}

/**
 * Copy all property value of this dockitem instance to target instance.
 *
 * @param target the dockitem to copy the values to
 */
void
plank_dock_item_copy_values_to (PlankDockItem* self,
                                PlankDockItem* target)
{
	GParamSpec** properties = NULL;
	GObjectClass* _tmp0_;
	guint _tmp1_ = 0;
	GParamSpec** _tmp2_;
	gint properties_length1;
	gint _properties_size_;
	GParamSpec** _tmp3_;
	gint _tmp3__length1;
#line 603 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 603 "../lib/Items/DockItem.vala"
	g_return_if_fail (target != NULL);
#line 605 "../lib/Items/DockItem.vala"
	_tmp0_ = G_OBJECT_GET_CLASS ((GObject*) self);
#line 605 "../lib/Items/DockItem.vala"
	_tmp2_ = g_object_class_list_properties (_tmp0_, &_tmp1_);
#line 605 "../lib/Items/DockItem.vala"
	properties = _tmp2_;
#line 605 "../lib/Items/DockItem.vala"
	properties_length1 = _tmp1_;
#line 605 "../lib/Items/DockItem.vala"
	_properties_size_ = properties_length1;
#line 607 "../lib/Items/DockItem.vala"
	_tmp3_ = properties;
#line 607 "../lib/Items/DockItem.vala"
	_tmp3__length1 = properties_length1;
#line 2108 "DockItem.c"
	{
		GParamSpec** prop_collection = NULL;
		gint prop_collection_length1 = 0;
		gint _prop_collection_size_ = 0;
		gint prop_it = 0;
#line 607 "../lib/Items/DockItem.vala"
		prop_collection = _tmp3_;
#line 607 "../lib/Items/DockItem.vala"
		prop_collection_length1 = _tmp3__length1;
#line 607 "../lib/Items/DockItem.vala"
		for (prop_it = 0; prop_it < prop_collection_length1; prop_it = prop_it + 1) {
#line 2120 "DockItem.c"
			GParamSpec* prop = NULL;
#line 607 "../lib/Items/DockItem.vala"
			prop = prop_collection[prop_it];
#line 2124 "DockItem.c"
			{
				gboolean _tmp4_ = FALSE;
				GParamSpec* _tmp5_;
				GParamFlags _tmp6_;
				const gchar* name = NULL;
				GParamSpec* _tmp9_;
				const gchar* _tmp10_;
				const gchar* _tmp11_;
				GType type = 0UL;
				GParamSpec* _tmp12_;
				GValue val = {0};
				GValue _tmp13_ = {0};
				const gchar* _tmp14_;
				const gchar* _tmp15_;
				GValue _tmp16_;
#line 609 "../lib/Items/DockItem.vala"
				_tmp5_ = prop;
#line 609 "../lib/Items/DockItem.vala"
				_tmp6_ = _tmp5_->flags;
#line 609 "../lib/Items/DockItem.vala"
				if ((_tmp6_ & G_PARAM_WRITABLE) == 0) {
#line 609 "../lib/Items/DockItem.vala"
					_tmp4_ = TRUE;
#line 2148 "DockItem.c"
				} else {
					GParamSpec* _tmp7_;
					GParamFlags _tmp8_;
#line 610 "../lib/Items/DockItem.vala"
					_tmp7_ = prop;
#line 610 "../lib/Items/DockItem.vala"
					_tmp8_ = _tmp7_->flags;
#line 610 "../lib/Items/DockItem.vala"
					_tmp4_ = (_tmp8_ & G_PARAM_CONSTRUCT_ONLY) != 0;
#line 2158 "DockItem.c"
				}
#line 609 "../lib/Items/DockItem.vala"
				if (_tmp4_) {
#line 611 "../lib/Items/DockItem.vala"
					continue;
#line 2164 "DockItem.c"
				}
#line 613 "../lib/Items/DockItem.vala"
				_tmp9_ = prop;
#line 613 "../lib/Items/DockItem.vala"
				_tmp10_ = g_param_spec_get_name (_tmp9_);
#line 613 "../lib/Items/DockItem.vala"
				name = _tmp10_;
#line 616 "../lib/Items/DockItem.vala"
				_tmp11_ = name;
#line 616 "../lib/Items/DockItem.vala"
				if (g_strcmp0 (_tmp11_, "Container") == 0) {
#line 617 "../lib/Items/DockItem.vala"
					continue;
#line 2178 "DockItem.c"
				}
#line 619 "../lib/Items/DockItem.vala"
				_tmp12_ = prop;
#line 619 "../lib/Items/DockItem.vala"
				type = _tmp12_->value_type;
#line 620 "../lib/Items/DockItem.vala"
				g_value_init (&_tmp13_, type);
#line 620 "../lib/Items/DockItem.vala"
				val = _tmp13_;
#line 621 "../lib/Items/DockItem.vala"
				_tmp14_ = name;
#line 621 "../lib/Items/DockItem.vala"
				g_object_get_property ((GObject*) self, _tmp14_, &val);
#line 622 "../lib/Items/DockItem.vala"
				_tmp15_ = name;
#line 622 "../lib/Items/DockItem.vala"
				_tmp16_ = val;
#line 622 "../lib/Items/DockItem.vala"
				g_object_set_property ((GObject*) target, _tmp15_, &_tmp16_);
#line 607 "../lib/Items/DockItem.vala"
				G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
#line 2200 "DockItem.c"
			}
		}
	}
#line 603 "../lib/Items/DockItem.vala"
	properties = (g_free (properties), NULL);
#line 2206 "DockItem.c"
}

const gchar*
plank_dock_item_get_Icon (PlankDockItem* self)
{
	const gchar* result;
	const gchar* _tmp0_;
#line 35 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 35 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_Icon;
#line 35 "../lib/Items/DockItem.vala"
	result = _tmp0_;
#line 35 "../lib/Items/DockItem.vala"
	return result;
#line 2222 "DockItem.c"
}

void
plank_dock_item_set_Icon (PlankDockItem* self,
                          const gchar* value)
{
	gchar* old_value;
#line 35 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 35 "../lib/Items/DockItem.vala"
	old_value = plank_dock_item_get_Icon (self);
#line 35 "../lib/Items/DockItem.vala"
	if (g_strcmp0 (value, old_value) != 0) {
#line 2236 "DockItem.c"
		gchar* _tmp0_;
#line 35 "../lib/Items/DockItem.vala"
		_tmp0_ = g_strdup (value);
#line 35 "../lib/Items/DockItem.vala"
		_g_free0 (self->priv->_Icon);
#line 35 "../lib/Items/DockItem.vala"
		self->priv->_Icon = _tmp0_;
#line 35 "../lib/Items/DockItem.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_item_properties[PLANK_DOCK_ITEM_ICON_PROPERTY]);
#line 2246 "DockItem.c"
	}
}

GdkPixbuf*
plank_dock_item_get_ForcePixbuf (PlankDockItem* self)
{
	GdkPixbuf* result;
	GdkPixbuf* _tmp0_;
#line 37 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 37 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_ForcePixbuf;
#line 37 "../lib/Items/DockItem.vala"
	result = _tmp0_;
#line 37 "../lib/Items/DockItem.vala"
	return result;
#line 2263 "DockItem.c"
}

void
plank_dock_item_set_ForcePixbuf (PlankDockItem* self,
                                 GdkPixbuf* value)
{
	GdkPixbuf* old_value;
#line 37 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 37 "../lib/Items/DockItem.vala"
	old_value = plank_dock_item_get_ForcePixbuf (self);
#line 37 "../lib/Items/DockItem.vala"
	if (old_value != value) {
#line 2277 "DockItem.c"
		GdkPixbuf* _tmp0_;
#line 37 "../lib/Items/DockItem.vala"
		_tmp0_ = _g_object_ref0 (value);
#line 37 "../lib/Items/DockItem.vala"
		_g_object_unref0 (self->priv->_ForcePixbuf);
#line 37 "../lib/Items/DockItem.vala"
		self->priv->_ForcePixbuf = _tmp0_;
#line 37 "../lib/Items/DockItem.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_item_properties[PLANK_DOCK_ITEM_FORCE_PIXBUF_PROPERTY]);
#line 2287 "DockItem.c"
	}
}

gint64
plank_dock_item_get_Count (PlankDockItem* self)
{
	gint64 result;
#line 42 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, 0LL);
#line 42 "../lib/Items/DockItem.vala"
	result = self->priv->_Count;
#line 42 "../lib/Items/DockItem.vala"
	return result;
#line 2301 "DockItem.c"
}

void
plank_dock_item_set_Count (PlankDockItem* self,
                           gint64 value)
{
	gint64 old_value;
#line 42 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 42 "../lib/Items/DockItem.vala"
	old_value = plank_dock_item_get_Count (self);
#line 42 "../lib/Items/DockItem.vala"
	if (old_value != value) {
#line 42 "../lib/Items/DockItem.vala"
		self->priv->_Count = value;
#line 42 "../lib/Items/DockItem.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_item_properties[PLANK_DOCK_ITEM_COUNT_PROPERTY]);
#line 2319 "DockItem.c"
	}
}

gboolean
plank_dock_item_get_CountVisible (PlankDockItem* self)
{
	gboolean result;
#line 47 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 47 "../lib/Items/DockItem.vala"
	result = self->priv->_CountVisible;
#line 47 "../lib/Items/DockItem.vala"
	return result;
#line 2333 "DockItem.c"
}

void
plank_dock_item_set_CountVisible (PlankDockItem* self,
                                  gboolean value)
{
	gboolean old_value;
#line 47 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 47 "../lib/Items/DockItem.vala"
	old_value = plank_dock_item_get_CountVisible (self);
#line 47 "../lib/Items/DockItem.vala"
	if (old_value != value) {
#line 47 "../lib/Items/DockItem.vala"
		self->priv->_CountVisible = value;
#line 47 "../lib/Items/DockItem.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_item_properties[PLANK_DOCK_ITEM_COUNT_VISIBLE_PROPERTY]);
#line 2351 "DockItem.c"
	}
}

gdouble
plank_dock_item_get_Progress (PlankDockItem* self)
{
	gdouble result;
#line 52 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, 0.0);
#line 52 "../lib/Items/DockItem.vala"
	result = self->priv->_Progress;
#line 52 "../lib/Items/DockItem.vala"
	return result;
#line 2365 "DockItem.c"
}

void
plank_dock_item_set_Progress (PlankDockItem* self,
                              gdouble value)
{
	gdouble old_value;
#line 52 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 52 "../lib/Items/DockItem.vala"
	old_value = plank_dock_item_get_Progress (self);
#line 52 "../lib/Items/DockItem.vala"
	if (old_value != value) {
#line 52 "../lib/Items/DockItem.vala"
		self->priv->_Progress = value;
#line 52 "../lib/Items/DockItem.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_item_properties[PLANK_DOCK_ITEM_PROGRESS_PROPERTY]);
#line 2383 "DockItem.c"
	}
}

gboolean
plank_dock_item_get_ProgressVisible (PlankDockItem* self)
{
	gboolean result;
#line 57 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 57 "../lib/Items/DockItem.vala"
	result = self->priv->_ProgressVisible;
#line 57 "../lib/Items/DockItem.vala"
	return result;
#line 2397 "DockItem.c"
}

void
plank_dock_item_set_ProgressVisible (PlankDockItem* self,
                                     gboolean value)
{
	gboolean old_value;
#line 57 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 57 "../lib/Items/DockItem.vala"
	old_value = plank_dock_item_get_ProgressVisible (self);
#line 57 "../lib/Items/DockItem.vala"
	if (old_value != value) {
#line 57 "../lib/Items/DockItem.vala"
		self->priv->_ProgressVisible = value;
#line 57 "../lib/Items/DockItem.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_item_properties[PLANK_DOCK_ITEM_PROGRESS_VISIBLE_PROPERTY]);
#line 2415 "DockItem.c"
	}
}

gint
plank_dock_item_get_Position (PlankDockItem* self)
{
	gint result;
#line 64 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 65 "../lib/Items/DockItem.vala"
	result = self->priv->position;
#line 65 "../lib/Items/DockItem.vala"
	return result;
#line 2429 "DockItem.c"
}

void
plank_dock_item_set_Position (PlankDockItem* self,
                              gint value)
{
	gint _tmp0_;
	gint _tmp1_;
#line 67 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 68 "../lib/Items/DockItem.vala"
	if (self->priv->position == value) {
#line 69 "../lib/Items/DockItem.vala"
		return;
#line 2444 "DockItem.c"
	}
#line 71 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_LastPosition;
#line 71 "../lib/Items/DockItem.vala"
	if (_tmp0_ != self->priv->position) {
#line 72 "../lib/Items/DockItem.vala"
		plank_dock_item_set_LastPosition (self, self->priv->position);
#line 2452 "DockItem.c"
	}
#line 74 "../lib/Items/DockItem.vala"
	self->priv->position = value;
#line 77 "../lib/Items/DockItem.vala"
	_tmp1_ = self->priv->_LastPosition;
#line 77 "../lib/Items/DockItem.vala"
	if (_tmp1_ > -1) {
#line 2460 "DockItem.c"
		PlankItemState _tmp2_;
#line 78 "../lib/Items/DockItem.vala"
		plank_dock_element_set_LastMove ((PlankDockElement*) self, g_get_monotonic_time ());
#line 79 "../lib/Items/DockItem.vala"
		_tmp2_ = self->priv->_State;
#line 79 "../lib/Items/DockItem.vala"
		plank_dock_item_set_State (self, _tmp2_ | PLANK_ITEM_STATE_MOVE);
#line 2468 "DockItem.c"
	}
#line 67 "../lib/Items/DockItem.vala"
	g_object_notify_by_pspec ((GObject *) self, plank_dock_item_properties[PLANK_DOCK_ITEM_POSITION_PROPERTY]);
#line 2472 "DockItem.c"
}

gint
plank_dock_item_get_LastPosition (PlankDockItem* self)
{
	gint result;
#line 87 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 87 "../lib/Items/DockItem.vala"
	result = self->priv->_LastPosition;
#line 87 "../lib/Items/DockItem.vala"
	return result;
#line 2485 "DockItem.c"
}

void
plank_dock_item_set_LastPosition (PlankDockItem* self,
                                  gint value)
{
	gint old_value;
#line 87 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 87 "../lib/Items/DockItem.vala"
	old_value = plank_dock_item_get_LastPosition (self);
#line 87 "../lib/Items/DockItem.vala"
	if (old_value != value) {
#line 87 "../lib/Items/DockItem.vala"
		self->priv->_LastPosition = value;
#line 87 "../lib/Items/DockItem.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_item_properties[PLANK_DOCK_ITEM_LAST_POSITION_PROPERTY]);
#line 2503 "DockItem.c"
	}
}

PlankItemState
plank_dock_item_get_State (PlankDockItem* self)
{
	PlankItemState result;
	PlankItemState _tmp0_;
#line 92 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, 0U);
#line 92 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_State;
#line 92 "../lib/Items/DockItem.vala"
	result = _tmp0_;
#line 92 "../lib/Items/DockItem.vala"
	return result;
#line 2520 "DockItem.c"
}

void
plank_dock_item_set_State (PlankDockItem* self,
                           PlankItemState value)
{
	PlankItemState old_value;
#line 92 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 92 "../lib/Items/DockItem.vala"
	old_value = plank_dock_item_get_State (self);
#line 92 "../lib/Items/DockItem.vala"
	if (old_value != value) {
#line 92 "../lib/Items/DockItem.vala"
		self->priv->_State = value;
#line 92 "../lib/Items/DockItem.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_item_properties[PLANK_DOCK_ITEM_STATE_PROPERTY]);
#line 2538 "DockItem.c"
	}
}

PlankIndicatorState
plank_dock_item_get_Indicator (PlankDockItem* self)
{
	PlankIndicatorState result;
	PlankIndicatorState _tmp0_;
#line 97 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 97 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_Indicator;
#line 97 "../lib/Items/DockItem.vala"
	result = _tmp0_;
#line 97 "../lib/Items/DockItem.vala"
	return result;
#line 2555 "DockItem.c"
}

void
plank_dock_item_set_Indicator (PlankDockItem* self,
                               PlankIndicatorState value)
{
	PlankIndicatorState old_value;
#line 97 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 97 "../lib/Items/DockItem.vala"
	old_value = plank_dock_item_get_Indicator (self);
#line 97 "../lib/Items/DockItem.vala"
	if (old_value != value) {
#line 97 "../lib/Items/DockItem.vala"
		self->priv->_Indicator = value;
#line 97 "../lib/Items/DockItem.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_item_properties[PLANK_DOCK_ITEM_INDICATOR_PROPERTY]);
#line 2573 "DockItem.c"
	}
}

void
plank_dock_item_get_AverageIconColor (PlankDockItem* self,
                                      PlankColor * result)
{
	PlankColor _tmp0_;
#line 102 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 102 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_AverageIconColor;
#line 102 "../lib/Items/DockItem.vala"
	*result = _tmp0_;
#line 102 "../lib/Items/DockItem.vala"
	return;
#line 2590 "DockItem.c"
}

static gboolean
_gdk_rgba_equal (const GdkRGBA * s1,
                 const GdkRGBA * s2)
{
#line 102 "../lib/Items/DockItem.vala"
	if (s1 == s2) {
#line 102 "../lib/Items/DockItem.vala"
		return TRUE;
#line 2601 "DockItem.c"
	}
#line 102 "../lib/Items/DockItem.vala"
	if (s1 == NULL) {
#line 102 "../lib/Items/DockItem.vala"
		return FALSE;
#line 2607 "DockItem.c"
	}
#line 102 "../lib/Items/DockItem.vala"
	if (s2 == NULL) {
#line 102 "../lib/Items/DockItem.vala"
		return FALSE;
#line 2613 "DockItem.c"
	}
#line 102 "../lib/Items/DockItem.vala"
	if (s1->red != s2->red) {
#line 102 "../lib/Items/DockItem.vala"
		return FALSE;
#line 2619 "DockItem.c"
	}
#line 102 "../lib/Items/DockItem.vala"
	if (s1->green != s2->green) {
#line 102 "../lib/Items/DockItem.vala"
		return FALSE;
#line 2625 "DockItem.c"
	}
#line 102 "../lib/Items/DockItem.vala"
	if (s1->blue != s2->blue) {
#line 102 "../lib/Items/DockItem.vala"
		return FALSE;
#line 2631 "DockItem.c"
	}
#line 102 "../lib/Items/DockItem.vala"
	if (s1->alpha != s2->alpha) {
#line 102 "../lib/Items/DockItem.vala"
		return FALSE;
#line 2637 "DockItem.c"
	}
#line 102 "../lib/Items/DockItem.vala"
	return TRUE;
#line 2641 "DockItem.c"
}

void
plank_dock_item_set_AverageIconColor (PlankDockItem* self,
                                      PlankColor * value)
{
	PlankColor old_value;
#line 102 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 102 "../lib/Items/DockItem.vala"
	plank_dock_item_get_AverageIconColor (self, &old_value);
#line 102 "../lib/Items/DockItem.vala"
	if (_gdk_rgba_equal (value, &old_value) != TRUE) {
#line 2655 "DockItem.c"
		PlankColor _tmp0_;
#line 102 "../lib/Items/DockItem.vala"
		_tmp0_ = *value;
#line 102 "../lib/Items/DockItem.vala"
		self->priv->_AverageIconColor = _tmp0_;
#line 102 "../lib/Items/DockItem.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_item_properties[PLANK_DOCK_ITEM_AVERAGE_ICON_COLOR_PROPERTY]);
#line 2663 "DockItem.c"
	}
}

gchar*
plank_dock_item_get_DockItemFilename (PlankDockItem* self)
{
	gchar* result;
	PlankDockItemPreferences* _tmp0_;
	gchar* _tmp1_;
#line 108 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 108 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_Prefs;
#line 108 "../lib/Items/DockItem.vala"
	_tmp1_ = plank_preferences_get_filename ((PlankPreferences*) _tmp0_);
#line 108 "../lib/Items/DockItem.vala"
	result = _tmp1_;
#line 108 "../lib/Items/DockItem.vala"
	return result;
#line 2683 "DockItem.c"
}

const gchar*
plank_dock_item_get_Launcher (PlankDockItem* self)
{
	const gchar* result;
	PlankDockItemPreferences* _tmp0_;
	const gchar* _tmp1_;
	const gchar* _tmp2_;
#line 115 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 115 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_Prefs;
#line 115 "../lib/Items/DockItem.vala"
	_tmp1_ = plank_dock_item_preferences_get_Launcher (_tmp0_);
#line 115 "../lib/Items/DockItem.vala"
	_tmp2_ = _tmp1_;
#line 115 "../lib/Items/DockItem.vala"
	result = _tmp2_;
#line 115 "../lib/Items/DockItem.vala"
	return result;
#line 2705 "DockItem.c"
}

PlankDockItemPreferences*
plank_dock_item_get_Prefs (PlankDockItem* self)
{
	PlankDockItemPreferences* result;
	PlankDockItemPreferences* _tmp0_;
#line 121 "../lib/Items/DockItem.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 121 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->_Prefs;
#line 121 "../lib/Items/DockItem.vala"
	result = _tmp0_;
#line 121 "../lib/Items/DockItem.vala"
	return result;
#line 2721 "DockItem.c"
}

static void
plank_dock_item_set_Prefs (PlankDockItem* self,
                           PlankDockItemPreferences* value)
{
	PlankDockItemPreferences* old_value;
#line 121 "../lib/Items/DockItem.vala"
	g_return_if_fail (self != NULL);
#line 121 "../lib/Items/DockItem.vala"
	old_value = plank_dock_item_get_Prefs (self);
#line 121 "../lib/Items/DockItem.vala"
	if (old_value != value) {
#line 2735 "DockItem.c"
		PlankDockItemPreferences* _tmp0_;
#line 121 "../lib/Items/DockItem.vala"
		_tmp0_ = _g_object_ref0 (value);
#line 121 "../lib/Items/DockItem.vala"
		_g_object_unref0 (self->priv->_Prefs);
#line 121 "../lib/Items/DockItem.vala"
		self->priv->_Prefs = _tmp0_;
#line 121 "../lib/Items/DockItem.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_item_properties[PLANK_DOCK_ITEM_PREFS_PROPERTY]);
#line 2745 "DockItem.c"
	}
}

static GObject *
plank_dock_item_constructor (GType type,
                             guint n_construct_properties,
                             GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	PlankDockItem * self;
	PlankSurfaceCache* _tmp0_;
	PlankSurfaceCache* _tmp1_;
	PlankDockItemPreferences* _tmp2_;
	PlankDockItemPreferences* _tmp3_;
	GtkIconTheme* _tmp4_;
	GdkPixbuf* _tmp5_;
#line 141 "../lib/Items/DockItem.vala"
	parent_class = G_OBJECT_CLASS (plank_dock_item_parent_class);
#line 141 "../lib/Items/DockItem.vala"
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
#line 141 "../lib/Items/DockItem.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_DOCK_ITEM, PlankDockItem);
#line 143 "../lib/Items/DockItem.vala"
	_tmp0_ = plank_surface_cache_new (PLANK_TYPE_DOCK_ITEM, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, PLANK_SURFACE_CACHE_FLAGS_NONE);
#line 143 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->buffer);
#line 143 "../lib/Items/DockItem.vala"
	self->priv->buffer = _tmp0_;
#line 144 "../lib/Items/DockItem.vala"
	_tmp1_ = plank_surface_cache_new (PLANK_TYPE_DOCK_ITEM, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, PLANK_SURFACE_CACHE_FLAGS_ALLOW_SCALE);
#line 144 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->background_buffer);
#line 144 "../lib/Items/DockItem.vala"
	self->priv->background_buffer = _tmp1_;
#line 146 "../lib/Items/DockItem.vala"
	_tmp2_ = self->priv->_Prefs;
#line 146 "../lib/Items/DockItem.vala"
	g_signal_connect_object ((PlankPreferences*) _tmp2_, "deleted", (GCallback) _plank_dock_item_handle_deleted_plank_preferences_deleted, self, 0);
#line 147 "../lib/Items/DockItem.vala"
	_tmp3_ = self->priv->_Prefs;
#line 147 "../lib/Items/DockItem.vala"
	g_signal_connect_object ((GObject*) _tmp3_, "notify::Launcher", (GCallback) _plank_dock_item_handle_launcher_changed_g_object_notify, self, 0);
#line 149 "../lib/Items/DockItem.vala"
	_tmp4_ = plank_drawing_service_get_icon_theme ();
#line 149 "../lib/Items/DockItem.vala"
	g_signal_connect_object (_tmp4_, "changed", (GCallback) _plank_dock_item_icon_theme_changed_gtk_icon_theme_changed, self, 0);
#line 150 "../lib/Items/DockItem.vala"
	g_signal_connect_object ((GObject*) self, "notify::Icon", (GCallback) _plank_dock_item_icon_changed_g_object_notify, self, 0);
#line 151 "../lib/Items/DockItem.vala"
	g_signal_connect_object ((GObject*) self, "notify::ForcePixbuf", (GCallback) _plank_dock_item_icon_changed_g_object_notify, self, 0);
#line 153 "../lib/Items/DockItem.vala"
	g_signal_connect_object ((GObject*) self, "notify::Count", (GCallback) _plank_dock_item_reset_foreground_buffer_g_object_notify, self, 0);
#line 154 "../lib/Items/DockItem.vala"
	g_signal_connect_object ((GObject*) self, "notify::CountVisible", (GCallback) _plank_dock_item_reset_foreground_buffer_g_object_notify, self, 0);
#line 155 "../lib/Items/DockItem.vala"
	g_signal_connect_object ((GObject*) self, "notify::Progress", (GCallback) _plank_dock_item_reset_foreground_buffer_g_object_notify, self, 0);
#line 156 "../lib/Items/DockItem.vala"
	g_signal_connect_object ((GObject*) self, "notify::ProgressVisible", (GCallback) _plank_dock_item_reset_foreground_buffer_g_object_notify, self, 0);
#line 158 "../lib/Items/DockItem.vala"
	plank_dock_item_launcher_file_monitor_start (self);
#line 159 "../lib/Items/DockItem.vala"
	_tmp5_ = self->priv->_ForcePixbuf;
#line 159 "../lib/Items/DockItem.vala"
	if (_tmp5_ == NULL) {
#line 160 "../lib/Items/DockItem.vala"
		plank_dock_item_icon_file_monitor_start (self);
#line 2813 "DockItem.c"
	}
#line 141 "../lib/Items/DockItem.vala"
	return obj;
#line 2817 "DockItem.c"
}

static void
plank_dock_item_class_init (PlankDockItemClass * klass,
                            gpointer klass_data)
{
#line 25 "../lib/Items/DockItem.vala"
	plank_dock_item_parent_class = g_type_class_peek_parent (klass);
#line 25 "../lib/Items/DockItem.vala"
	g_type_class_adjust_private_offset (klass, &PlankDockItem_private_offset);
#line 25 "../lib/Items/DockItem.vala"
	((PlankDockItemClass *) klass)->load_from_launcher = (void (*) (PlankDockItem*)) plank_dock_item_real_load_from_launcher;
#line 25 "../lib/Items/DockItem.vala"
	((PlankDockElementClass *) klass)->reset_buffers = (void (*) (PlankDockElement*)) plank_dock_item_real_reset_buffers;
#line 25 "../lib/Items/DockItem.vala"
	((PlankDockItemClass *) klass)->draw_icon = (void (*) (PlankDockItem*, PlankSurface*)) plank_dock_item_real_draw_icon;
#line 25 "../lib/Items/DockItem.vala"
	((PlankDockItemClass *) klass)->draw_icon_fast = (void (*) (PlankDockItem*, PlankSurface*)) plank_dock_item_real_draw_icon_fast;
#line 25 "../lib/Items/DockItem.vala"
	((PlankDockItemClass *) klass)->is_valid = (gboolean (*) (PlankDockItem*)) plank_dock_item_real_is_valid;
#line 25 "../lib/Items/DockItem.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_plank_dock_item_get_property;
#line 25 "../lib/Items/DockItem.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_plank_dock_item_set_property;
#line 25 "../lib/Items/DockItem.vala"
	G_OBJECT_CLASS (klass)->constructor = plank_dock_item_constructor;
#line 25 "../lib/Items/DockItem.vala"
	G_OBJECT_CLASS (klass)->finalize = plank_dock_item_finalize;
#line 2846 "DockItem.c"
	/**
	 * The dock item's icon.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_ICON_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_ICON_PROPERTY] = g_param_spec_string ("Icon", "Icon", "Icon", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_FORCE_PIXBUF_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_FORCE_PIXBUF_PROPERTY] = g_param_spec_object ("ForcePixbuf", "ForcePixbuf", "ForcePixbuf", gdk_pixbuf_get_type (), G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 2854 "DockItem.c"
	/**
	 * The count for the dock item.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_COUNT_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_COUNT_PROPERTY] = g_param_spec_int64 ("Count", "Count", "Count", G_MININT64, G_MAXINT64, (gint64) 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 2860 "DockItem.c"
	/**
	 * Show the item's count or not.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_COUNT_VISIBLE_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_COUNT_VISIBLE_PROPERTY] = g_param_spec_boolean ("CountVisible", "CountVisible", "CountVisible", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 2866 "DockItem.c"
	/**
	 * The progress for this dock item.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_PROGRESS_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_PROGRESS_PROPERTY] = g_param_spec_double ("Progress", "Progress", "Progress", -G_MAXDOUBLE, G_MAXDOUBLE, (gdouble) 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 2872 "DockItem.c"
	/**
	 * Show the item's progress or not.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_PROGRESS_VISIBLE_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_PROGRESS_VISIBLE_PROPERTY] = g_param_spec_boolean ("ProgressVisible", "ProgressVisible", "ProgressVisible", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 2878 "DockItem.c"
	/**
	 * The dock item's position on the dock.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_POSITION_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_POSITION_PROPERTY] = g_param_spec_int ("Position", "Position", "Position", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 2884 "DockItem.c"
	/**
	 * The dock item's last position on the dock.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_LAST_POSITION_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_LAST_POSITION_PROPERTY] = g_param_spec_int ("LastPosition", "LastPosition", "LastPosition", G_MININT, G_MAXINT, -1, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 2890 "DockItem.c"
	/**
	 * The item's current state.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_STATE_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_STATE_PROPERTY] = g_param_spec_flags ("State", "State", "State", PLANK_TYPE_ITEM_STATE, PLANK_ITEM_STATE_NORMAL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 2896 "DockItem.c"
	/**
	 * The indicator shown for the item.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_INDICATOR_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_INDICATOR_PROPERTY] = g_param_spec_enum ("Indicator", "Indicator", "Indicator", PLANK_TYPE_INDICATOR_STATE, PLANK_INDICATOR_STATE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 2902 "DockItem.c"
	/**
	 * The average color of this item's icon.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_AVERAGE_ICON_COLOR_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_AVERAGE_ICON_COLOR_PROPERTY] = g_param_spec_boxed ("AverageIconColor", "AverageIconColor", "AverageIconColor", PLANK_TYPE_COLOR, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 2908 "DockItem.c"
	/**
	 * The filename of the preferences backing file.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_DOCK_ITEM_FILENAME_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_DOCK_ITEM_FILENAME_PROPERTY] = g_param_spec_string ("DockItemFilename", "DockItemFilename", "DockItemFilename", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
#line 2914 "DockItem.c"
	/**
	 * The launcher associated with this item.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_LAUNCHER_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_LAUNCHER_PROPERTY] = g_param_spec_string ("Launcher", "Launcher", "Launcher", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
#line 2920 "DockItem.c"
	/**
	 * The underlying preferences for this item.
	 */
#line 25 "../lib/Items/DockItem.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ITEM_PREFS_PROPERTY, plank_dock_item_properties[PLANK_DOCK_ITEM_PREFS_PROPERTY] = g_param_spec_object ("Prefs", "Prefs", "Prefs", PLANK_TYPE_DOCK_ITEM_PREFERENCES, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
#line 2926 "DockItem.c"
	/**
	 * Signal fired when the .dockitem for this item was deleted.
	 */
#line 25 "../lib/Items/DockItem.vala"
	plank_dock_item_signals[PLANK_DOCK_ITEM_DELETED_SIGNAL] = g_signal_new ("deleted", PLANK_TYPE_DOCK_ITEM, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
#line 2932 "DockItem.c"
}

static void
plank_dock_item_instance_init (PlankDockItem * self,
                               gpointer klass)
{
	gchar* _tmp0_;
	PlankColor _tmp1_ = {0};
#line 25 "../lib/Items/DockItem.vala"
	self->priv = plank_dock_item_get_instance_private (self);
#line 35 "../lib/Items/DockItem.vala"
	_tmp0_ = g_strdup ("");
#line 35 "../lib/Items/DockItem.vala"
	self->priv->_Icon = _tmp0_;
#line 37 "../lib/Items/DockItem.vala"
	self->priv->_ForcePixbuf = NULL;
#line 42 "../lib/Items/DockItem.vala"
	self->priv->_Count = (gint64) 0;
#line 47 "../lib/Items/DockItem.vala"
	self->priv->_CountVisible = FALSE;
#line 52 "../lib/Items/DockItem.vala"
	self->priv->_Progress = (gdouble) 0;
#line 57 "../lib/Items/DockItem.vala"
	self->priv->_ProgressVisible = FALSE;
#line 59 "../lib/Items/DockItem.vala"
	self->priv->position = -1;
#line 87 "../lib/Items/DockItem.vala"
	self->priv->_LastPosition = -1;
#line 92 "../lib/Items/DockItem.vala"
	self->priv->_State = PLANK_ITEM_STATE_NORMAL;
#line 97 "../lib/Items/DockItem.vala"
	self->priv->_Indicator = PLANK_INDICATOR_STATE_NONE;
#line 102 "../lib/Items/DockItem.vala"
	memset (&_tmp1_, 0, sizeof (PlankColor));
#line 102 "../lib/Items/DockItem.vala"
	_tmp1_.red = 0.0;
#line 102 "../lib/Items/DockItem.vala"
	_tmp1_.green = 0.0;
#line 102 "../lib/Items/DockItem.vala"
	_tmp1_.blue = 0.0;
#line 102 "../lib/Items/DockItem.vala"
	_tmp1_.alpha = 0.0;
#line 102 "../lib/Items/DockItem.vala"
	self->priv->_AverageIconColor = _tmp1_;
#line 125 "../lib/Items/DockItem.vala"
	self->priv->foreground_surface = NULL;
#line 127 "../lib/Items/DockItem.vala"
	self->priv->launcher_file_monitor = NULL;
#line 128 "../lib/Items/DockItem.vala"
	self->priv->icon_file_monitor = NULL;
#line 130 "../lib/Items/DockItem.vala"
	self->priv->launcher_exists = FALSE;
#line 131 "../lib/Items/DockItem.vala"
	self->priv->removal_timer_id = 0U;
#line 2987 "DockItem.c"
}

static void
plank_dock_item_finalize (GObject * obj)
{
	PlankDockItem * self;
	PlankSurfaceCache* _tmp0_;
	PlankSurfaceCache* _tmp1_;
	PlankDockItemPreferences* _tmp2_;
	guint _tmp3_;
	PlankDockItemPreferences* _tmp4_;
	guint _tmp5_;
	GQuark _tmp6_;
	GtkIconTheme* _tmp7_;
	guint _tmp8_;
	guint _tmp9_;
	GQuark _tmp10_;
	guint _tmp11_;
	GQuark _tmp12_;
	guint _tmp13_;
	GQuark _tmp14_;
	guint _tmp15_;
	GQuark _tmp16_;
	guint _tmp17_;
	GQuark _tmp18_;
	guint _tmp19_;
	GQuark _tmp20_;
#line 25 "../lib/Items/DockItem.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_DOCK_ITEM, PlankDockItem);
#line 165 "../lib/Items/DockItem.vala"
	_tmp0_ = self->priv->buffer;
#line 165 "../lib/Items/DockItem.vala"
	plank_surface_cache_clear (_tmp0_);
#line 166 "../lib/Items/DockItem.vala"
	_tmp1_ = self->priv->background_buffer;
#line 166 "../lib/Items/DockItem.vala"
	plank_surface_cache_clear (_tmp1_);
#line 168 "../lib/Items/DockItem.vala"
	_tmp2_ = self->priv->_Prefs;
#line 168 "../lib/Items/DockItem.vala"
	g_signal_parse_name ("deleted", PLANK_TYPE_PREFERENCES, &_tmp3_, NULL, FALSE);
#line 168 "../lib/Items/DockItem.vala"
	g_signal_handlers_disconnect_matched ((PlankPreferences*) _tmp2_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp3_, 0, NULL, (GCallback) _plank_dock_item_handle_deleted_plank_preferences_deleted, self);
#line 169 "../lib/Items/DockItem.vala"
	_tmp4_ = self->priv->_Prefs;
#line 169 "../lib/Items/DockItem.vala"
	g_signal_parse_name ("notify::Launcher", G_TYPE_OBJECT, &_tmp5_, &_tmp6_, TRUE);
#line 169 "../lib/Items/DockItem.vala"
	g_signal_handlers_disconnect_matched ((GObject*) _tmp4_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp5_, _tmp6_, NULL, (GCallback) _plank_dock_item_handle_launcher_changed_g_object_notify, self);
#line 171 "../lib/Items/DockItem.vala"
	_tmp7_ = plank_drawing_service_get_icon_theme ();
#line 171 "../lib/Items/DockItem.vala"
	g_signal_parse_name ("changed", gtk_icon_theme_get_type (), &_tmp8_, NULL, FALSE);
#line 171 "../lib/Items/DockItem.vala"
	g_signal_handlers_disconnect_matched (_tmp7_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp8_, 0, NULL, (GCallback) _plank_dock_item_icon_theme_changed_gtk_icon_theme_changed, self);
#line 172 "../lib/Items/DockItem.vala"
	g_signal_parse_name ("notify::Icon", G_TYPE_OBJECT, &_tmp9_, &_tmp10_, TRUE);
#line 172 "../lib/Items/DockItem.vala"
	g_signal_handlers_disconnect_matched ((GObject*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp9_, _tmp10_, NULL, (GCallback) _plank_dock_item_icon_changed_g_object_notify, self);
#line 173 "../lib/Items/DockItem.vala"
	g_signal_parse_name ("notify::ForcePixbuf", G_TYPE_OBJECT, &_tmp11_, &_tmp12_, TRUE);
#line 173 "../lib/Items/DockItem.vala"
	g_signal_handlers_disconnect_matched ((GObject*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp11_, _tmp12_, NULL, (GCallback) _plank_dock_item_icon_changed_g_object_notify, self);
#line 175 "../lib/Items/DockItem.vala"
	g_signal_parse_name ("notify::Count", G_TYPE_OBJECT, &_tmp13_, &_tmp14_, TRUE);
#line 175 "../lib/Items/DockItem.vala"
	g_signal_handlers_disconnect_matched ((GObject*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp13_, _tmp14_, NULL, (GCallback) _plank_dock_item_reset_foreground_buffer_g_object_notify, self);
#line 176 "../lib/Items/DockItem.vala"
	g_signal_parse_name ("notify::CountVisible", G_TYPE_OBJECT, &_tmp15_, &_tmp16_, TRUE);
#line 176 "../lib/Items/DockItem.vala"
	g_signal_handlers_disconnect_matched ((GObject*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp15_, _tmp16_, NULL, (GCallback) _plank_dock_item_reset_foreground_buffer_g_object_notify, self);
#line 177 "../lib/Items/DockItem.vala"
	g_signal_parse_name ("notify::Progress", G_TYPE_OBJECT, &_tmp17_, &_tmp18_, TRUE);
#line 177 "../lib/Items/DockItem.vala"
	g_signal_handlers_disconnect_matched ((GObject*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp17_, _tmp18_, NULL, (GCallback) _plank_dock_item_reset_foreground_buffer_g_object_notify, self);
#line 178 "../lib/Items/DockItem.vala"
	g_signal_parse_name ("notify::ProgressVisible", G_TYPE_OBJECT, &_tmp19_, &_tmp20_, TRUE);
#line 178 "../lib/Items/DockItem.vala"
	g_signal_handlers_disconnect_matched ((GObject*) self, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp19_, _tmp20_, NULL, (GCallback) _plank_dock_item_reset_foreground_buffer_g_object_notify, self);
#line 180 "../lib/Items/DockItem.vala"
	plank_dock_item_launcher_file_monitor_stop (self);
#line 181 "../lib/Items/DockItem.vala"
	plank_dock_item_icon_file_monitor_stop (self);
#line 183 "../lib/Items/DockItem.vala"
	if (plank_dock_item_stop_removal (self)) {
#line 184 "../lib/Items/DockItem.vala"
		plank_dock_item_delete (self);
#line 3075 "DockItem.c"
	}
#line 35 "../lib/Items/DockItem.vala"
	_g_free0 (self->priv->_Icon);
#line 37 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->_ForcePixbuf);
#line 121 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->_Prefs);
#line 123 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->buffer);
#line 124 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->background_buffer);
#line 125 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->foreground_surface);
#line 127 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->launcher_file_monitor);
#line 128 "../lib/Items/DockItem.vala"
	_g_object_unref0 (self->priv->icon_file_monitor);
#line 25 "../lib/Items/DockItem.vala"
	G_OBJECT_CLASS (plank_dock_item_parent_class)->finalize (obj);
#line 3095 "DockItem.c"
}

/**
 * The base class for all dock items.
 */
static GType
plank_dock_item_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankDockItemClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_dock_item_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankDockItem), 0, (GInstanceInitFunc) plank_dock_item_instance_init, NULL };
	GType plank_dock_item_type_id;
	plank_dock_item_type_id = g_type_register_static (PLANK_TYPE_DOCK_ELEMENT, "PlankDockItem", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	PlankDockItem_private_offset = g_type_add_instance_private (plank_dock_item_type_id, sizeof (PlankDockItemPrivate));
	return plank_dock_item_type_id;
}

GType
plank_dock_item_get_type (void)
{
	static volatile gsize plank_dock_item_type_id__volatile = 0;
	if (g_once_init_enter (&plank_dock_item_type_id__volatile)) {
		GType plank_dock_item_type_id;
		plank_dock_item_type_id = plank_dock_item_get_type_once ();
		g_once_init_leave (&plank_dock_item_type_id__volatile, plank_dock_item_type_id);
	}
	return plank_dock_item_type_id__volatile;
}

static void
_vala_plank_dock_item_get_property (GObject * object,
                                    guint property_id,
                                    GValue * value,
                                    GParamSpec * pspec)
{
	PlankDockItem * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_DOCK_ITEM, PlankDockItem);
#line 25 "../lib/Items/DockItem.vala"
	switch (property_id) {
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_ICON_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_set_string (value, plank_dock_item_get_Icon (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_FORCE_PIXBUF_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_set_object (value, plank_dock_item_get_ForcePixbuf (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_COUNT_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_set_int64 (value, plank_dock_item_get_Count (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_COUNT_VISIBLE_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_set_boolean (value, plank_dock_item_get_CountVisible (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_PROGRESS_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_set_double (value, plank_dock_item_get_Progress (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_PROGRESS_VISIBLE_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_set_boolean (value, plank_dock_item_get_ProgressVisible (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_POSITION_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_set_int (value, plank_dock_item_get_Position (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_LAST_POSITION_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_set_int (value, plank_dock_item_get_LastPosition (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_STATE_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_set_flags (value, plank_dock_item_get_State (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_INDICATOR_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_set_enum (value, plank_dock_item_get_Indicator (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_AVERAGE_ICON_COLOR_PROPERTY:
#line 3195 "DockItem.c"
		{
			PlankColor boxed;
#line 25 "../lib/Items/DockItem.vala"
			plank_dock_item_get_AverageIconColor (self, &boxed);
#line 25 "../lib/Items/DockItem.vala"
			g_value_set_boxed (value, &boxed);
#line 3202 "DockItem.c"
		}
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_DOCK_ITEM_FILENAME_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_take_string (value, plank_dock_item_get_DockItemFilename (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_LAUNCHER_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_set_string (value, plank_dock_item_get_Launcher (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_PREFS_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		g_value_set_object (value, plank_dock_item_get_Prefs (self));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 3224 "DockItem.c"
		default:
#line 25 "../lib/Items/DockItem.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 3230 "DockItem.c"
	}
}

static void
_vala_plank_dock_item_set_property (GObject * object,
                                    guint property_id,
                                    const GValue * value,
                                    GParamSpec * pspec)
{
	PlankDockItem * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_DOCK_ITEM, PlankDockItem);
#line 25 "../lib/Items/DockItem.vala"
	switch (property_id) {
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_ICON_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		plank_dock_item_set_Icon (self, g_value_get_string (value));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_FORCE_PIXBUF_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		plank_dock_item_set_ForcePixbuf (self, g_value_get_object (value));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_COUNT_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		plank_dock_item_set_Count (self, g_value_get_int64 (value));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_COUNT_VISIBLE_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		plank_dock_item_set_CountVisible (self, g_value_get_boolean (value));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_PROGRESS_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		plank_dock_item_set_Progress (self, g_value_get_double (value));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_PROGRESS_VISIBLE_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		plank_dock_item_set_ProgressVisible (self, g_value_get_boolean (value));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_POSITION_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		plank_dock_item_set_Position (self, g_value_get_int (value));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_LAST_POSITION_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		plank_dock_item_set_LastPosition (self, g_value_get_int (value));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_STATE_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		plank_dock_item_set_State (self, g_value_get_flags (value));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_INDICATOR_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		plank_dock_item_set_Indicator (self, g_value_get_enum (value));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_AVERAGE_ICON_COLOR_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		plank_dock_item_set_AverageIconColor (self, g_value_get_boxed (value));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 25 "../lib/Items/DockItem.vala"
		case PLANK_DOCK_ITEM_PREFS_PROPERTY:
#line 25 "../lib/Items/DockItem.vala"
		plank_dock_item_set_Prefs (self, g_value_get_object (value));
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 3316 "DockItem.c"
		default:
#line 25 "../lib/Items/DockItem.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 25 "../lib/Items/DockItem.vala"
		break;
#line 3322 "DockItem.c"
	}
}

