/* DockElement.c generated by valac 0.48.17, the Vala compiler
 * generated from DockElement.vala, do not modify */

/**/
/*  Copyright (C) 2011-2012 Robert Dyer, Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <gdk/gdk.h>
#include <glib.h>
#include <gee.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk-pixbuf/gdk-pixbuf.h>

#define PLANK_TYPE_DOCK_ELEMENT (plank_dock_element_get_type ())
#define PLANK_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElement))
#define PLANK_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))
#define PLANK_IS_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_IS_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_DOCK_ELEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))

typedef struct _PlankDockElement PlankDockElement;
typedef struct _PlankDockElementClass PlankDockElementClass;
typedef struct _PlankDockElementPrivate PlankDockElementPrivate;
typedef enum  {
	PLANK_POPUP_BUTTON_NONE = 1 << 0,
	PLANK_POPUP_BUTTON_LEFT = 1 << 1,
	PLANK_POPUP_BUTTON_MIDDLE = 1 << 2,
	PLANK_POPUP_BUTTON_RIGHT = 1 << 3
} PlankPopupButton;

#define PLANK_TYPE_POPUP_BUTTON (plank_popup_button_get_type ())
typedef enum  {
	PLANK_ANIMATION_TYPE_NONE,
	PLANK_ANIMATION_TYPE_BOUNCE,
	PLANK_ANIMATION_TYPE_DARKEN,
	PLANK_ANIMATION_TYPE_LIGHTEN
} PlankAnimationType;

#define PLANK_TYPE_ANIMATION_TYPE (plank_animation_type_get_type ())

#define PLANK_TYPE_DOCK_CONTAINER (plank_dock_container_get_type ())
#define PLANK_DOCK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainer))
#define PLANK_DOCK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainerClass))
#define PLANK_IS_DOCK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_CONTAINER))
#define PLANK_IS_DOCK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_CONTAINER))
#define PLANK_DOCK_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainerClass))

typedef struct _PlankDockContainer PlankDockContainer;
typedef struct _PlankDockContainerClass PlankDockContainerClass;
enum  {
	PLANK_DOCK_ELEMENT_0_PROPERTY,
	PLANK_DOCK_ELEMENT_CONTAINER_PROPERTY,
	PLANK_DOCK_ELEMENT_TEXT_PROPERTY,
	PLANK_DOCK_ELEMENT_IS_ATTACHED_PROPERTY,
	PLANK_DOCK_ELEMENT_IS_VISIBLE_PROPERTY,
	PLANK_DOCK_ELEMENT_BUTTON_PROPERTY,
	PLANK_DOCK_ELEMENT_CLICKED_ANIMATION_PROPERTY,
	PLANK_DOCK_ELEMENT_HOVERED_ANIMATION_PROPERTY,
	PLANK_DOCK_ELEMENT_SCROLLED_ANIMATION_PROPERTY,
	PLANK_DOCK_ELEMENT_ADD_TIME_PROPERTY,
	PLANK_DOCK_ELEMENT_REMOVE_TIME_PROPERTY,
	PLANK_DOCK_ELEMENT_LAST_CLICKED_PROPERTY,
	PLANK_DOCK_ELEMENT_LAST_HOVERED_PROPERTY,
	PLANK_DOCK_ELEMENT_LAST_SCROLLED_PROPERTY,
	PLANK_DOCK_ELEMENT_LAST_URGENT_PROPERTY,
	PLANK_DOCK_ELEMENT_LAST_ACTIVE_PROPERTY,
	PLANK_DOCK_ELEMENT_LAST_MOVE_PROPERTY,
	PLANK_DOCK_ELEMENT_LAST_VALID_PROPERTY,
	PLANK_DOCK_ELEMENT_NUM_PROPERTIES
};
static GParamSpec* plank_dock_element_properties[PLANK_DOCK_ELEMENT_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define PLANK_TYPE_DOCK_CONTROLLER (plank_dock_controller_get_type ())
#define PLANK_DOCK_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_CONTROLLER, PlankDockController))
#define PLANK_DOCK_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_CONTROLLER, PlankDockControllerClass))
#define PLANK_IS_DOCK_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_CONTROLLER))
#define PLANK_IS_DOCK_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_CONTROLLER))
#define PLANK_DOCK_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_CONTROLLER, PlankDockControllerClass))

typedef struct _PlankDockController PlankDockController;
typedef struct _PlankDockControllerClass PlankDockControllerClass;
enum  {
	PLANK_DOCK_ELEMENT_NEEDS_REDRAW_SIGNAL,
	PLANK_DOCK_ELEMENT_NUM_SIGNALS
};
static guint plank_dock_element_signals[PLANK_DOCK_ELEMENT_NUM_SIGNALS] = {0};

struct _PlankDockElement {
	GObject parent_instance;
	PlankDockElementPrivate * priv;
};

struct _PlankDockElementClass {
	GObjectClass parent_class;
	PlankAnimationType (*on_clicked) (PlankDockElement* self, PlankPopupButton button, GdkModifierType mod, guint32 event_time);
	PlankAnimationType (*on_hovered) (PlankDockElement* self);
	PlankAnimationType (*on_scrolled) (PlankDockElement* self, GdkScrollDirection direction, GdkModifierType mod, guint32 event_time);
	GeeArrayList* (*get_menu_items) (PlankDockElement* self);
	gchar* (*get_drop_text) (PlankDockElement* self);
	gboolean (*can_be_removed) (PlankDockElement* self);
	gboolean (*can_accept_drop) (PlankDockElement* self, GeeArrayList* uris);
	gboolean (*accept_drop) (PlankDockElement* self, GeeArrayList* uris);
	gchar* (*unique_id) (PlankDockElement* self);
	void (*reset_buffers) (PlankDockElement* self);
};

struct _PlankDockElementPrivate {
	PlankDockContainer* _Container;
	gchar* _Text;
	gboolean _IsAttached;
	gboolean _IsVisible;
	PlankPopupButton _Button;
	PlankAnimationType _ClickedAnimation;
	PlankAnimationType _HoveredAnimation;
	PlankAnimationType _ScrolledAnimation;
	gint64 _AddTime;
	gint64 _RemoveTime;
	gint64 _LastClicked;
	gint64 _LastHovered;
	gint64 _LastScrolled;
	gint64 _LastUrgent;
	gint64 _LastActive;
	gint64 _LastMove;
	gint64 _LastValid;
};

static gint PlankDockElement_private_offset;
static gpointer plank_dock_element_parent_class = NULL;

GType plank_dock_element_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockElement, g_object_unref)
GType plank_popup_button_get_type (void) G_GNUC_CONST;
GType plank_animation_type_get_type (void) G_GNUC_CONST;
GType plank_dock_container_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockContainer, g_object_unref)
PlankAnimationType plank_dock_element_on_clicked (PlankDockElement* self,
                                                  PlankPopupButton button,
                                                  GdkModifierType mod,
                                                  guint32 event_time);
PlankAnimationType plank_dock_element_on_hovered (PlankDockElement* self);
PlankAnimationType plank_dock_element_on_scrolled (PlankDockElement* self,
                                                   GdkScrollDirection direction,
                                                   GdkModifierType mod,
                                                   guint32 event_time);
GeeArrayList* plank_dock_element_get_menu_items (PlankDockElement* self);
gchar* plank_dock_element_get_drop_text (PlankDockElement* self);
gboolean plank_dock_element_can_be_removed (PlankDockElement* self);
gboolean plank_dock_element_can_accept_drop (PlankDockElement* self,
                                             GeeArrayList* uris);
gboolean plank_dock_element_accept_drop (PlankDockElement* self,
                                         GeeArrayList* uris);
gchar* plank_dock_element_unique_id (PlankDockElement* self);
void plank_dock_element_reset_buffers (PlankDockElement* self);
void plank_dock_element_clicked (PlankDockElement* self,
                                 PlankPopupButton button,
                                 GdkModifierType mod,
                                 guint32 event_time);
void plank_dock_element_set_ClickedAnimation (PlankDockElement* self,
                                              PlankAnimationType value);
void plank_dock_element_set_LastClicked (PlankDockElement* self,
                                         gint64 value);
static PlankAnimationType plank_dock_element_real_on_clicked (PlankDockElement* self,
                                                       PlankPopupButton button,
                                                       GdkModifierType mod,
                                                       guint32 event_time);
void plank_dock_element_hovered (PlankDockElement* self);
void plank_dock_element_set_HoveredAnimation (PlankDockElement* self,
                                              PlankAnimationType value);
void plank_dock_element_set_LastHovered (PlankDockElement* self,
                                         gint64 value);
static PlankAnimationType plank_dock_element_real_on_hovered (PlankDockElement* self);
void plank_dock_element_scrolled (PlankDockElement* self,
                                  GdkScrollDirection direction,
                                  GdkModifierType mod,
                                  guint32 event_time);
void plank_dock_element_set_ScrolledAnimation (PlankDockElement* self,
                                               PlankAnimationType value);
static PlankAnimationType plank_dock_element_real_on_scrolled (PlankDockElement* self,
                                                        GdkScrollDirection direction,
                                                        GdkModifierType mod,
                                                        guint32 event_time);
void plank_dock_element_set_LastScrolled (PlankDockElement* self,
                                          gint64 value);
GType plank_dock_controller_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockController, g_object_unref)
PlankDockController* plank_dock_element_get_dock (PlankDockElement* self);
PlankDockContainer* plank_dock_element_get_Container (PlankDockElement* self);
static GeeArrayList* plank_dock_element_real_get_menu_items (PlankDockElement* self);
static gchar* plank_dock_element_real_get_drop_text (PlankDockElement* self);
static gboolean plank_dock_element_real_can_be_removed (PlankDockElement* self);
static gboolean plank_dock_element_real_can_accept_drop (PlankDockElement* self,
                                                  GeeArrayList* uris);
static gboolean plank_dock_element_real_accept_drop (PlankDockElement* self,
                                              GeeArrayList* uris);
static gchar* plank_dock_element_real_unique_id (PlankDockElement* self);
gchar* plank_dock_element_as_uri (PlankDockElement* self);
static void plank_dock_element_real_reset_buffers (PlankDockElement* self);
GtkMenuItem* plank_dock_element_create_menu_item (const gchar* title,
                                                  const gchar* icon,
                                                  gboolean force_show_icon);
static GtkMenuItem* plank_dock_element_create_menu_item_iternal (const gchar* title,
                                                          GdkPixbuf* pixbuf,
                                                          gboolean force_show_icon,
                                                          gboolean mnemonics);
GdkPixbuf* plank_drawing_service_load_icon (const gchar* names,
                                            gint width,
                                            gint height);
GtkMenuItem* plank_dock_element_create_menu_item_with_pixbuf (const gchar* title,
                                                              GdkPixbuf* pixbuf,
                                                              gboolean force_show_icon);
GdkPixbuf* plank_drawing_service_ar_scale (GdkPixbuf* source,
                                           gint width,
                                           gint height);
GtkMenuItem* plank_dock_element_create_literal_menu_item (const gchar* title,
                                                          const gchar* icon,
                                                          gboolean force_show_icon);
GtkMenuItem* plank_dock_element_create_literal_menu_item_with_pixbuf (const gchar* title,
                                                                      GdkPixbuf* pixbuf,
                                                                      gboolean force_show_icon);
PlankDockElement* plank_dock_element_construct (GType object_type);
void plank_dock_element_set_Container (PlankDockElement* self,
                                       PlankDockContainer* value);
const gchar* plank_dock_element_get_Text (PlankDockElement* self);
void plank_dock_element_set_Text (PlankDockElement* self,
                                  const gchar* value);
gboolean plank_dock_element_get_IsAttached (PlankDockElement* self);
void plank_dock_element_set_IsAttached (PlankDockElement* self,
                                        gboolean value);
gboolean plank_dock_element_get_IsVisible (PlankDockElement* self);
void plank_dock_element_set_IsVisible (PlankDockElement* self,
                                       gboolean value);
PlankPopupButton plank_dock_element_get_Button (PlankDockElement* self);
void plank_dock_element_set_Button (PlankDockElement* self,
                                    PlankPopupButton value);
PlankAnimationType plank_dock_element_get_ClickedAnimation (PlankDockElement* self);
PlankAnimationType plank_dock_element_get_HoveredAnimation (PlankDockElement* self);
PlankAnimationType plank_dock_element_get_ScrolledAnimation (PlankDockElement* self);
gint64 plank_dock_element_get_AddTime (PlankDockElement* self);
void plank_dock_element_set_AddTime (PlankDockElement* self,
                                     gint64 value);
gint64 plank_dock_element_get_RemoveTime (PlankDockElement* self);
void plank_dock_element_set_RemoveTime (PlankDockElement* self,
                                        gint64 value);
gint64 plank_dock_element_get_LastClicked (PlankDockElement* self);
gint64 plank_dock_element_get_LastHovered (PlankDockElement* self);
gint64 plank_dock_element_get_LastScrolled (PlankDockElement* self);
gint64 plank_dock_element_get_LastUrgent (PlankDockElement* self);
void plank_dock_element_set_LastUrgent (PlankDockElement* self,
                                        gint64 value);
gint64 plank_dock_element_get_LastActive (PlankDockElement* self);
void plank_dock_element_set_LastActive (PlankDockElement* self,
                                        gint64 value);
gint64 plank_dock_element_get_LastMove (PlankDockElement* self);
void plank_dock_element_set_LastMove (PlankDockElement* self,
                                      gint64 value);
gint64 plank_dock_element_get_LastValid (PlankDockElement* self);
void plank_dock_element_set_LastValid (PlankDockElement* self,
                                       gint64 value);
static void plank_dock_element_finalize (GObject * obj);
static GType plank_dock_element_get_type_once (void);
static void _vala_plank_dock_element_get_property (GObject * object,
                                            guint property_id,
                                            GValue * value,
                                            GParamSpec * pspec);
static void _vala_plank_dock_element_set_property (GObject * object,
                                            guint property_id,
                                            const GValue * value,
                                            GParamSpec * pspec);

static inline gpointer
plank_dock_element_get_instance_private (PlankDockElement* self)
{
	return G_STRUCT_MEMBER_P (self, PlankDockElement_private_offset);
}

/**
 * Called when an item is clicked on.
 *
 * @param button the button clicked
 * @param mod the modifiers
 * @param event_time the timestamp of the event triggering this action
 */
void
plank_dock_element_clicked (PlankDockElement* self,
                            PlankPopupButton button,
                            GdkModifierType mod,
                            guint32 event_time)
{
#line 128 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 130 "../lib/Items/DockElement.vala"
	plank_dock_element_set_ClickedAnimation (self, plank_dock_element_on_clicked (self, button, mod, event_time));
#line 131 "../lib/Items/DockElement.vala"
	plank_dock_element_set_LastClicked (self, g_get_monotonic_time ());
#line 316 "DockElement.c"
}

/**
 * Called when an item is clicked on.
 *
 * @param button the button clicked
 * @param mod the modifiers
 * @param event_time the timestamp of the event triggering this action
 * @return which type of animation to trigger
 */
static PlankAnimationType
plank_dock_element_real_on_clicked (PlankDockElement* self,
                                    PlankPopupButton button,
                                    GdkModifierType mod,
                                    guint32 event_time)
{
	PlankAnimationType result = 0;
#line 144 "../lib/Items/DockElement.vala"
	result = PLANK_ANIMATION_TYPE_NONE;
#line 144 "../lib/Items/DockElement.vala"
	return result;
#line 338 "DockElement.c"
}

PlankAnimationType
plank_dock_element_on_clicked (PlankDockElement* self,
                               PlankPopupButton button,
                               GdkModifierType mod,
                               guint32 event_time)
{
#line 142 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 142 "../lib/Items/DockElement.vala"
	return PLANK_DOCK_ELEMENT_GET_CLASS (self)->on_clicked (self, button, mod, event_time);
#line 351 "DockElement.c"
}

/**
 * Called when an item gets hovered.
 */
void
plank_dock_element_hovered (PlankDockElement* self)
{
#line 150 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 152 "../lib/Items/DockElement.vala"
	plank_dock_element_set_HoveredAnimation (self, plank_dock_element_on_hovered (self));
#line 153 "../lib/Items/DockElement.vala"
	plank_dock_element_set_LastHovered (self, g_get_monotonic_time ());
#line 366 "DockElement.c"
}

/**
 * Called when an item gets hovered.
 *
 * @return which type of animation to trigger
 */
static PlankAnimationType
plank_dock_element_real_on_hovered (PlankDockElement* self)
{
	PlankAnimationType result = 0;
#line 163 "../lib/Items/DockElement.vala"
	result = PLANK_ANIMATION_TYPE_LIGHTEN;
#line 163 "../lib/Items/DockElement.vala"
	return result;
#line 382 "DockElement.c"
}

PlankAnimationType
plank_dock_element_on_hovered (PlankDockElement* self)
{
#line 161 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 161 "../lib/Items/DockElement.vala"
	return PLANK_DOCK_ELEMENT_GET_CLASS (self)->on_hovered (self);
#line 392 "DockElement.c"
}

/**
 * Called when an item is scrolled over.
 *
 * @param direction the scroll direction
 * @param mod the modifiers
 * @param event_time the timestamp of the event triggering this action
 */
void
plank_dock_element_scrolled (PlankDockElement* self,
                             GdkScrollDirection direction,
                             GdkModifierType mod,
                             guint32 event_time)
{
#line 173 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 175 "../lib/Items/DockElement.vala"
	plank_dock_element_set_ScrolledAnimation (self, plank_dock_element_on_scrolled (self, direction, mod, event_time));
#line 412 "DockElement.c"
}

/**
 * Called when an item is scrolled over.
 *
 * @param direction the scroll direction
 * @param mod the modifiers
 * @param event_time the timestamp of the event triggering this action
 * @return which type of animation to trigger
 */
static PlankAnimationType
plank_dock_element_real_on_scrolled (PlankDockElement* self,
                                     GdkScrollDirection direction,
                                     GdkModifierType mod,
                                     guint32 event_time)
{
	PlankAnimationType result = 0;
#line 188 "../lib/Items/DockElement.vala"
	plank_dock_element_set_LastScrolled (self, g_get_monotonic_time ());
#line 189 "../lib/Items/DockElement.vala"
	result = PLANK_ANIMATION_TYPE_NONE;
#line 189 "../lib/Items/DockElement.vala"
	return result;
#line 436 "DockElement.c"
}

PlankAnimationType
plank_dock_element_on_scrolled (PlankDockElement* self,
                                GdkScrollDirection direction,
                                GdkModifierType mod,
                                guint32 event_time)
{
#line 186 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 186 "../lib/Items/DockElement.vala"
	return PLANK_DOCK_ELEMENT_GET_CLASS (self)->on_scrolled (self, direction, mod, event_time);
#line 449 "DockElement.c"
}

/**
 * Get the dock which this element is part of
 *
 * @return the dock-controller of this element, or null
 */
PlankDockController*
plank_dock_element_get_dock (PlankDockElement* self)
{
	PlankDockContainer* container = NULL;
	PlankDockContainer* _tmp0_;
	PlankDockController* result = NULL;
#line 197 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 199 "../lib/Items/DockElement.vala"
	_tmp0_ = self->priv->_Container;
#line 199 "../lib/Items/DockElement.vala"
	container = _tmp0_;
#line 201 "../lib/Items/DockElement.vala"
	while (TRUE) {
#line 471 "DockElement.c"
		PlankDockContainer* _tmp1_;
		PlankDockContainer* _tmp2_;
		PlankDockContainer* _tmp4_;
		PlankDockContainer* _tmp5_;
#line 201 "../lib/Items/DockElement.vala"
		_tmp1_ = container;
#line 201 "../lib/Items/DockElement.vala"
		if (!(_tmp1_ != NULL)) {
#line 201 "../lib/Items/DockElement.vala"
			break;
#line 482 "DockElement.c"
		}
#line 202 "../lib/Items/DockElement.vala"
		_tmp2_ = container;
#line 202 "../lib/Items/DockElement.vala"
		if (PLANK_IS_DOCK_CONTROLLER (_tmp2_)) {
#line 488 "DockElement.c"
			PlankDockContainer* _tmp3_;
#line 203 "../lib/Items/DockElement.vala"
			_tmp3_ = container;
#line 203 "../lib/Items/DockElement.vala"
			result = G_TYPE_CHECK_INSTANCE_CAST (_tmp3_, PLANK_TYPE_DOCK_CONTROLLER, PlankDockController);
#line 203 "../lib/Items/DockElement.vala"
			return result;
#line 496 "DockElement.c"
		}
#line 205 "../lib/Items/DockElement.vala"
		_tmp4_ = container;
#line 205 "../lib/Items/DockElement.vala"
		_tmp5_ = ((PlankDockElement*) _tmp4_)->priv->_Container;
#line 205 "../lib/Items/DockElement.vala"
		container = _tmp5_;
#line 504 "DockElement.c"
	}
#line 208 "../lib/Items/DockElement.vala"
	result = NULL;
#line 208 "../lib/Items/DockElement.vala"
	return result;
#line 510 "DockElement.c"
}

/**
 * Returns a list of the item's menu items.
 *
 * @return the item's menu items
 */
static GeeArrayList*
plank_dock_element_real_get_menu_items (PlankDockElement* self)
{
	GeeArrayList* _tmp0_;
	GeeArrayList* result = NULL;
#line 218 "../lib/Items/DockElement.vala"
	_tmp0_ = gee_array_list_new (gtk_menu_item_get_type (), (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL);
#line 218 "../lib/Items/DockElement.vala"
	result = _tmp0_;
#line 218 "../lib/Items/DockElement.vala"
	return result;
#line 529 "DockElement.c"
}

GeeArrayList*
plank_dock_element_get_menu_items (PlankDockElement* self)
{
#line 216 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 216 "../lib/Items/DockElement.vala"
	return PLANK_DOCK_ELEMENT_GET_CLASS (self)->get_menu_items (self);
#line 539 "DockElement.c"
}

/**
 * The item's text for drop actions.
 *
 * @return the item's drop-text
 */
static gchar*
plank_dock_element_real_get_drop_text (PlankDockElement* self)
{
	gchar* _tmp0_;
	gchar* result = NULL;
#line 228 "../lib/Items/DockElement.vala"
	_tmp0_ = g_strdup ("");
#line 228 "../lib/Items/DockElement.vala"
	result = _tmp0_;
#line 228 "../lib/Items/DockElement.vala"
	return result;
#line 558 "DockElement.c"
}

gchar*
plank_dock_element_get_drop_text (PlankDockElement* self)
{
#line 226 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 226 "../lib/Items/DockElement.vala"
	return PLANK_DOCK_ELEMENT_GET_CLASS (self)->get_drop_text (self);
#line 568 "DockElement.c"
}

/**
 * Returns if this item can be removed from the dock.
 *
 * @return if this item can be removed from the dock
 */
static gboolean
plank_dock_element_real_can_be_removed (PlankDockElement* self)
{
	gboolean result = FALSE;
#line 238 "../lib/Items/DockElement.vala"
	result = TRUE;
#line 238 "../lib/Items/DockElement.vala"
	return result;
#line 584 "DockElement.c"
}

gboolean
plank_dock_element_can_be_removed (PlankDockElement* self)
{
#line 236 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 236 "../lib/Items/DockElement.vala"
	return PLANK_DOCK_ELEMENT_GET_CLASS (self)->can_be_removed (self);
#line 594 "DockElement.c"
}

/**
 * Returns if the item accepts a drop of the given URIs.
 *
 * @param uris the URIs to check
 * @return if the item accepts a drop of the given URIs
 */
static gboolean
plank_dock_element_real_can_accept_drop (PlankDockElement* self,
                                         GeeArrayList* uris)
{
	gboolean result = FALSE;
#line 247 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (uris != NULL, FALSE);
#line 249 "../lib/Items/DockElement.vala"
	result = FALSE;
#line 249 "../lib/Items/DockElement.vala"
	return result;
#line 614 "DockElement.c"
}

gboolean
plank_dock_element_can_accept_drop (PlankDockElement* self,
                                    GeeArrayList* uris)
{
#line 247 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 247 "../lib/Items/DockElement.vala"
	return PLANK_DOCK_ELEMENT_GET_CLASS (self)->can_accept_drop (self, uris);
#line 625 "DockElement.c"
}

/**
 * Accepts a drop of the given URIs.
 *
 * @param uris the URIs to accept
 * @return if the item accepted a drop of the given URIs
 */
static gboolean
plank_dock_element_real_accept_drop (PlankDockElement* self,
                                     GeeArrayList* uris)
{
	gboolean result = FALSE;
#line 258 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (uris != NULL, FALSE);
#line 260 "../lib/Items/DockElement.vala"
	result = FALSE;
#line 260 "../lib/Items/DockElement.vala"
	return result;
#line 645 "DockElement.c"
}

gboolean
plank_dock_element_accept_drop (PlankDockElement* self,
                                GeeArrayList* uris)
{
#line 258 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 258 "../lib/Items/DockElement.vala"
	return PLANK_DOCK_ELEMENT_GET_CLASS (self)->accept_drop (self, uris);
#line 656 "DockElement.c"
}

/**
 * Returns a unique ID for this dock item.
 *
 * @return a unique ID for this dock element
 */
static gchar*
plank_dock_element_real_unique_id (PlankDockElement* self)
{
	gchar* _tmp0_;
	gchar* result = NULL;
#line 272 "../lib/Items/DockElement.vala"
	_tmp0_ = g_strdup_printf ("dockelement%p", self);
#line 272 "../lib/Items/DockElement.vala"
	result = _tmp0_;
#line 272 "../lib/Items/DockElement.vala"
	return result;
#line 675 "DockElement.c"
}

gchar*
plank_dock_element_unique_id (PlankDockElement* self)
{
#line 268 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 268 "../lib/Items/DockElement.vala"
	return PLANK_DOCK_ELEMENT_GET_CLASS (self)->unique_id (self);
#line 685 "DockElement.c"
}

/**
 * Returns a unique URI for this dock element.
 *
 * @return a unique URI for this dock element
 */
gchar*
plank_dock_element_as_uri (PlankDockElement* self)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* result = NULL;
#line 280 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 282 "../lib/Items/DockElement.vala"
	_tmp0_ = plank_dock_element_unique_id (self);
#line 282 "../lib/Items/DockElement.vala"
	_tmp1_ = _tmp0_;
#line 282 "../lib/Items/DockElement.vala"
	_tmp2_ = g_strdup_printf ("plank://%s", _tmp1_);
#line 282 "../lib/Items/DockElement.vala"
	_tmp3_ = _tmp2_;
#line 282 "../lib/Items/DockElement.vala"
	_g_free0 (_tmp1_);
#line 282 "../lib/Items/DockElement.vala"
	result = _tmp3_;
#line 282 "../lib/Items/DockElement.vala"
	return result;
#line 717 "DockElement.c"
}

/**
 * Resets the buffers for this element.
 */
static void
plank_dock_element_real_reset_buffers (PlankDockElement* self)
{
#line 288 "../lib/Items/DockElement.vala"
	g_critical ("Type `%s' does not implement abstract method `plank_dock_element_reset_buffers'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
#line 288 "../lib/Items/DockElement.vala"
	return;
#line 730 "DockElement.c"
}

void
plank_dock_element_reset_buffers (PlankDockElement* self)
{
#line 288 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 288 "../lib/Items/DockElement.vala"
	PLANK_DOCK_ELEMENT_GET_CLASS (self)->reset_buffers (self);
#line 740 "DockElement.c"
}

/**
 * Creates a new menu item with mnemonics enabled.
 *
 * @param title the title of the menu item
 * @param icon the icon of the menu item
 * @param force_show_icon whether to force showing the icon
 * @return the new menu item
 */
GtkMenuItem*
plank_dock_element_create_menu_item (const gchar* title,
                                     const gchar* icon,
                                     gboolean force_show_icon)
{
	gboolean _tmp0_ = FALSE;
	gint width = 0;
	gint height = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	GdkPixbuf* _tmp4_;
	GtkMenuItem* _tmp5_;
	GtkMenuItem* result = NULL;
#line 298 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (title != NULL, NULL);
#line 300 "../lib/Items/DockElement.vala"
	if (icon == NULL) {
#line 300 "../lib/Items/DockElement.vala"
		_tmp0_ = TRUE;
#line 770 "DockElement.c"
	} else {
#line 300 "../lib/Items/DockElement.vala"
		_tmp0_ = g_strcmp0 (icon, "") == 0;
#line 774 "DockElement.c"
	}
#line 300 "../lib/Items/DockElement.vala"
	if (_tmp0_) {
#line 778 "DockElement.c"
		GtkMenuItem* _tmp1_;
#line 301 "../lib/Items/DockElement.vala"
		_tmp1_ = (GtkMenuItem*) gtk_menu_item_new_with_mnemonic (title);
#line 301 "../lib/Items/DockElement.vala"
		g_object_ref_sink (_tmp1_);
#line 301 "../lib/Items/DockElement.vala"
		result = _tmp1_;
#line 301 "../lib/Items/DockElement.vala"
		return result;
#line 788 "DockElement.c"
	}
#line 304 "../lib/Items/DockElement.vala"
	gtk_icon_size_lookup (GTK_ICON_SIZE_MENU, &_tmp2_, &_tmp3_);
#line 304 "../lib/Items/DockElement.vala"
	width = _tmp2_;
#line 304 "../lib/Items/DockElement.vala"
	height = _tmp3_;
#line 306 "../lib/Items/DockElement.vala"
	_tmp4_ = plank_drawing_service_load_icon (icon, width, height);
#line 306 "../lib/Items/DockElement.vala"
	_tmp5_ = plank_dock_element_create_menu_item_iternal (title, _tmp4_, force_show_icon, TRUE);
#line 306 "../lib/Items/DockElement.vala"
	result = _tmp5_;
#line 306 "../lib/Items/DockElement.vala"
	return result;
#line 804 "DockElement.c"
}

/**
 * Creates a new menu item with mnemonics enabled.
 *
 * @param title the title of the menu item
 * @param pixbuf the icon of the menu item
 * @param force_show_icon whether to force showing the icon
 * @return the new menu item
 */
static gpointer
_g_object_ref0 (gpointer self)
{
#line 325 "../lib/Items/DockElement.vala"
	return self ? g_object_ref (self) : NULL;
#line 820 "DockElement.c"
}

GtkMenuItem*
plank_dock_element_create_menu_item_with_pixbuf (const gchar* title,
                                                 GdkPixbuf* pixbuf,
                                                 gboolean force_show_icon)
{
	gint width = 0;
	gint height = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	gint _tmp3_;
	gint _tmp4_;
	GdkPixbuf* _tmp8_;
	GtkMenuItem* _tmp9_;
	GtkMenuItem* result = NULL;
#line 317 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (title != NULL, NULL);
#line 317 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (pixbuf != NULL, NULL);
#line 320 "../lib/Items/DockElement.vala"
	gtk_icon_size_lookup (GTK_ICON_SIZE_MENU, &_tmp0_, &_tmp1_);
#line 320 "../lib/Items/DockElement.vala"
	width = _tmp0_;
#line 320 "../lib/Items/DockElement.vala"
	height = _tmp1_;
#line 322 "../lib/Items/DockElement.vala"
	_tmp3_ = gdk_pixbuf_get_width (pixbuf);
#line 322 "../lib/Items/DockElement.vala"
	_tmp4_ = _tmp3_;
#line 322 "../lib/Items/DockElement.vala"
	if (width != _tmp4_) {
#line 322 "../lib/Items/DockElement.vala"
		_tmp2_ = TRUE;
#line 856 "DockElement.c"
	} else {
		gint _tmp5_;
		gint _tmp6_;
#line 322 "../lib/Items/DockElement.vala"
		_tmp5_ = gdk_pixbuf_get_height (pixbuf);
#line 322 "../lib/Items/DockElement.vala"
		_tmp6_ = _tmp5_;
#line 322 "../lib/Items/DockElement.vala"
		_tmp2_ = height != _tmp6_;
#line 866 "DockElement.c"
	}
#line 322 "../lib/Items/DockElement.vala"
	if (_tmp2_) {
#line 870 "DockElement.c"
		GdkPixbuf* _tmp7_;
#line 323 "../lib/Items/DockElement.vala"
		_tmp7_ = plank_drawing_service_ar_scale (pixbuf, width, height);
#line 323 "../lib/Items/DockElement.vala"
		_g_object_unref0 (pixbuf);
#line 323 "../lib/Items/DockElement.vala"
		pixbuf = _tmp7_;
#line 878 "DockElement.c"
	}
#line 325 "../lib/Items/DockElement.vala"
	_tmp8_ = _g_object_ref0 (pixbuf);
#line 325 "../lib/Items/DockElement.vala"
	_tmp9_ = plank_dock_element_create_menu_item_iternal (title, _tmp8_, force_show_icon, TRUE);
#line 325 "../lib/Items/DockElement.vala"
	result = _tmp9_;
#line 325 "../lib/Items/DockElement.vala"
	_g_object_unref0 (pixbuf);
#line 325 "../lib/Items/DockElement.vala"
	return result;
#line 890 "DockElement.c"
}

/**
 * Creates a new menu item with mnemonics disabled.
 *
 * @param title the title of the menu item
 * @param icon the icon of the menu item
 * @param force_show_icon whether to force showing the icon
 * @return the new menu item
 */
GtkMenuItem*
plank_dock_element_create_literal_menu_item (const gchar* title,
                                             const gchar* icon,
                                             gboolean force_show_icon)
{
	gboolean _tmp0_ = FALSE;
	gint width = 0;
	gint height = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	GdkPixbuf* _tmp4_;
	GtkMenuItem* _tmp5_;
	GtkMenuItem* result = NULL;
#line 336 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (title != NULL, NULL);
#line 338 "../lib/Items/DockElement.vala"
	if (icon == NULL) {
#line 338 "../lib/Items/DockElement.vala"
		_tmp0_ = TRUE;
#line 920 "DockElement.c"
	} else {
#line 338 "../lib/Items/DockElement.vala"
		_tmp0_ = g_strcmp0 (icon, "") == 0;
#line 924 "DockElement.c"
	}
#line 338 "../lib/Items/DockElement.vala"
	if (_tmp0_) {
#line 928 "DockElement.c"
		GtkMenuItem* _tmp1_;
#line 339 "../lib/Items/DockElement.vala"
		_tmp1_ = (GtkMenuItem*) gtk_menu_item_new_with_label (title);
#line 339 "../lib/Items/DockElement.vala"
		g_object_ref_sink (_tmp1_);
#line 339 "../lib/Items/DockElement.vala"
		result = _tmp1_;
#line 339 "../lib/Items/DockElement.vala"
		return result;
#line 938 "DockElement.c"
	}
#line 342 "../lib/Items/DockElement.vala"
	gtk_icon_size_lookup (GTK_ICON_SIZE_MENU, &_tmp2_, &_tmp3_);
#line 342 "../lib/Items/DockElement.vala"
	width = _tmp2_;
#line 342 "../lib/Items/DockElement.vala"
	height = _tmp3_;
#line 344 "../lib/Items/DockElement.vala"
	_tmp4_ = plank_drawing_service_load_icon (icon, width, height);
#line 344 "../lib/Items/DockElement.vala"
	_tmp5_ = plank_dock_element_create_menu_item_iternal (title, _tmp4_, force_show_icon, FALSE);
#line 344 "../lib/Items/DockElement.vala"
	result = _tmp5_;
#line 344 "../lib/Items/DockElement.vala"
	return result;
#line 954 "DockElement.c"
}

/**
 * Creates a new menu item with mnemonics disabled.
 *
 * @param title the title of the menu item
 * @param pixbuf the icon of the menu item
 * @param force_show_icon whether to force showing the icon
 * @return the new menu item
 */
GtkMenuItem*
plank_dock_element_create_literal_menu_item_with_pixbuf (const gchar* title,
                                                         GdkPixbuf* pixbuf,
                                                         gboolean force_show_icon)
{
	gint width = 0;
	gint height = 0;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	gboolean _tmp2_ = FALSE;
	gint _tmp3_;
	gint _tmp4_;
	GdkPixbuf* _tmp8_;
	GtkMenuItem* _tmp9_;
	GtkMenuItem* result = NULL;
#line 355 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (title != NULL, NULL);
#line 355 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (pixbuf != NULL, NULL);
#line 358 "../lib/Items/DockElement.vala"
	gtk_icon_size_lookup (GTK_ICON_SIZE_MENU, &_tmp0_, &_tmp1_);
#line 358 "../lib/Items/DockElement.vala"
	width = _tmp0_;
#line 358 "../lib/Items/DockElement.vala"
	height = _tmp1_;
#line 360 "../lib/Items/DockElement.vala"
	_tmp3_ = gdk_pixbuf_get_width (pixbuf);
#line 360 "../lib/Items/DockElement.vala"
	_tmp4_ = _tmp3_;
#line 360 "../lib/Items/DockElement.vala"
	if (width != _tmp4_) {
#line 360 "../lib/Items/DockElement.vala"
		_tmp2_ = TRUE;
#line 998 "DockElement.c"
	} else {
		gint _tmp5_;
		gint _tmp6_;
#line 360 "../lib/Items/DockElement.vala"
		_tmp5_ = gdk_pixbuf_get_height (pixbuf);
#line 360 "../lib/Items/DockElement.vala"
		_tmp6_ = _tmp5_;
#line 360 "../lib/Items/DockElement.vala"
		_tmp2_ = height != _tmp6_;
#line 1008 "DockElement.c"
	}
#line 360 "../lib/Items/DockElement.vala"
	if (_tmp2_) {
#line 1012 "DockElement.c"
		GdkPixbuf* _tmp7_;
#line 361 "../lib/Items/DockElement.vala"
		_tmp7_ = plank_drawing_service_ar_scale (pixbuf, width, height);
#line 361 "../lib/Items/DockElement.vala"
		_g_object_unref0 (pixbuf);
#line 361 "../lib/Items/DockElement.vala"
		pixbuf = _tmp7_;
#line 1020 "DockElement.c"
	}
#line 363 "../lib/Items/DockElement.vala"
	_tmp8_ = _g_object_ref0 (pixbuf);
#line 363 "../lib/Items/DockElement.vala"
	_tmp9_ = plank_dock_element_create_menu_item_iternal (title, _tmp8_, force_show_icon, FALSE);
#line 363 "../lib/Items/DockElement.vala"
	result = _tmp9_;
#line 363 "../lib/Items/DockElement.vala"
	_g_object_unref0 (pixbuf);
#line 363 "../lib/Items/DockElement.vala"
	return result;
#line 1032 "DockElement.c"
}

static GtkMenuItem*
plank_dock_element_create_menu_item_iternal (const gchar* title,
                                             GdkPixbuf* pixbuf,
                                             gboolean force_show_icon,
                                             gboolean mnemonics)
{
	GtkImageMenuItem* _tmp0_ = NULL;
	GtkImageMenuItem* item = NULL;
	GtkImageMenuItem* _tmp3_;
	GtkImageMenuItem* _tmp4_;
	GtkImage* _tmp5_;
	GtkImage* _tmp6_;
	GtkMenuItem* result = NULL;
#line 366 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (title != NULL, NULL);
#line 366 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (pixbuf != NULL, NULL);
#line 368 "../lib/Items/DockElement.vala"
	if (mnemonics) {
#line 1054 "DockElement.c"
		GtkImageMenuItem* _tmp1_;
#line 368 "../lib/Items/DockElement.vala"
		_tmp1_ = (GtkImageMenuItem*) gtk_image_menu_item_new_with_mnemonic (title);
#line 368 "../lib/Items/DockElement.vala"
		g_object_ref_sink (_tmp1_);
#line 368 "../lib/Items/DockElement.vala"
		_g_object_unref0 (_tmp0_);
#line 368 "../lib/Items/DockElement.vala"
		_tmp0_ = _tmp1_;
#line 1064 "DockElement.c"
	} else {
		GtkImageMenuItem* _tmp2_;
#line 368 "../lib/Items/DockElement.vala"
		_tmp2_ = (GtkImageMenuItem*) gtk_image_menu_item_new_with_label (title);
#line 368 "../lib/Items/DockElement.vala"
		g_object_ref_sink (_tmp2_);
#line 368 "../lib/Items/DockElement.vala"
		_g_object_unref0 (_tmp0_);
#line 368 "../lib/Items/DockElement.vala"
		_tmp0_ = _tmp2_;
#line 1075 "DockElement.c"
	}
#line 368 "../lib/Items/DockElement.vala"
	_tmp3_ = _g_object_ref0 (_tmp0_);
#line 368 "../lib/Items/DockElement.vala"
	item = _tmp3_;
#line 369 "../lib/Items/DockElement.vala"
	_tmp4_ = item;
#line 369 "../lib/Items/DockElement.vala"
	_tmp5_ = (GtkImage*) gtk_image_new_from_pixbuf (pixbuf);
#line 369 "../lib/Items/DockElement.vala"
	g_object_ref_sink (_tmp5_);
#line 369 "../lib/Items/DockElement.vala"
	_tmp6_ = _tmp5_;
#line 369 "../lib/Items/DockElement.vala"
	gtk_image_menu_item_set_image (_tmp4_, (GtkWidget*) _tmp6_);
#line 369 "../lib/Items/DockElement.vala"
	_g_object_unref0 (_tmp6_);
#line 370 "../lib/Items/DockElement.vala"
	if (force_show_icon) {
#line 1095 "DockElement.c"
		GtkImageMenuItem* _tmp7_;
#line 371 "../lib/Items/DockElement.vala"
		_tmp7_ = item;
#line 371 "../lib/Items/DockElement.vala"
		gtk_image_menu_item_set_always_show_image (_tmp7_, TRUE);
#line 1101 "DockElement.c"
	}
#line 373 "../lib/Items/DockElement.vala"
	result = (GtkMenuItem*) item;
#line 373 "../lib/Items/DockElement.vala"
	_g_object_unref0 (_tmp0_);
#line 373 "../lib/Items/DockElement.vala"
	_g_object_unref0 (pixbuf);
#line 373 "../lib/Items/DockElement.vala"
	return result;
#line 1111 "DockElement.c"
}

PlankDockElement*
plank_dock_element_construct (GType object_type)
{
	PlankDockElement * self = NULL;
#line 25 "../lib/Items/DockElement.vala"
	self = (PlankDockElement*) g_object_new (object_type, NULL);
#line 25 "../lib/Items/DockElement.vala"
	return self;
#line 1122 "DockElement.c"
}

PlankDockContainer*
plank_dock_element_get_Container (PlankDockElement* self)
{
	PlankDockContainer* result;
	PlankDockContainer* _tmp0_;
#line 35 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 35 "../lib/Items/DockElement.vala"
	_tmp0_ = self->priv->_Container;
#line 35 "../lib/Items/DockElement.vala"
	result = _tmp0_;
#line 35 "../lib/Items/DockElement.vala"
	return result;
#line 1138 "DockElement.c"
}

void
plank_dock_element_set_Container (PlankDockElement* self,
                                  PlankDockContainer* value)
{
	PlankDockContainer* old_value;
#line 35 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 35 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_Container (self);
#line 35 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 1152 "DockElement.c"
		PlankDockContainer* _tmp0_;
#line 35 "../lib/Items/DockElement.vala"
		_tmp0_ = _g_object_ref0 (value);
#line 35 "../lib/Items/DockElement.vala"
		_g_object_unref0 (self->priv->_Container);
#line 35 "../lib/Items/DockElement.vala"
		self->priv->_Container = _tmp0_;
#line 35 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_CONTAINER_PROPERTY]);
#line 1162 "DockElement.c"
	}
}

const gchar*
plank_dock_element_get_Text (PlankDockElement* self)
{
	const gchar* result;
	const gchar* _tmp0_;
#line 40 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 40 "../lib/Items/DockElement.vala"
	_tmp0_ = self->priv->_Text;
#line 40 "../lib/Items/DockElement.vala"
	result = _tmp0_;
#line 40 "../lib/Items/DockElement.vala"
	return result;
#line 1179 "DockElement.c"
}

void
plank_dock_element_set_Text (PlankDockElement* self,
                             const gchar* value)
{
	gchar* old_value;
#line 40 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 40 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_Text (self);
#line 40 "../lib/Items/DockElement.vala"
	if (g_strcmp0 (value, old_value) != 0) {
#line 1193 "DockElement.c"
		gchar* _tmp0_;
#line 40 "../lib/Items/DockElement.vala"
		_tmp0_ = g_strdup (value);
#line 40 "../lib/Items/DockElement.vala"
		_g_free0 (self->priv->_Text);
#line 40 "../lib/Items/DockElement.vala"
		self->priv->_Text = _tmp0_;
#line 40 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_TEXT_PROPERTY]);
#line 1203 "DockElement.c"
	}
}

gboolean
plank_dock_element_get_IsAttached (PlankDockElement* self)
{
	gboolean result;
#line 47 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 47 "../lib/Items/DockElement.vala"
	result = self->priv->_IsAttached;
#line 47 "../lib/Items/DockElement.vala"
	return result;
#line 1217 "DockElement.c"
}

void
plank_dock_element_set_IsAttached (PlankDockElement* self,
                                   gboolean value)
{
	gboolean old_value;
#line 47 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 47 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_IsAttached (self);
#line 47 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 47 "../lib/Items/DockElement.vala"
		self->priv->_IsAttached = value;
#line 47 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_IS_ATTACHED_PROPERTY]);
#line 1235 "DockElement.c"
	}
}

gboolean
plank_dock_element_get_IsVisible (PlankDockElement* self)
{
	gboolean result;
#line 54 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 54 "../lib/Items/DockElement.vala"
	result = self->priv->_IsVisible;
#line 54 "../lib/Items/DockElement.vala"
	return result;
#line 1249 "DockElement.c"
}

void
plank_dock_element_set_IsVisible (PlankDockElement* self,
                                  gboolean value)
{
	gboolean old_value;
#line 54 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 54 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_IsVisible (self);
#line 54 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 54 "../lib/Items/DockElement.vala"
		self->priv->_IsVisible = value;
#line 54 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_IS_VISIBLE_PROPERTY]);
#line 1267 "DockElement.c"
	}
}

PlankPopupButton
plank_dock_element_get_Button (PlankDockElement* self)
{
	PlankPopupButton result;
	PlankPopupButton _tmp0_;
#line 59 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0U);
#line 59 "../lib/Items/DockElement.vala"
	_tmp0_ = self->priv->_Button;
#line 59 "../lib/Items/DockElement.vala"
	result = _tmp0_;
#line 59 "../lib/Items/DockElement.vala"
	return result;
#line 1284 "DockElement.c"
}

void
plank_dock_element_set_Button (PlankDockElement* self,
                               PlankPopupButton value)
{
	PlankPopupButton old_value;
#line 59 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 59 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_Button (self);
#line 59 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 59 "../lib/Items/DockElement.vala"
		self->priv->_Button = value;
#line 59 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_BUTTON_PROPERTY]);
#line 1302 "DockElement.c"
	}
}

PlankAnimationType
plank_dock_element_get_ClickedAnimation (PlankDockElement* self)
{
	PlankAnimationType result;
	PlankAnimationType _tmp0_;
#line 64 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 64 "../lib/Items/DockElement.vala"
	_tmp0_ = self->priv->_ClickedAnimation;
#line 64 "../lib/Items/DockElement.vala"
	result = _tmp0_;
#line 64 "../lib/Items/DockElement.vala"
	return result;
#line 1319 "DockElement.c"
}

void
plank_dock_element_set_ClickedAnimation (PlankDockElement* self,
                                         PlankAnimationType value)
{
	PlankAnimationType old_value;
#line 64 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 64 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_ClickedAnimation (self);
#line 64 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 64 "../lib/Items/DockElement.vala"
		self->priv->_ClickedAnimation = value;
#line 64 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_CLICKED_ANIMATION_PROPERTY]);
#line 1337 "DockElement.c"
	}
}

PlankAnimationType
plank_dock_element_get_HoveredAnimation (PlankDockElement* self)
{
	PlankAnimationType result;
	PlankAnimationType _tmp0_;
#line 69 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 69 "../lib/Items/DockElement.vala"
	_tmp0_ = self->priv->_HoveredAnimation;
#line 69 "../lib/Items/DockElement.vala"
	result = _tmp0_;
#line 69 "../lib/Items/DockElement.vala"
	return result;
#line 1354 "DockElement.c"
}

void
plank_dock_element_set_HoveredAnimation (PlankDockElement* self,
                                         PlankAnimationType value)
{
	PlankAnimationType old_value;
#line 69 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 69 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_HoveredAnimation (self);
#line 69 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 69 "../lib/Items/DockElement.vala"
		self->priv->_HoveredAnimation = value;
#line 69 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_HOVERED_ANIMATION_PROPERTY]);
#line 1372 "DockElement.c"
	}
}

PlankAnimationType
plank_dock_element_get_ScrolledAnimation (PlankDockElement* self)
{
	PlankAnimationType result;
	PlankAnimationType _tmp0_;
#line 74 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 74 "../lib/Items/DockElement.vala"
	_tmp0_ = self->priv->_ScrolledAnimation;
#line 74 "../lib/Items/DockElement.vala"
	result = _tmp0_;
#line 74 "../lib/Items/DockElement.vala"
	return result;
#line 1389 "DockElement.c"
}

void
plank_dock_element_set_ScrolledAnimation (PlankDockElement* self,
                                          PlankAnimationType value)
{
	PlankAnimationType old_value;
#line 74 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 74 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_ScrolledAnimation (self);
#line 74 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 74 "../lib/Items/DockElement.vala"
		self->priv->_ScrolledAnimation = value;
#line 74 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_SCROLLED_ANIMATION_PROPERTY]);
#line 1407 "DockElement.c"
	}
}

gint64
plank_dock_element_get_AddTime (PlankDockElement* self)
{
	gint64 result;
#line 79 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0LL);
#line 79 "../lib/Items/DockElement.vala"
	result = self->priv->_AddTime;
#line 79 "../lib/Items/DockElement.vala"
	return result;
#line 1421 "DockElement.c"
}

void
plank_dock_element_set_AddTime (PlankDockElement* self,
                                gint64 value)
{
	gint64 old_value;
#line 79 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 79 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_AddTime (self);
#line 79 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 79 "../lib/Items/DockElement.vala"
		self->priv->_AddTime = value;
#line 79 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_ADD_TIME_PROPERTY]);
#line 1439 "DockElement.c"
	}
}

gint64
plank_dock_element_get_RemoveTime (PlankDockElement* self)
{
	gint64 result;
#line 84 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0LL);
#line 84 "../lib/Items/DockElement.vala"
	result = self->priv->_RemoveTime;
#line 84 "../lib/Items/DockElement.vala"
	return result;
#line 1453 "DockElement.c"
}

void
plank_dock_element_set_RemoveTime (PlankDockElement* self,
                                   gint64 value)
{
	gint64 old_value;
#line 84 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 84 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_RemoveTime (self);
#line 84 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 84 "../lib/Items/DockElement.vala"
		self->priv->_RemoveTime = value;
#line 84 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_REMOVE_TIME_PROPERTY]);
#line 1471 "DockElement.c"
	}
}

gint64
plank_dock_element_get_LastClicked (PlankDockElement* self)
{
	gint64 result;
#line 89 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0LL);
#line 89 "../lib/Items/DockElement.vala"
	result = self->priv->_LastClicked;
#line 89 "../lib/Items/DockElement.vala"
	return result;
#line 1485 "DockElement.c"
}

void
plank_dock_element_set_LastClicked (PlankDockElement* self,
                                    gint64 value)
{
	gint64 old_value;
#line 89 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 89 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_LastClicked (self);
#line 89 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 89 "../lib/Items/DockElement.vala"
		self->priv->_LastClicked = value;
#line 89 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_CLICKED_PROPERTY]);
#line 1503 "DockElement.c"
	}
}

gint64
plank_dock_element_get_LastHovered (PlankDockElement* self)
{
	gint64 result;
#line 94 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0LL);
#line 94 "../lib/Items/DockElement.vala"
	result = self->priv->_LastHovered;
#line 94 "../lib/Items/DockElement.vala"
	return result;
#line 1517 "DockElement.c"
}

void
plank_dock_element_set_LastHovered (PlankDockElement* self,
                                    gint64 value)
{
	gint64 old_value;
#line 94 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 94 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_LastHovered (self);
#line 94 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 94 "../lib/Items/DockElement.vala"
		self->priv->_LastHovered = value;
#line 94 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_HOVERED_PROPERTY]);
#line 1535 "DockElement.c"
	}
}

gint64
plank_dock_element_get_LastScrolled (PlankDockElement* self)
{
	gint64 result;
#line 99 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0LL);
#line 99 "../lib/Items/DockElement.vala"
	result = self->priv->_LastScrolled;
#line 99 "../lib/Items/DockElement.vala"
	return result;
#line 1549 "DockElement.c"
}

void
plank_dock_element_set_LastScrolled (PlankDockElement* self,
                                     gint64 value)
{
	gint64 old_value;
#line 99 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 99 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_LastScrolled (self);
#line 99 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 99 "../lib/Items/DockElement.vala"
		self->priv->_LastScrolled = value;
#line 99 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_SCROLLED_PROPERTY]);
#line 1567 "DockElement.c"
	}
}

gint64
plank_dock_element_get_LastUrgent (PlankDockElement* self)
{
	gint64 result;
#line 104 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0LL);
#line 104 "../lib/Items/DockElement.vala"
	result = self->priv->_LastUrgent;
#line 104 "../lib/Items/DockElement.vala"
	return result;
#line 1581 "DockElement.c"
}

void
plank_dock_element_set_LastUrgent (PlankDockElement* self,
                                   gint64 value)
{
	gint64 old_value;
#line 104 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 104 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_LastUrgent (self);
#line 104 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 104 "../lib/Items/DockElement.vala"
		self->priv->_LastUrgent = value;
#line 104 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_URGENT_PROPERTY]);
#line 1599 "DockElement.c"
	}
}

gint64
plank_dock_element_get_LastActive (PlankDockElement* self)
{
	gint64 result;
#line 109 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0LL);
#line 109 "../lib/Items/DockElement.vala"
	result = self->priv->_LastActive;
#line 109 "../lib/Items/DockElement.vala"
	return result;
#line 1613 "DockElement.c"
}

void
plank_dock_element_set_LastActive (PlankDockElement* self,
                                   gint64 value)
{
	gint64 old_value;
#line 109 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 109 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_LastActive (self);
#line 109 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 109 "../lib/Items/DockElement.vala"
		self->priv->_LastActive = value;
#line 109 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_ACTIVE_PROPERTY]);
#line 1631 "DockElement.c"
	}
}

gint64
plank_dock_element_get_LastMove (PlankDockElement* self)
{
	gint64 result;
#line 114 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0LL);
#line 114 "../lib/Items/DockElement.vala"
	result = self->priv->_LastMove;
#line 114 "../lib/Items/DockElement.vala"
	return result;
#line 1645 "DockElement.c"
}

void
plank_dock_element_set_LastMove (PlankDockElement* self,
                                 gint64 value)
{
	gint64 old_value;
#line 114 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 114 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_LastMove (self);
#line 114 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 114 "../lib/Items/DockElement.vala"
		self->priv->_LastMove = value;
#line 114 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_MOVE_PROPERTY]);
#line 1663 "DockElement.c"
	}
}

gint64
plank_dock_element_get_LastValid (PlankDockElement* self)
{
	gint64 result;
#line 119 "../lib/Items/DockElement.vala"
	g_return_val_if_fail (self != NULL, 0LL);
#line 119 "../lib/Items/DockElement.vala"
	result = self->priv->_LastValid;
#line 119 "../lib/Items/DockElement.vala"
	return result;
#line 1677 "DockElement.c"
}

void
plank_dock_element_set_LastValid (PlankDockElement* self,
                                  gint64 value)
{
	gint64 old_value;
#line 119 "../lib/Items/DockElement.vala"
	g_return_if_fail (self != NULL);
#line 119 "../lib/Items/DockElement.vala"
	old_value = plank_dock_element_get_LastValid (self);
#line 119 "../lib/Items/DockElement.vala"
	if (old_value != value) {
#line 119 "../lib/Items/DockElement.vala"
		self->priv->_LastValid = value;
#line 119 "../lib/Items/DockElement.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_VALID_PROPERTY]);
#line 1695 "DockElement.c"
	}
}

static void
plank_dock_element_class_init (PlankDockElementClass * klass,
                               gpointer klass_data)
{
#line 25 "../lib/Items/DockElement.vala"
	plank_dock_element_parent_class = g_type_class_peek_parent (klass);
#line 25 "../lib/Items/DockElement.vala"
	g_type_class_adjust_private_offset (klass, &PlankDockElement_private_offset);
#line 25 "../lib/Items/DockElement.vala"
	((PlankDockElementClass *) klass)->on_clicked = (PlankAnimationType (*) (PlankDockElement*, PlankPopupButton, GdkModifierType, guint32)) plank_dock_element_real_on_clicked;
#line 25 "../lib/Items/DockElement.vala"
	((PlankDockElementClass *) klass)->on_hovered = (PlankAnimationType (*) (PlankDockElement*)) plank_dock_element_real_on_hovered;
#line 25 "../lib/Items/DockElement.vala"
	((PlankDockElementClass *) klass)->on_scrolled = (PlankAnimationType (*) (PlankDockElement*, GdkScrollDirection, GdkModifierType, guint32)) plank_dock_element_real_on_scrolled;
#line 25 "../lib/Items/DockElement.vala"
	((PlankDockElementClass *) klass)->get_menu_items = (GeeArrayList* (*) (PlankDockElement*)) plank_dock_element_real_get_menu_items;
#line 25 "../lib/Items/DockElement.vala"
	((PlankDockElementClass *) klass)->get_drop_text = (gchar* (*) (PlankDockElement*)) plank_dock_element_real_get_drop_text;
#line 25 "../lib/Items/DockElement.vala"
	((PlankDockElementClass *) klass)->can_be_removed = (gboolean (*) (PlankDockElement*)) plank_dock_element_real_can_be_removed;
#line 25 "../lib/Items/DockElement.vala"
	((PlankDockElementClass *) klass)->can_accept_drop = (gboolean (*) (PlankDockElement*, GeeArrayList*)) plank_dock_element_real_can_accept_drop;
#line 25 "../lib/Items/DockElement.vala"
	((PlankDockElementClass *) klass)->accept_drop = (gboolean (*) (PlankDockElement*, GeeArrayList*)) plank_dock_element_real_accept_drop;
#line 25 "../lib/Items/DockElement.vala"
	((PlankDockElementClass *) klass)->unique_id = (gchar* (*) (PlankDockElement*)) plank_dock_element_real_unique_id;
#line 25 "../lib/Items/DockElement.vala"
	((PlankDockElementClass *) klass)->reset_buffers = (void (*) (PlankDockElement*)) plank_dock_element_real_reset_buffers;
#line 25 "../lib/Items/DockElement.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_plank_dock_element_get_property;
#line 25 "../lib/Items/DockElement.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_plank_dock_element_set_property;
#line 25 "../lib/Items/DockElement.vala"
	G_OBJECT_CLASS (klass)->finalize = plank_dock_element_finalize;
#line 1733 "DockElement.c"
	/**
	 * The dock element's container which it is added too (if any).
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_CONTAINER_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_CONTAINER_PROPERTY] = g_param_spec_object ("Container", "Container", "Container", PLANK_TYPE_DOCK_CONTAINER, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1739 "DockElement.c"
	/**
	 * The dock item's text.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_TEXT_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_TEXT_PROPERTY] = g_param_spec_string ("Text", "Text", "Text", NULL, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1745 "DockElement.c"
	/**
	 * Whether the item is currently hidden on the dock.
	 * If TRUE it will be drawn and does consume space.
	 * If FALSE it will not be drawn and does not consume space.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_IS_ATTACHED_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_IS_ATTACHED_PROPERTY] = g_param_spec_boolean ("IsAttached", "IsAttached", "IsAttached", TRUE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1753 "DockElement.c"
	/**
	 * Whether the item is currently visible on the dock.
	 * If TRUE it will be drawn and does consume space.
	 * If FALSE it will not be drawn and does consume space.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_IS_VISIBLE_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_IS_VISIBLE_PROPERTY] = g_param_spec_boolean ("IsVisible", "IsVisible", "IsVisible", TRUE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1761 "DockElement.c"
	/**
	 * The buttons this item shows popup menus for.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_BUTTON_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_BUTTON_PROPERTY] = g_param_spec_flags ("Button", "Button", "Button", PLANK_TYPE_POPUP_BUTTON, PLANK_POPUP_BUTTON_RIGHT, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1767 "DockElement.c"
	/**
	 * The animation to show for the item's last click event.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_CLICKED_ANIMATION_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_CLICKED_ANIMATION_PROPERTY] = g_param_spec_enum ("ClickedAnimation", "ClickedAnimation", "ClickedAnimation", PLANK_TYPE_ANIMATION_TYPE, PLANK_ANIMATION_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1773 "DockElement.c"
	/**
	 * The animation to show for the item's last hover event.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_HOVERED_ANIMATION_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_HOVERED_ANIMATION_PROPERTY] = g_param_spec_enum ("HoveredAnimation", "HoveredAnimation", "HoveredAnimation", PLANK_TYPE_ANIMATION_TYPE, PLANK_ANIMATION_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1779 "DockElement.c"
	/**
	 * The animation to show for the item's last scroll event.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_SCROLLED_ANIMATION_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_SCROLLED_ANIMATION_PROPERTY] = g_param_spec_enum ("ScrolledAnimation", "ScrolledAnimation", "ScrolledAnimation", PLANK_TYPE_ANIMATION_TYPE, PLANK_ANIMATION_TYPE_NONE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1785 "DockElement.c"
	/**
	 * The time the item was added to the dock.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_ADD_TIME_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_ADD_TIME_PROPERTY] = g_param_spec_int64 ("AddTime", "AddTime", "AddTime", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1791 "DockElement.c"
	/**
	 * The time the item was removed from the dock.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_REMOVE_TIME_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_REMOVE_TIME_PROPERTY] = g_param_spec_int64 ("RemoveTime", "RemoveTime", "RemoveTime", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1797 "DockElement.c"
	/**
	 * The last time the item was clicked.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_LAST_CLICKED_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_CLICKED_PROPERTY] = g_param_spec_int64 ("LastClicked", "LastClicked", "LastClicked", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1803 "DockElement.c"
	/**
	 * The last time the item was hovered.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_LAST_HOVERED_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_HOVERED_PROPERTY] = g_param_spec_int64 ("LastHovered", "LastHovered", "LastHovered", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1809 "DockElement.c"
	/**
	 * The last time the item was scrolled.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_LAST_SCROLLED_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_SCROLLED_PROPERTY] = g_param_spec_int64 ("LastScrolled", "LastScrolled", "LastScrolled", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1815 "DockElement.c"
	/**
	 * The last time the item changed its urgent status.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_LAST_URGENT_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_URGENT_PROPERTY] = g_param_spec_int64 ("LastUrgent", "LastUrgent", "LastUrgent", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1821 "DockElement.c"
	/**
	 * The last time the item changed its active status.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_LAST_ACTIVE_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_ACTIVE_PROPERTY] = g_param_spec_int64 ("LastActive", "LastActive", "LastActive", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1827 "DockElement.c"
	/**
	 * The last time the item changed its position.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_LAST_MOVE_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_MOVE_PROPERTY] = g_param_spec_int64 ("LastMove", "LastMove", "LastMove", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1833 "DockElement.c"
	/**
	 * The last time the item was valid.
	 */
#line 25 "../lib/Items/DockElement.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DOCK_ELEMENT_LAST_VALID_PROPERTY, plank_dock_element_properties[PLANK_DOCK_ELEMENT_LAST_VALID_PROPERTY] = g_param_spec_int64 ("LastValid", "LastValid", "LastValid", G_MININT64, G_MAXINT64, 0, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE | G_PARAM_WRITABLE));
#line 1839 "DockElement.c"
	/**
	 * Signal fired when the dock element needs redrawn.
	 */
#line 25 "../lib/Items/DockElement.vala"
	plank_dock_element_signals[PLANK_DOCK_ELEMENT_NEEDS_REDRAW_SIGNAL] = g_signal_new ("needs-redraw", PLANK_TYPE_DOCK_ELEMENT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
#line 1845 "DockElement.c"
}

static void
plank_dock_element_instance_init (PlankDockElement * self,
                                  gpointer klass)
{
	gchar* _tmp0_;
#line 25 "../lib/Items/DockElement.vala"
	self->priv = plank_dock_element_get_instance_private (self);
#line 35 "../lib/Items/DockElement.vala"
	self->priv->_Container = NULL;
#line 40 "../lib/Items/DockElement.vala"
	_tmp0_ = g_strdup ("");
#line 40 "../lib/Items/DockElement.vala"
	self->priv->_Text = _tmp0_;
#line 47 "../lib/Items/DockElement.vala"
	self->priv->_IsAttached = TRUE;
#line 54 "../lib/Items/DockElement.vala"
	self->priv->_IsVisible = TRUE;
#line 59 "../lib/Items/DockElement.vala"
	self->priv->_Button = PLANK_POPUP_BUTTON_RIGHT;
#line 64 "../lib/Items/DockElement.vala"
	self->priv->_ClickedAnimation = PLANK_ANIMATION_TYPE_NONE;
#line 69 "../lib/Items/DockElement.vala"
	self->priv->_HoveredAnimation = PLANK_ANIMATION_TYPE_NONE;
#line 74 "../lib/Items/DockElement.vala"
	self->priv->_ScrolledAnimation = PLANK_ANIMATION_TYPE_NONE;
#line 1873 "DockElement.c"
}

static void
plank_dock_element_finalize (GObject * obj)
{
	PlankDockElement * self;
#line 25 "../lib/Items/DockElement.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_DOCK_ELEMENT, PlankDockElement);
#line 35 "../lib/Items/DockElement.vala"
	_g_object_unref0 (self->priv->_Container);
#line 40 "../lib/Items/DockElement.vala"
	_g_free0 (self->priv->_Text);
#line 25 "../lib/Items/DockElement.vala"
	G_OBJECT_CLASS (plank_dock_element_parent_class)->finalize (obj);
#line 1888 "DockElement.c"
}

/**
 * The base class for all dock elements.
 */
static GType
plank_dock_element_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankDockElementClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_dock_element_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankDockElement), 0, (GInstanceInitFunc) plank_dock_element_instance_init, NULL };
	GType plank_dock_element_type_id;
	plank_dock_element_type_id = g_type_register_static (G_TYPE_OBJECT, "PlankDockElement", &g_define_type_info, G_TYPE_FLAG_ABSTRACT);
	PlankDockElement_private_offset = g_type_add_instance_private (plank_dock_element_type_id, sizeof (PlankDockElementPrivate));
	return plank_dock_element_type_id;
}

GType
plank_dock_element_get_type (void)
{
	static volatile gsize plank_dock_element_type_id__volatile = 0;
	if (g_once_init_enter (&plank_dock_element_type_id__volatile)) {
		GType plank_dock_element_type_id;
		plank_dock_element_type_id = plank_dock_element_get_type_once ();
		g_once_init_leave (&plank_dock_element_type_id__volatile, plank_dock_element_type_id);
	}
	return plank_dock_element_type_id__volatile;
}

static void
_vala_plank_dock_element_get_property (GObject * object,
                                       guint property_id,
                                       GValue * value,
                                       GParamSpec * pspec)
{
	PlankDockElement * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_DOCK_ELEMENT, PlankDockElement);
#line 25 "../lib/Items/DockElement.vala"
	switch (property_id) {
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_CONTAINER_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_object (value, plank_dock_element_get_Container (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_TEXT_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_string (value, plank_dock_element_get_Text (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_IS_ATTACHED_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_boolean (value, plank_dock_element_get_IsAttached (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_IS_VISIBLE_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_boolean (value, plank_dock_element_get_IsVisible (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_BUTTON_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_flags (value, plank_dock_element_get_Button (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_CLICKED_ANIMATION_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_enum (value, plank_dock_element_get_ClickedAnimation (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_HOVERED_ANIMATION_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_enum (value, plank_dock_element_get_HoveredAnimation (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_SCROLLED_ANIMATION_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_enum (value, plank_dock_element_get_ScrolledAnimation (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_ADD_TIME_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_int64 (value, plank_dock_element_get_AddTime (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_REMOVE_TIME_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_int64 (value, plank_dock_element_get_RemoveTime (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_CLICKED_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_int64 (value, plank_dock_element_get_LastClicked (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_HOVERED_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_int64 (value, plank_dock_element_get_LastHovered (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_SCROLLED_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_int64 (value, plank_dock_element_get_LastScrolled (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_URGENT_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_int64 (value, plank_dock_element_get_LastUrgent (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_ACTIVE_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_int64 (value, plank_dock_element_get_LastActive (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_MOVE_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_int64 (value, plank_dock_element_get_LastMove (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_VALID_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		g_value_set_int64 (value, plank_dock_element_get_LastValid (self));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 2028 "DockElement.c"
		default:
#line 25 "../lib/Items/DockElement.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 2034 "DockElement.c"
	}
}

static void
_vala_plank_dock_element_set_property (GObject * object,
                                       guint property_id,
                                       const GValue * value,
                                       GParamSpec * pspec)
{
	PlankDockElement * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_DOCK_ELEMENT, PlankDockElement);
#line 25 "../lib/Items/DockElement.vala"
	switch (property_id) {
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_CONTAINER_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_Container (self, g_value_get_object (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_TEXT_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_Text (self, g_value_get_string (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_IS_ATTACHED_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_IsAttached (self, g_value_get_boolean (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_IS_VISIBLE_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_IsVisible (self, g_value_get_boolean (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_BUTTON_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_Button (self, g_value_get_flags (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_CLICKED_ANIMATION_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_ClickedAnimation (self, g_value_get_enum (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_HOVERED_ANIMATION_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_HoveredAnimation (self, g_value_get_enum (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_SCROLLED_ANIMATION_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_ScrolledAnimation (self, g_value_get_enum (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_ADD_TIME_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_AddTime (self, g_value_get_int64 (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_REMOVE_TIME_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_RemoveTime (self, g_value_get_int64 (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_CLICKED_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_LastClicked (self, g_value_get_int64 (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_HOVERED_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_LastHovered (self, g_value_get_int64 (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_SCROLLED_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_LastScrolled (self, g_value_get_int64 (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_URGENT_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_LastUrgent (self, g_value_get_int64 (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_ACTIVE_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_LastActive (self, g_value_get_int64 (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_MOVE_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_LastMove (self, g_value_get_int64 (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 25 "../lib/Items/DockElement.vala"
		case PLANK_DOCK_ELEMENT_LAST_VALID_PROPERTY:
#line 25 "../lib/Items/DockElement.vala"
		plank_dock_element_set_LastValid (self, g_value_get_int64 (value));
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 2150 "DockElement.c"
		default:
#line 25 "../lib/Items/DockElement.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 25 "../lib/Items/DockElement.vala"
		break;
#line 2156 "DockElement.c"
	}
}

