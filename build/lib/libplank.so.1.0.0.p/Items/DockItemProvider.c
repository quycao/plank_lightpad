/* DockItemProvider.c generated by valac 0.48.17, the Vala compiler
 * generated from DockItemProvider.vala, do not modify */

/**/
/*  Copyright (C) 2014 Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <gdk/gdk.h>
#include <glib.h>
#include <gee.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>

#define PLANK_TYPE_DOCK_ELEMENT (plank_dock_element_get_type ())
#define PLANK_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElement))
#define PLANK_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))
#define PLANK_IS_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_IS_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_DOCK_ELEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))

typedef struct _PlankDockElement PlankDockElement;
typedef struct _PlankDockElementClass PlankDockElementClass;
typedef struct _PlankDockElementPrivate PlankDockElementPrivate;
typedef enum  {
	PLANK_POPUP_BUTTON_NONE = 1 << 0,
	PLANK_POPUP_BUTTON_LEFT = 1 << 1,
	PLANK_POPUP_BUTTON_MIDDLE = 1 << 2,
	PLANK_POPUP_BUTTON_RIGHT = 1 << 3
} PlankPopupButton;

#define PLANK_TYPE_POPUP_BUTTON (plank_popup_button_get_type ())
typedef enum  {
	PLANK_ANIMATION_TYPE_NONE,
	PLANK_ANIMATION_TYPE_BOUNCE,
	PLANK_ANIMATION_TYPE_DARKEN,
	PLANK_ANIMATION_TYPE_LIGHTEN
} PlankAnimationType;

#define PLANK_TYPE_ANIMATION_TYPE (plank_animation_type_get_type ())

#define PLANK_TYPE_DOCK_CONTAINER (plank_dock_container_get_type ())
#define PLANK_DOCK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainer))
#define PLANK_DOCK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainerClass))
#define PLANK_IS_DOCK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_CONTAINER))
#define PLANK_IS_DOCK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_CONTAINER))
#define PLANK_DOCK_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainerClass))

typedef struct _PlankDockContainer PlankDockContainer;
typedef struct _PlankDockContainerClass PlankDockContainerClass;
typedef struct _PlankDockContainerPrivate PlankDockContainerPrivate;

#define PLANK_TYPE_DOCK_ITEM_PROVIDER (plank_dock_item_provider_get_type ())
#define PLANK_DOCK_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ITEM_PROVIDER, PlankDockItemProvider))
#define PLANK_DOCK_ITEM_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ITEM_PROVIDER, PlankDockItemProviderClass))
#define PLANK_IS_DOCK_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ITEM_PROVIDER))
#define PLANK_IS_DOCK_ITEM_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ITEM_PROVIDER))
#define PLANK_DOCK_ITEM_PROVIDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ITEM_PROVIDER, PlankDockItemProviderClass))

typedef struct _PlankDockItemProvider PlankDockItemProvider;
typedef struct _PlankDockItemProviderClass PlankDockItemProviderClass;
typedef struct _PlankDockItemProviderPrivate PlankDockItemProviderPrivate;

#define PLANK_TYPE_DOCK_ITEM (plank_dock_item_get_type ())
#define PLANK_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ITEM, PlankDockItem))
#define PLANK_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ITEM, PlankDockItemClass))
#define PLANK_IS_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ITEM))
#define PLANK_IS_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ITEM))
#define PLANK_DOCK_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ITEM, PlankDockItemClass))

typedef struct _PlankDockItem PlankDockItem;
typedef struct _PlankDockItemClass PlankDockItemClass;
enum  {
	PLANK_DOCK_ITEM_PROVIDER_0_PROPERTY,
	PLANK_DOCK_ITEM_PROVIDER_NUM_PROPERTIES
};
static GParamSpec* plank_dock_item_provider_properties[PLANK_DOCK_ITEM_PROVIDER_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define PLANK_TYPE_DOCK_CONTROLLER (plank_dock_controller_get_type ())
#define PLANK_DOCK_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_CONTROLLER, PlankDockController))
#define PLANK_DOCK_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_CONTROLLER, PlankDockControllerClass))
#define PLANK_IS_DOCK_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_CONTROLLER))
#define PLANK_IS_DOCK_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_CONTROLLER))
#define PLANK_DOCK_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_CONTROLLER, PlankDockControllerClass))

typedef struct _PlankDockController PlankDockController;
typedef struct _PlankDockControllerClass PlankDockControllerClass;

#define PLANK_TYPE_COMPOSITED_WINDOW (plank_composited_window_get_type ())
#define PLANK_COMPOSITED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_COMPOSITED_WINDOW, PlankCompositedWindow))
#define PLANK_COMPOSITED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_COMPOSITED_WINDOW, PlankCompositedWindowClass))
#define PLANK_IS_COMPOSITED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_COMPOSITED_WINDOW))
#define PLANK_IS_COMPOSITED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_COMPOSITED_WINDOW))
#define PLANK_COMPOSITED_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_COMPOSITED_WINDOW, PlankCompositedWindowClass))

typedef struct _PlankCompositedWindow PlankCompositedWindow;
typedef struct _PlankCompositedWindowClass PlankCompositedWindowClass;

#define PLANK_TYPE_DOCK_WINDOW (plank_dock_window_get_type ())
#define PLANK_DOCK_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_WINDOW, PlankDockWindow))
#define PLANK_DOCK_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_WINDOW, PlankDockWindowClass))
#define PLANK_IS_DOCK_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_WINDOW))
#define PLANK_IS_DOCK_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_WINDOW))
#define PLANK_DOCK_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_WINDOW, PlankDockWindowClass))

typedef struct _PlankDockWindow PlankDockWindow;
typedef struct _PlankDockWindowClass PlankDockWindowClass;

#define PLANK_TYPE_POSITION_MANAGER (plank_position_manager_get_type ())
#define PLANK_POSITION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_POSITION_MANAGER, PlankPositionManager))
#define PLANK_POSITION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_POSITION_MANAGER, PlankPositionManagerClass))
#define PLANK_IS_POSITION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_POSITION_MANAGER))
#define PLANK_IS_POSITION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_POSITION_MANAGER))
#define PLANK_POSITION_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_POSITION_MANAGER, PlankPositionManagerClass))

typedef struct _PlankPositionManager PlankPositionManager;
typedef struct _PlankPositionManagerClass PlankPositionManagerClass;

struct _PlankDockElement {
	GObject parent_instance;
	PlankDockElementPrivate * priv;
};

struct _PlankDockElementClass {
	GObjectClass parent_class;
	PlankAnimationType (*on_clicked) (PlankDockElement* self, PlankPopupButton button, GdkModifierType mod, guint32 event_time);
	PlankAnimationType (*on_hovered) (PlankDockElement* self);
	PlankAnimationType (*on_scrolled) (PlankDockElement* self, GdkScrollDirection direction, GdkModifierType mod, guint32 event_time);
	GeeArrayList* (*get_menu_items) (PlankDockElement* self);
	gchar* (*get_drop_text) (PlankDockElement* self);
	gboolean (*can_be_removed) (PlankDockElement* self);
	gboolean (*can_accept_drop) (PlankDockElement* self, GeeArrayList* uris);
	gboolean (*accept_drop) (PlankDockElement* self, GeeArrayList* uris);
	gchar* (*unique_id) (PlankDockElement* self);
	void (*reset_buffers) (PlankDockElement* self);
};

struct _PlankDockContainer {
	PlankDockElement parent_instance;
	PlankDockContainerPrivate * priv;
	GeeArrayList* visible_elements;
	GeeArrayList* internal_elements;
};

struct _PlankDockContainerClass {
	PlankDockElementClass parent_class;
	void (*prepare) (PlankDockContainer* self);
	void (*update_visible_elements) (PlankDockContainer* self);
	gboolean (*move_to) (PlankDockContainer* self, PlankDockElement* move, PlankDockElement* target);
	gboolean (*replace) (PlankDockContainer* self, PlankDockElement* new_element, PlankDockElement* old_element);
	void (*connect_element) (PlankDockContainer* self, PlankDockElement* element);
	void (*disconnect_element) (PlankDockContainer* self, PlankDockElement* element);
};

struct _PlankDockItemProvider {
	PlankDockContainer parent_instance;
	PlankDockItemProviderPrivate * priv;
};

struct _PlankDockItemProviderClass {
	PlankDockContainerClass parent_class;
	gboolean (*item_exists_for_uri) (PlankDockItemProvider* self, const gchar* uri);
	PlankDockItem* (*item_for_uri) (PlankDockItemProvider* self, const gchar* uri);
	gboolean (*add_item_with_uri) (PlankDockItemProvider* self, const gchar* uri, PlankDockItem* target);
	void (*handle_item_deleted) (PlankDockItemProvider* self, PlankDockItem* item);
	gchar** (*get_dockitem_filenames) (PlankDockItemProvider* self, gint* result_length1);
};

static gpointer plank_dock_item_provider_parent_class = NULL;

GType plank_dock_element_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockElement, g_object_unref)
GType plank_popup_button_get_type (void) G_GNUC_CONST;
GType plank_animation_type_get_type (void) G_GNUC_CONST;
GType plank_dock_container_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockContainer, g_object_unref)
GType plank_dock_item_provider_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockItemProvider, g_object_unref)
GType plank_dock_item_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockItem, g_object_unref)
gboolean plank_dock_item_provider_item_exists_for_uri (PlankDockItemProvider* self,
                                                       const gchar* uri);
PlankDockItem* plank_dock_item_provider_item_for_uri (PlankDockItemProvider* self,
                                                      const gchar* uri);
gboolean plank_dock_item_provider_add_item_with_uri (PlankDockItemProvider* self,
                                                     const gchar* uri,
                                                     PlankDockItem* target);
gboolean plank_dock_element_can_accept_drop (PlankDockElement* self,
                                             GeeArrayList* uris);
gboolean plank_dock_element_accept_drop (PlankDockElement* self,
                                         GeeArrayList* uris);
void plank_dock_container_connect_element (PlankDockContainer* self,
                                           PlankDockElement* element);
void plank_dock_container_disconnect_element (PlankDockContainer* self,
                                              PlankDockElement* element);
void plank_dock_item_provider_handle_item_deleted (PlankDockItemProvider* self,
                                                   PlankDockItem* item);
gchar** plank_dock_item_provider_get_dockitem_filenames (PlankDockItemProvider* self,
                                                         gint* result_length1);
PlankDockItemProvider* plank_dock_item_provider_new (void);
PlankDockItemProvider* plank_dock_item_provider_construct (GType object_type);
static gboolean plank_dock_item_provider_real_item_exists_for_uri (PlankDockItemProvider* self,
                                                            const gchar* uri);
static PlankDockItem* plank_dock_item_provider_real_item_for_uri (PlankDockItemProvider* self,
                                                           const gchar* uri);
const gchar* plank_dock_item_get_Launcher (PlankDockItem* self);
static gboolean plank_dock_item_provider_real_add_item_with_uri (PlankDockItemProvider* self,
                                                          const gchar* uri,
                                                          PlankDockItem* target);
static gboolean plank_dock_item_provider_real_can_accept_drop (PlankDockElement* base,
                                                        GeeArrayList* uris);
static gboolean plank_dock_item_provider_real_accept_drop (PlankDockElement* base,
                                                    GeeArrayList* uris);
GType plank_dock_controller_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockController, g_object_unref)
PlankDockController* plank_dock_element_get_dock (PlankDockElement* self);
GType plank_composited_window_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankCompositedWindow, g_object_unref)
GType plank_dock_window_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockWindow, g_object_unref)
PlankDockWindow* plank_dock_controller_get_window (PlankDockController* self);
PlankDockItemProvider* plank_dock_window_get_HoveredItemProvider (PlankDockWindow* self);
GType plank_position_manager_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankPositionManager, g_object_unref)
PlankPositionManager* plank_dock_controller_get_position_manager (PlankDockController* self);
PlankDockItem* plank_position_manager_get_current_target_item (PlankPositionManager* self,
                                                               PlankDockContainer* container);
static void plank_dock_item_provider_real_connect_element (PlankDockContainer* base,
                                                    PlankDockElement* element);
static void plank_dock_item_provider_handle_item_state_changed (PlankDockItemProvider* self);
static void _plank_dock_item_provider_handle_item_state_changed_g_object_notify (GObject* _sender,
                                                                          GParamSpec* pspec,
                                                                          gpointer self);
static void _plank_dock_item_provider_handle_item_state_changed_plank_dock_element_needs_redraw (PlankDockElement* _sender,
                                                                                          gpointer self);
static void _plank_dock_item_provider_handle_item_deleted_plank_dock_item_deleted (PlankDockItem* _sender,
                                                                            gpointer self);
static void plank_dock_item_provider_real_disconnect_element (PlankDockContainer* base,
                                                       PlankDockElement* element);
static void plank_dock_item_provider_real_handle_item_deleted (PlankDockItemProvider* self,
                                                        PlankDockItem* item);
gboolean plank_dock_container_remove (PlankDockContainer* self,
                                      PlankDockElement* element);
static gchar** plank_dock_item_provider_real_get_dockitem_filenames (PlankDockItemProvider* self,
                                                              gint* result_length1);
gchar* plank_dock_item_get_DockItemFilename (PlankDockItem* self);
static GType plank_dock_item_provider_get_type_once (void);

/**
 * Creates a new container for dock items.
 */
PlankDockItemProvider*
plank_dock_item_provider_construct (GType object_type)
{
	PlankDockItemProvider * self = NULL;
#line 32 "../lib/Items/DockItemProvider.vala"
	self = (PlankDockItemProvider*) g_object_new (object_type, NULL);
#line 30 "../lib/Items/DockItemProvider.vala"
	return self;
#line 279 "DockItemProvider.c"
}

PlankDockItemProvider*
plank_dock_item_provider_new (void)
{
#line 30 "../lib/Items/DockItemProvider.vala"
	return plank_dock_item_provider_construct (PLANK_TYPE_DOCK_ITEM_PROVIDER);
#line 287 "DockItemProvider.c"
}

/**
 * Whether a dock item with the given URI exists in this provider.
 *
 * @param uri the URI to look for
 */
static gboolean
plank_dock_item_provider_real_item_exists_for_uri (PlankDockItemProvider* self,
                                                   const gchar* uri)
{
	PlankDockItem* _tmp0_;
	gboolean result = FALSE;
#line 40 "../lib/Items/DockItemProvider.vala"
	g_return_val_if_fail (uri != NULL, FALSE);
#line 42 "../lib/Items/DockItemProvider.vala"
	_tmp0_ = plank_dock_item_provider_item_for_uri (self, uri);
#line 42 "../lib/Items/DockItemProvider.vala"
	result = _tmp0_ != NULL;
#line 42 "../lib/Items/DockItemProvider.vala"
	return result;
#line 309 "DockItemProvider.c"
}

gboolean
plank_dock_item_provider_item_exists_for_uri (PlankDockItemProvider* self,
                                              const gchar* uri)
{
#line 40 "../lib/Items/DockItemProvider.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 40 "../lib/Items/DockItemProvider.vala"
	return PLANK_DOCK_ITEM_PROVIDER_GET_CLASS (self)->item_exists_for_uri (self, uri);
#line 320 "DockItemProvider.c"
}

/**
 * Get the dock item for the given URI if it exists or null.
 *
 * @param uri the URI to look for
 */
static gpointer
_g_object_ref0 (gpointer self)
{
#line 52 "../lib/Items/DockItemProvider.vala"
	return self ? g_object_ref (self) : NULL;
#line 333 "DockItemProvider.c"
}

static PlankDockItem*
plank_dock_item_provider_real_item_for_uri (PlankDockItemProvider* self,
                                            const gchar* uri)
{
	PlankDockItem* result = NULL;
#line 50 "../lib/Items/DockItemProvider.vala"
	g_return_val_if_fail (uri != NULL, NULL);
#line 343 "DockItemProvider.c"
	{
		GeeArrayList* _element_list = NULL;
		GeeArrayList* _tmp0_;
		GeeArrayList* _tmp1_;
		gint _element_size = 0;
		GeeArrayList* _tmp2_;
		gint _tmp3_;
		gint _tmp4_;
		gint _element_index = 0;
#line 52 "../lib/Items/DockItemProvider.vala"
		_tmp0_ = ((PlankDockContainer*) self)->internal_elements;
#line 52 "../lib/Items/DockItemProvider.vala"
		_tmp1_ = _g_object_ref0 (_tmp0_);
#line 52 "../lib/Items/DockItemProvider.vala"
		_element_list = _tmp1_;
#line 52 "../lib/Items/DockItemProvider.vala"
		_tmp2_ = _element_list;
#line 52 "../lib/Items/DockItemProvider.vala"
		_tmp3_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp2_);
#line 52 "../lib/Items/DockItemProvider.vala"
		_tmp4_ = _tmp3_;
#line 52 "../lib/Items/DockItemProvider.vala"
		_element_size = _tmp4_;
#line 52 "../lib/Items/DockItemProvider.vala"
		_element_index = -1;
#line 52 "../lib/Items/DockItemProvider.vala"
		while (TRUE) {
#line 371 "DockItemProvider.c"
			gint _tmp5_;
			gint _tmp6_;
			PlankDockElement* element = NULL;
			GeeArrayList* _tmp7_;
			gpointer _tmp8_;
			PlankDockItem* item = NULL;
			PlankDockElement* _tmp9_;
			gboolean _tmp10_ = FALSE;
			PlankDockItem* _tmp11_;
#line 52 "../lib/Items/DockItemProvider.vala"
			_element_index = _element_index + 1;
#line 52 "../lib/Items/DockItemProvider.vala"
			_tmp5_ = _element_index;
#line 52 "../lib/Items/DockItemProvider.vala"
			_tmp6_ = _element_size;
#line 52 "../lib/Items/DockItemProvider.vala"
			if (!(_tmp5_ < _tmp6_)) {
#line 52 "../lib/Items/DockItemProvider.vala"
				break;
#line 391 "DockItemProvider.c"
			}
#line 52 "../lib/Items/DockItemProvider.vala"
			_tmp7_ = _element_list;
#line 52 "../lib/Items/DockItemProvider.vala"
			_tmp8_ = gee_abstract_list_get ((GeeAbstractList*) _tmp7_, _element_index);
#line 52 "../lib/Items/DockItemProvider.vala"
			element = (PlankDockElement*) _tmp8_;
#line 53 "../lib/Items/DockItemProvider.vala"
			_tmp9_ = element;
#line 53 "../lib/Items/DockItemProvider.vala"
			item = PLANK_IS_DOCK_ITEM (_tmp9_) ? ((PlankDockItem*) _tmp9_) : NULL;
#line 54 "../lib/Items/DockItemProvider.vala"
			_tmp11_ = item;
#line 54 "../lib/Items/DockItemProvider.vala"
			if (_tmp11_ != NULL) {
#line 407 "DockItemProvider.c"
				PlankDockItem* _tmp12_;
				const gchar* _tmp13_;
				const gchar* _tmp14_;
#line 54 "../lib/Items/DockItemProvider.vala"
				_tmp12_ = item;
#line 54 "../lib/Items/DockItemProvider.vala"
				_tmp13_ = plank_dock_item_get_Launcher (_tmp12_);
#line 54 "../lib/Items/DockItemProvider.vala"
				_tmp14_ = _tmp13_;
#line 54 "../lib/Items/DockItemProvider.vala"
				_tmp10_ = g_strcmp0 (_tmp14_, uri) == 0;
#line 419 "DockItemProvider.c"
			} else {
#line 54 "../lib/Items/DockItemProvider.vala"
				_tmp10_ = FALSE;
#line 423 "DockItemProvider.c"
			}
#line 54 "../lib/Items/DockItemProvider.vala"
			if (_tmp10_) {
#line 427 "DockItemProvider.c"
				PlankDockItem* _tmp15_;
#line 55 "../lib/Items/DockItemProvider.vala"
				_tmp15_ = item;
#line 55 "../lib/Items/DockItemProvider.vala"
				result = _tmp15_;
#line 55 "../lib/Items/DockItemProvider.vala"
				_g_object_unref0 (element);
#line 55 "../lib/Items/DockItemProvider.vala"
				_g_object_unref0 (_element_list);
#line 55 "../lib/Items/DockItemProvider.vala"
				return result;
#line 439 "DockItemProvider.c"
			}
#line 52 "../lib/Items/DockItemProvider.vala"
			_g_object_unref0 (element);
#line 443 "DockItemProvider.c"
		}
#line 52 "../lib/Items/DockItemProvider.vala"
		_g_object_unref0 (_element_list);
#line 447 "DockItemProvider.c"
	}
#line 58 "../lib/Items/DockItemProvider.vala"
	result = NULL;
#line 58 "../lib/Items/DockItemProvider.vala"
	return result;
#line 453 "DockItemProvider.c"
}

PlankDockItem*
plank_dock_item_provider_item_for_uri (PlankDockItemProvider* self,
                                       const gchar* uri)
{
#line 50 "../lib/Items/DockItemProvider.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 50 "../lib/Items/DockItemProvider.vala"
	return PLANK_DOCK_ITEM_PROVIDER_GET_CLASS (self)->item_for_uri (self, uri);
#line 464 "DockItemProvider.c"
}

/**
 * Adds a dock item with the given URI to the collection.
 *
 * @param uri the URI to add a dock item for
 * @param target an existing item where to put this new one at
 * @return whether adding the URI was successful
 */
static gboolean
plank_dock_item_provider_real_add_item_with_uri (PlankDockItemProvider* self,
                                                 const gchar* uri,
                                                 PlankDockItem* target)
{
	gboolean result = FALSE;
#line 68 "../lib/Items/DockItemProvider.vala"
	g_return_val_if_fail (uri != NULL, FALSE);
#line 70 "../lib/Items/DockItemProvider.vala"
	g_warning ("DockItemProvider.vala:70: Not implemented by default");
#line 72 "../lib/Items/DockItemProvider.vala"
	result = FALSE;
#line 72 "../lib/Items/DockItemProvider.vala"
	return result;
#line 488 "DockItemProvider.c"
}

gboolean
plank_dock_item_provider_add_item_with_uri (PlankDockItemProvider* self,
                                            const gchar* uri,
                                            PlankDockItem* target)
{
#line 68 "../lib/Items/DockItemProvider.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 68 "../lib/Items/DockItemProvider.vala"
	return PLANK_DOCK_ITEM_PROVIDER_GET_CLASS (self)->add_item_with_uri (self, uri, target);
#line 500 "DockItemProvider.c"
}

static gboolean
plank_dock_item_provider_real_can_accept_drop (PlankDockElement* base,
                                               GeeArrayList* uris)
{
	PlankDockItemProvider * self;
	gboolean result = FALSE;
#line 75 "../lib/Items/DockItemProvider.vala"
	self = (PlankDockItemProvider*) base;
#line 75 "../lib/Items/DockItemProvider.vala"
	g_return_val_if_fail (uris != NULL, FALSE);
#line 513 "DockItemProvider.c"
	{
		GeeArrayList* _uri_list = NULL;
		GeeArrayList* _tmp0_;
		gint _uri_size = 0;
		GeeArrayList* _tmp1_;
		gint _tmp2_;
		gint _tmp3_;
		gint _uri_index = 0;
#line 77 "../lib/Items/DockItemProvider.vala"
		_tmp0_ = _g_object_ref0 (uris);
#line 77 "../lib/Items/DockItemProvider.vala"
		_uri_list = _tmp0_;
#line 77 "../lib/Items/DockItemProvider.vala"
		_tmp1_ = _uri_list;
#line 77 "../lib/Items/DockItemProvider.vala"
		_tmp2_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp1_);
#line 77 "../lib/Items/DockItemProvider.vala"
		_tmp3_ = _tmp2_;
#line 77 "../lib/Items/DockItemProvider.vala"
		_uri_size = _tmp3_;
#line 77 "../lib/Items/DockItemProvider.vala"
		_uri_index = -1;
#line 77 "../lib/Items/DockItemProvider.vala"
		while (TRUE) {
#line 538 "DockItemProvider.c"
			gint _tmp4_;
			gint _tmp5_;
			gchar* uri = NULL;
			GeeArrayList* _tmp6_;
			gpointer _tmp7_;
			const gchar* _tmp8_;
#line 77 "../lib/Items/DockItemProvider.vala"
			_uri_index = _uri_index + 1;
#line 77 "../lib/Items/DockItemProvider.vala"
			_tmp4_ = _uri_index;
#line 77 "../lib/Items/DockItemProvider.vala"
			_tmp5_ = _uri_size;
#line 77 "../lib/Items/DockItemProvider.vala"
			if (!(_tmp4_ < _tmp5_)) {
#line 77 "../lib/Items/DockItemProvider.vala"
				break;
#line 555 "DockItemProvider.c"
			}
#line 77 "../lib/Items/DockItemProvider.vala"
			_tmp6_ = _uri_list;
#line 77 "../lib/Items/DockItemProvider.vala"
			_tmp7_ = gee_abstract_list_get ((GeeAbstractList*) _tmp6_, _uri_index);
#line 77 "../lib/Items/DockItemProvider.vala"
			uri = (gchar*) _tmp7_;
#line 78 "../lib/Items/DockItemProvider.vala"
			_tmp8_ = uri;
#line 78 "../lib/Items/DockItemProvider.vala"
			if (!plank_dock_item_provider_item_exists_for_uri (self, _tmp8_)) {
#line 79 "../lib/Items/DockItemProvider.vala"
				result = TRUE;
#line 79 "../lib/Items/DockItemProvider.vala"
				_g_free0 (uri);
#line 79 "../lib/Items/DockItemProvider.vala"
				_g_object_unref0 (_uri_list);
#line 79 "../lib/Items/DockItemProvider.vala"
				return result;
#line 575 "DockItemProvider.c"
			}
#line 77 "../lib/Items/DockItemProvider.vala"
			_g_free0 (uri);
#line 579 "DockItemProvider.c"
		}
#line 77 "../lib/Items/DockItemProvider.vala"
		_g_object_unref0 (_uri_list);
#line 583 "DockItemProvider.c"
	}
#line 81 "../lib/Items/DockItemProvider.vala"
	result = FALSE;
#line 81 "../lib/Items/DockItemProvider.vala"
	return result;
#line 589 "DockItemProvider.c"
}

static gboolean
plank_dock_item_provider_real_accept_drop (PlankDockElement* base,
                                           GeeArrayList* uris)
{
	PlankDockItemProvider * self;
	gboolean _result_ = FALSE;
	PlankDockItem* target_item = NULL;
	PlankDockController* controller = NULL;
	PlankDockController* _tmp0_;
	gboolean _tmp1_ = FALSE;
	PlankDockController* _tmp2_;
	gboolean result = FALSE;
#line 84 "../lib/Items/DockItemProvider.vala"
	self = (PlankDockItemProvider*) base;
#line 84 "../lib/Items/DockItemProvider.vala"
	g_return_val_if_fail (uris != NULL, FALSE);
#line 86 "../lib/Items/DockItemProvider.vala"
	_result_ = FALSE;
#line 88 "../lib/Items/DockItemProvider.vala"
	target_item = NULL;
#line 89 "../lib/Items/DockItemProvider.vala"
	_tmp0_ = plank_dock_element_get_dock ((PlankDockElement*) self);
#line 89 "../lib/Items/DockItemProvider.vala"
	controller = _tmp0_;
#line 90 "../lib/Items/DockItemProvider.vala"
	_tmp2_ = controller;
#line 90 "../lib/Items/DockItemProvider.vala"
	if (_tmp2_ != NULL) {
#line 620 "DockItemProvider.c"
		PlankDockController* _tmp3_;
		PlankDockWindow* _tmp4_;
		PlankDockWindow* _tmp5_;
		PlankDockItemProvider* _tmp6_;
		PlankDockItemProvider* _tmp7_;
#line 90 "../lib/Items/DockItemProvider.vala"
		_tmp3_ = controller;
#line 90 "../lib/Items/DockItemProvider.vala"
		_tmp4_ = plank_dock_controller_get_window (_tmp3_);
#line 90 "../lib/Items/DockItemProvider.vala"
		_tmp5_ = _tmp4_;
#line 90 "../lib/Items/DockItemProvider.vala"
		_tmp6_ = plank_dock_window_get_HoveredItemProvider (_tmp5_);
#line 90 "../lib/Items/DockItemProvider.vala"
		_tmp7_ = _tmp6_;
#line 90 "../lib/Items/DockItemProvider.vala"
		_tmp1_ = _tmp7_ == self;
#line 638 "DockItemProvider.c"
	} else {
#line 90 "../lib/Items/DockItemProvider.vala"
		_tmp1_ = FALSE;
#line 642 "DockItemProvider.c"
	}
#line 90 "../lib/Items/DockItemProvider.vala"
	if (_tmp1_) {
#line 646 "DockItemProvider.c"
		PlankDockController* _tmp8_;
		PlankPositionManager* _tmp9_;
		PlankPositionManager* _tmp10_;
		PlankDockItem* _tmp11_;
#line 91 "../lib/Items/DockItemProvider.vala"
		_tmp8_ = controller;
#line 91 "../lib/Items/DockItemProvider.vala"
		_tmp9_ = plank_dock_controller_get_position_manager (_tmp8_);
#line 91 "../lib/Items/DockItemProvider.vala"
		_tmp10_ = _tmp9_;
#line 91 "../lib/Items/DockItemProvider.vala"
		_tmp11_ = plank_position_manager_get_current_target_item (_tmp10_, (PlankDockContainer*) self);
#line 91 "../lib/Items/DockItemProvider.vala"
		target_item = _tmp11_;
#line 661 "DockItemProvider.c"
	}
	{
		GeeArrayList* _uri_list = NULL;
		GeeArrayList* _tmp12_;
		gint _uri_size = 0;
		GeeArrayList* _tmp13_;
		gint _tmp14_;
		gint _tmp15_;
		gint _uri_index = 0;
#line 94 "../lib/Items/DockItemProvider.vala"
		_tmp12_ = _g_object_ref0 (uris);
#line 94 "../lib/Items/DockItemProvider.vala"
		_uri_list = _tmp12_;
#line 94 "../lib/Items/DockItemProvider.vala"
		_tmp13_ = _uri_list;
#line 94 "../lib/Items/DockItemProvider.vala"
		_tmp14_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp13_);
#line 94 "../lib/Items/DockItemProvider.vala"
		_tmp15_ = _tmp14_;
#line 94 "../lib/Items/DockItemProvider.vala"
		_uri_size = _tmp15_;
#line 94 "../lib/Items/DockItemProvider.vala"
		_uri_index = -1;
#line 94 "../lib/Items/DockItemProvider.vala"
		while (TRUE) {
#line 687 "DockItemProvider.c"
			gint _tmp16_;
			gint _tmp17_;
			gchar* uri = NULL;
			GeeArrayList* _tmp18_;
			gpointer _tmp19_;
			const gchar* _tmp20_;
#line 94 "../lib/Items/DockItemProvider.vala"
			_uri_index = _uri_index + 1;
#line 94 "../lib/Items/DockItemProvider.vala"
			_tmp16_ = _uri_index;
#line 94 "../lib/Items/DockItemProvider.vala"
			_tmp17_ = _uri_size;
#line 94 "../lib/Items/DockItemProvider.vala"
			if (!(_tmp16_ < _tmp17_)) {
#line 94 "../lib/Items/DockItemProvider.vala"
				break;
#line 704 "DockItemProvider.c"
			}
#line 94 "../lib/Items/DockItemProvider.vala"
			_tmp18_ = _uri_list;
#line 94 "../lib/Items/DockItemProvider.vala"
			_tmp19_ = gee_abstract_list_get ((GeeAbstractList*) _tmp18_, _uri_index);
#line 94 "../lib/Items/DockItemProvider.vala"
			uri = (gchar*) _tmp19_;
#line 95 "../lib/Items/DockItemProvider.vala"
			_tmp20_ = uri;
#line 95 "../lib/Items/DockItemProvider.vala"
			if (!plank_dock_item_provider_item_exists_for_uri (self, _tmp20_)) {
#line 716 "DockItemProvider.c"
				const gchar* _tmp21_;
				PlankDockItem* _tmp22_;
#line 96 "../lib/Items/DockItemProvider.vala"
				_tmp21_ = uri;
#line 96 "../lib/Items/DockItemProvider.vala"
				_tmp22_ = target_item;
#line 96 "../lib/Items/DockItemProvider.vala"
				plank_dock_item_provider_add_item_with_uri (self, _tmp21_, _tmp22_);
#line 97 "../lib/Items/DockItemProvider.vala"
				_result_ = TRUE;
#line 727 "DockItemProvider.c"
			}
#line 94 "../lib/Items/DockItemProvider.vala"
			_g_free0 (uri);
#line 731 "DockItemProvider.c"
		}
#line 94 "../lib/Items/DockItemProvider.vala"
		_g_object_unref0 (_uri_list);
#line 735 "DockItemProvider.c"
	}
#line 101 "../lib/Items/DockItemProvider.vala"
	result = _result_;
#line 101 "../lib/Items/DockItemProvider.vala"
	return result;
#line 741 "DockItemProvider.c"
}

static void
_plank_dock_item_provider_handle_item_state_changed_g_object_notify (GObject* _sender,
                                                                     GParamSpec* pspec,
                                                                     gpointer self)
{
#line 110 "../lib/Items/DockItemProvider.vala"
	plank_dock_item_provider_handle_item_state_changed ((PlankDockItemProvider*) self);
#line 751 "DockItemProvider.c"
}

static void
_plank_dock_item_provider_handle_item_state_changed_plank_dock_element_needs_redraw (PlankDockElement* _sender,
                                                                                     gpointer self)
{
#line 113 "../lib/Items/DockItemProvider.vala"
	plank_dock_item_provider_handle_item_state_changed ((PlankDockItemProvider*) self);
#line 760 "DockItemProvider.c"
}

static void
_plank_dock_item_provider_handle_item_deleted_plank_dock_item_deleted (PlankDockItem* _sender,
                                                                       gpointer self)
{
#line 114 "../lib/Items/DockItemProvider.vala"
	plank_dock_item_provider_handle_item_deleted ((PlankDockItemProvider*) self, _sender);
#line 769 "DockItemProvider.c"
}

static void
plank_dock_item_provider_real_connect_element (PlankDockContainer* base,
                                               PlankDockElement* element)
{
	PlankDockItemProvider * self;
	PlankDockItem* item = NULL;
	PlankDockItem* _tmp0_;
	PlankDockItem* _tmp1_;
	PlankDockItem* _tmp2_;
	PlankDockItem* _tmp3_;
	PlankDockItem* _tmp4_;
	PlankDockItem* _tmp5_;
#line 104 "../lib/Items/DockItemProvider.vala"
	self = (PlankDockItemProvider*) base;
#line 104 "../lib/Items/DockItemProvider.vala"
	g_return_if_fail (element != NULL);
#line 106 "../lib/Items/DockItemProvider.vala"
	item = PLANK_IS_DOCK_ITEM (element) ? ((PlankDockItem*) element) : NULL;
#line 107 "../lib/Items/DockItemProvider.vala"
	_tmp0_ = item;
#line 107 "../lib/Items/DockItemProvider.vala"
	if (_tmp0_ == NULL) {
#line 108 "../lib/Items/DockItemProvider.vala"
		return;
#line 796 "DockItemProvider.c"
	}
#line 110 "../lib/Items/DockItemProvider.vala"
	_tmp1_ = item;
#line 110 "../lib/Items/DockItemProvider.vala"
	g_signal_connect_object ((GObject*) _tmp1_, "notify::Indicator", (GCallback) _plank_dock_item_provider_handle_item_state_changed_g_object_notify, self, 0);
#line 111 "../lib/Items/DockItemProvider.vala"
	_tmp2_ = item;
#line 111 "../lib/Items/DockItemProvider.vala"
	g_signal_connect_object ((GObject*) _tmp2_, "notify::State", (GCallback) _plank_dock_item_provider_handle_item_state_changed_g_object_notify, self, 0);
#line 112 "../lib/Items/DockItemProvider.vala"
	_tmp3_ = item;
#line 112 "../lib/Items/DockItemProvider.vala"
	g_signal_connect_object ((GObject*) _tmp3_, "notify::LastClicked", (GCallback) _plank_dock_item_provider_handle_item_state_changed_g_object_notify, self, 0);
#line 113 "../lib/Items/DockItemProvider.vala"
	_tmp4_ = item;
#line 113 "../lib/Items/DockItemProvider.vala"
	g_signal_connect_object ((PlankDockElement*) _tmp4_, "needs-redraw", (GCallback) _plank_dock_item_provider_handle_item_state_changed_plank_dock_element_needs_redraw, self, 0);
#line 114 "../lib/Items/DockItemProvider.vala"
	_tmp5_ = item;
#line 114 "../lib/Items/DockItemProvider.vala"
	g_signal_connect_object (_tmp5_, "deleted", (GCallback) _plank_dock_item_provider_handle_item_deleted_plank_dock_item_deleted, self, 0);
#line 818 "DockItemProvider.c"
}

static void
plank_dock_item_provider_real_disconnect_element (PlankDockContainer* base,
                                                  PlankDockElement* element)
{
	PlankDockItemProvider * self;
	PlankDockItem* item = NULL;
	PlankDockItem* _tmp0_;
	PlankDockItem* _tmp1_;
	guint _tmp2_;
	GQuark _tmp3_;
	PlankDockItem* _tmp4_;
	guint _tmp5_;
	GQuark _tmp6_;
	PlankDockItem* _tmp7_;
	guint _tmp8_;
	GQuark _tmp9_;
	PlankDockItem* _tmp10_;
	guint _tmp11_;
	PlankDockItem* _tmp12_;
	guint _tmp13_;
#line 117 "../lib/Items/DockItemProvider.vala"
	self = (PlankDockItemProvider*) base;
#line 117 "../lib/Items/DockItemProvider.vala"
	g_return_if_fail (element != NULL);
#line 119 "../lib/Items/DockItemProvider.vala"
	item = PLANK_IS_DOCK_ITEM (element) ? ((PlankDockItem*) element) : NULL;
#line 120 "../lib/Items/DockItemProvider.vala"
	_tmp0_ = item;
#line 120 "../lib/Items/DockItemProvider.vala"
	if (_tmp0_ == NULL) {
#line 121 "../lib/Items/DockItemProvider.vala"
		return;
#line 853 "DockItemProvider.c"
	}
#line 123 "../lib/Items/DockItemProvider.vala"
	_tmp1_ = item;
#line 123 "../lib/Items/DockItemProvider.vala"
	g_signal_parse_name ("notify::Indicator", G_TYPE_OBJECT, &_tmp2_, &_tmp3_, TRUE);
#line 123 "../lib/Items/DockItemProvider.vala"
	g_signal_handlers_disconnect_matched ((GObject*) _tmp1_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp2_, _tmp3_, NULL, (GCallback) _plank_dock_item_provider_handle_item_state_changed_g_object_notify, self);
#line 124 "../lib/Items/DockItemProvider.vala"
	_tmp4_ = item;
#line 124 "../lib/Items/DockItemProvider.vala"
	g_signal_parse_name ("notify::State", G_TYPE_OBJECT, &_tmp5_, &_tmp6_, TRUE);
#line 124 "../lib/Items/DockItemProvider.vala"
	g_signal_handlers_disconnect_matched ((GObject*) _tmp4_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp5_, _tmp6_, NULL, (GCallback) _plank_dock_item_provider_handle_item_state_changed_g_object_notify, self);
#line 125 "../lib/Items/DockItemProvider.vala"
	_tmp7_ = item;
#line 125 "../lib/Items/DockItemProvider.vala"
	g_signal_parse_name ("notify::LastClicked", G_TYPE_OBJECT, &_tmp8_, &_tmp9_, TRUE);
#line 125 "../lib/Items/DockItemProvider.vala"
	g_signal_handlers_disconnect_matched ((GObject*) _tmp7_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp8_, _tmp9_, NULL, (GCallback) _plank_dock_item_provider_handle_item_state_changed_g_object_notify, self);
#line 126 "../lib/Items/DockItemProvider.vala"
	_tmp10_ = item;
#line 126 "../lib/Items/DockItemProvider.vala"
	g_signal_parse_name ("needs-redraw", PLANK_TYPE_DOCK_ELEMENT, &_tmp11_, NULL, FALSE);
#line 126 "../lib/Items/DockItemProvider.vala"
	g_signal_handlers_disconnect_matched ((PlankDockElement*) _tmp10_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp11_, 0, NULL, (GCallback) _plank_dock_item_provider_handle_item_state_changed_plank_dock_element_needs_redraw, self);
#line 127 "../lib/Items/DockItemProvider.vala"
	_tmp12_ = item;
#line 127 "../lib/Items/DockItemProvider.vala"
	g_signal_parse_name ("deleted", PLANK_TYPE_DOCK_ITEM, &_tmp13_, NULL, FALSE);
#line 127 "../lib/Items/DockItemProvider.vala"
	g_signal_handlers_disconnect_matched (_tmp12_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp13_, 0, NULL, (GCallback) _plank_dock_item_provider_handle_item_deleted_plank_dock_item_deleted, self);
#line 885 "DockItemProvider.c"
}

static void
plank_dock_item_provider_handle_item_state_changed (PlankDockItemProvider* self)
{
#line 130 "../lib/Items/DockItemProvider.vala"
	g_return_if_fail (self != NULL);
#line 132 "../lib/Items/DockItemProvider.vala"
	g_signal_emit_by_name ((PlankDockContainer*) self, "states-changed");
#line 895 "DockItemProvider.c"
}

static void
plank_dock_item_provider_real_handle_item_deleted (PlankDockItemProvider* self,
                                                   PlankDockItem* item)
{
#line 135 "../lib/Items/DockItemProvider.vala"
	g_return_if_fail (item != NULL);
#line 137 "../lib/Items/DockItemProvider.vala"
	plank_dock_container_remove ((PlankDockContainer*) self, (PlankDockElement*) item);
#line 906 "DockItemProvider.c"
}

void
plank_dock_item_provider_handle_item_deleted (PlankDockItemProvider* self,
                                              PlankDockItem* item)
{
#line 135 "../lib/Items/DockItemProvider.vala"
	g_return_if_fail (self != NULL);
#line 135 "../lib/Items/DockItemProvider.vala"
	PLANK_DOCK_ITEM_PROVIDER_GET_CLASS (self)->handle_item_deleted (self, item);
#line 917 "DockItemProvider.c"
}

/**
 * Get ordered array of dockitem-filenames handled by this provider
 *
 * @return an ordered array of strings containing all basenames
 */
static gchar**
plank_dock_item_provider_real_get_dockitem_filenames (PlankDockItemProvider* self,
                                                      gint* result_length1)
{
	GeeArrayList* item_list = NULL;
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp21_;
	gint _tmp22_ = 0;
	gpointer* _tmp23_;
	gchar** _tmp24_;
	gint _tmp24__length1;
	gchar** result = NULL;
#line 147 "../lib/Items/DockItemProvider.vala"
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL);
#line 147 "../lib/Items/DockItemProvider.vala"
	item_list = _tmp0_;
#line 941 "DockItemProvider.c"
	{
		GeeArrayList* _element_list = NULL;
		GeeArrayList* _tmp1_;
		GeeArrayList* _tmp2_;
		gint _element_size = 0;
		GeeArrayList* _tmp3_;
		gint _tmp4_;
		gint _tmp5_;
		gint _element_index = 0;
#line 149 "../lib/Items/DockItemProvider.vala"
		_tmp1_ = ((PlankDockContainer*) self)->internal_elements;
#line 149 "../lib/Items/DockItemProvider.vala"
		_tmp2_ = _g_object_ref0 (_tmp1_);
#line 149 "../lib/Items/DockItemProvider.vala"
		_element_list = _tmp2_;
#line 149 "../lib/Items/DockItemProvider.vala"
		_tmp3_ = _element_list;
#line 149 "../lib/Items/DockItemProvider.vala"
		_tmp4_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp3_);
#line 149 "../lib/Items/DockItemProvider.vala"
		_tmp5_ = _tmp4_;
#line 149 "../lib/Items/DockItemProvider.vala"
		_element_size = _tmp5_;
#line 149 "../lib/Items/DockItemProvider.vala"
		_element_index = -1;
#line 149 "../lib/Items/DockItemProvider.vala"
		while (TRUE) {
#line 969 "DockItemProvider.c"
			gint _tmp6_;
			gint _tmp7_;
			PlankDockElement* element = NULL;
			GeeArrayList* _tmp8_;
			gpointer _tmp9_;
			PlankDockItem* item = NULL;
			PlankDockElement* _tmp10_;
			PlankDockItem* _tmp11_;
			gchar* dock_item_filename = NULL;
			PlankDockItem* _tmp12_;
			gchar* _tmp13_;
			gchar* _tmp14_;
			const gchar* _tmp15_;
			gint _tmp16_;
			gint _tmp17_;
#line 149 "../lib/Items/DockItemProvider.vala"
			_element_index = _element_index + 1;
#line 149 "../lib/Items/DockItemProvider.vala"
			_tmp6_ = _element_index;
#line 149 "../lib/Items/DockItemProvider.vala"
			_tmp7_ = _element_size;
#line 149 "../lib/Items/DockItemProvider.vala"
			if (!(_tmp6_ < _tmp7_)) {
#line 149 "../lib/Items/DockItemProvider.vala"
				break;
#line 995 "DockItemProvider.c"
			}
#line 149 "../lib/Items/DockItemProvider.vala"
			_tmp8_ = _element_list;
#line 149 "../lib/Items/DockItemProvider.vala"
			_tmp9_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, _element_index);
#line 149 "../lib/Items/DockItemProvider.vala"
			element = (PlankDockElement*) _tmp9_;
#line 150 "../lib/Items/DockItemProvider.vala"
			_tmp10_ = element;
#line 150 "../lib/Items/DockItemProvider.vala"
			item = PLANK_IS_DOCK_ITEM (_tmp10_) ? ((PlankDockItem*) _tmp10_) : NULL;
#line 151 "../lib/Items/DockItemProvider.vala"
			_tmp11_ = item;
#line 151 "../lib/Items/DockItemProvider.vala"
			if (_tmp11_ == NULL) {
#line 152 "../lib/Items/DockItemProvider.vala"
				_g_object_unref0 (element);
#line 152 "../lib/Items/DockItemProvider.vala"
				continue;
#line 1015 "DockItemProvider.c"
			}
#line 154 "../lib/Items/DockItemProvider.vala"
			_tmp12_ = item;
#line 154 "../lib/Items/DockItemProvider.vala"
			_tmp13_ = plank_dock_item_get_DockItemFilename (_tmp12_);
#line 154 "../lib/Items/DockItemProvider.vala"
			_tmp14_ = _tmp13_;
#line 154 "../lib/Items/DockItemProvider.vala"
			dock_item_filename = _tmp14_;
#line 155 "../lib/Items/DockItemProvider.vala"
			_tmp15_ = dock_item_filename;
#line 155 "../lib/Items/DockItemProvider.vala"
			_tmp16_ = strlen (_tmp15_);
#line 155 "../lib/Items/DockItemProvider.vala"
			_tmp17_ = _tmp16_;
#line 155 "../lib/Items/DockItemProvider.vala"
			if (_tmp17_ > 0) {
#line 1033 "DockItemProvider.c"
				GeeArrayList* _tmp18_;
				gchar* _tmp19_;
				gchar* _tmp20_;
#line 156 "../lib/Items/DockItemProvider.vala"
				_tmp18_ = item_list;
#line 156 "../lib/Items/DockItemProvider.vala"
				_tmp19_ = dock_item_filename;
#line 156 "../lib/Items/DockItemProvider.vala"
				dock_item_filename = NULL;
#line 156 "../lib/Items/DockItemProvider.vala"
				_tmp20_ = _tmp19_;
#line 156 "../lib/Items/DockItemProvider.vala"
				gee_abstract_collection_add ((GeeAbstractCollection*) _tmp18_, _tmp20_);
#line 156 "../lib/Items/DockItemProvider.vala"
				_g_free0 (_tmp20_);
#line 1049 "DockItemProvider.c"
			}
#line 149 "../lib/Items/DockItemProvider.vala"
			_g_free0 (dock_item_filename);
#line 149 "../lib/Items/DockItemProvider.vala"
			_g_object_unref0 (element);
#line 1055 "DockItemProvider.c"
		}
#line 149 "../lib/Items/DockItemProvider.vala"
		_g_object_unref0 (_element_list);
#line 1059 "DockItemProvider.c"
	}
#line 159 "../lib/Items/DockItemProvider.vala"
	_tmp21_ = item_list;
#line 159 "../lib/Items/DockItemProvider.vala"
	_tmp23_ = gee_collection_to_array ((GeeCollection*) _tmp21_, &_tmp22_);
#line 159 "../lib/Items/DockItemProvider.vala"
	_tmp24_ = _tmp23_;
#line 159 "../lib/Items/DockItemProvider.vala"
	_tmp24__length1 = _tmp22_;
#line 159 "../lib/Items/DockItemProvider.vala"
	if (result_length1) {
#line 159 "../lib/Items/DockItemProvider.vala"
		*result_length1 = _tmp24__length1;
#line 1073 "DockItemProvider.c"
	}
#line 159 "../lib/Items/DockItemProvider.vala"
	result = _tmp24_;
#line 159 "../lib/Items/DockItemProvider.vala"
	_g_object_unref0 (item_list);
#line 159 "../lib/Items/DockItemProvider.vala"
	return result;
#line 1081 "DockItemProvider.c"
}

gchar**
plank_dock_item_provider_get_dockitem_filenames (PlankDockItemProvider* self,
                                                 gint* result_length1)
{
#line 145 "../lib/Items/DockItemProvider.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 145 "../lib/Items/DockItemProvider.vala"
	return PLANK_DOCK_ITEM_PROVIDER_GET_CLASS (self)->get_dockitem_filenames (self, result_length1);
#line 1092 "DockItemProvider.c"
}

static void
plank_dock_item_provider_class_init (PlankDockItemProviderClass * klass,
                                     gpointer klass_data)
{
#line 25 "../lib/Items/DockItemProvider.vala"
	plank_dock_item_provider_parent_class = g_type_class_peek_parent (klass);
#line 25 "../lib/Items/DockItemProvider.vala"
	((PlankDockItemProviderClass *) klass)->item_exists_for_uri = (gboolean (*) (PlankDockItemProvider*, const gchar*)) plank_dock_item_provider_real_item_exists_for_uri;
#line 25 "../lib/Items/DockItemProvider.vala"
	((PlankDockItemProviderClass *) klass)->item_for_uri = (PlankDockItem* (*) (PlankDockItemProvider*, const gchar*)) plank_dock_item_provider_real_item_for_uri;
#line 25 "../lib/Items/DockItemProvider.vala"
	((PlankDockItemProviderClass *) klass)->add_item_with_uri = (gboolean (*) (PlankDockItemProvider*, const gchar*, PlankDockItem*)) plank_dock_item_provider_real_add_item_with_uri;
#line 25 "../lib/Items/DockItemProvider.vala"
	((PlankDockElementClass *) klass)->can_accept_drop = (gboolean (*) (PlankDockElement*, GeeArrayList*)) plank_dock_item_provider_real_can_accept_drop;
#line 25 "../lib/Items/DockItemProvider.vala"
	((PlankDockElementClass *) klass)->accept_drop = (gboolean (*) (PlankDockElement*, GeeArrayList*)) plank_dock_item_provider_real_accept_drop;
#line 25 "../lib/Items/DockItemProvider.vala"
	((PlankDockContainerClass *) klass)->connect_element = (void (*) (PlankDockContainer*, PlankDockElement*)) plank_dock_item_provider_real_connect_element;
#line 25 "../lib/Items/DockItemProvider.vala"
	((PlankDockContainerClass *) klass)->disconnect_element = (void (*) (PlankDockContainer*, PlankDockElement*)) plank_dock_item_provider_real_disconnect_element;
#line 25 "../lib/Items/DockItemProvider.vala"
	((PlankDockItemProviderClass *) klass)->handle_item_deleted = (void (*) (PlankDockItemProvider*, PlankDockItem*)) plank_dock_item_provider_real_handle_item_deleted;
#line 25 "../lib/Items/DockItemProvider.vala"
	((PlankDockItemProviderClass *) klass)->get_dockitem_filenames = (gchar** (*) (PlankDockItemProvider*, gint*)) plank_dock_item_provider_real_get_dockitem_filenames;
#line 1119 "DockItemProvider.c"
}

static void
plank_dock_item_provider_instance_init (PlankDockItemProvider * self,
                                        gpointer klass)
{
}

/**
 * A container and controller class for managing dock items.
 */
static GType
plank_dock_item_provider_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankDockItemProviderClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_dock_item_provider_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankDockItemProvider), 0, (GInstanceInitFunc) plank_dock_item_provider_instance_init, NULL };
	GType plank_dock_item_provider_type_id;
	plank_dock_item_provider_type_id = g_type_register_static (PLANK_TYPE_DOCK_CONTAINER, "PlankDockItemProvider", &g_define_type_info, 0);
	return plank_dock_item_provider_type_id;
}

GType
plank_dock_item_provider_get_type (void)
{
	static volatile gsize plank_dock_item_provider_type_id__volatile = 0;
	if (g_once_init_enter (&plank_dock_item_provider_type_id__volatile)) {
		GType plank_dock_item_provider_type_id;
		plank_dock_item_provider_type_id = plank_dock_item_provider_get_type_once ();
		g_once_init_leave (&plank_dock_item_provider_type_id__volatile, plank_dock_item_provider_type_id);
	}
	return plank_dock_item_provider_type_id__volatile;
}

