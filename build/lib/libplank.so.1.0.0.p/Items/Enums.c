/* Enums.c generated by valac 0.48.17, the Vala compiler
 * generated from Enums.vala, do not modify */

/**/
/*  Copyright (C) 2015 Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <gdk/gdk.h>
#include <glib.h>

typedef enum  {
	PLANK_ANIMATION_TYPE_NONE,
	PLANK_ANIMATION_TYPE_BOUNCE,
	PLANK_ANIMATION_TYPE_DARKEN,
	PLANK_ANIMATION_TYPE_LIGHTEN
} PlankAnimationType;

#define PLANK_TYPE_ANIMATION_TYPE (plank_animation_type_get_type ())
typedef enum  {
	PLANK_INDICATOR_STATE_NONE,
	PLANK_INDICATOR_STATE_SINGLE,
	PLANK_INDICATOR_STATE_SINGLE_PLUS
} PlankIndicatorState;

#define PLANK_TYPE_INDICATOR_STATE (plank_indicator_state_get_type ())
typedef enum  {
	PLANK_ITEM_STATE_NORMAL = 1 << 0,
	PLANK_ITEM_STATE_ACTIVE = 1 << 1,
	PLANK_ITEM_STATE_URGENT = 1 << 2,
	PLANK_ITEM_STATE_MOVE = 1 << 3,
	PLANK_ITEM_STATE_INVALID = 1 << 4
} PlankItemState;

#define PLANK_TYPE_ITEM_STATE (plank_item_state_get_type ())
typedef enum  {
	PLANK_POPUP_BUTTON_NONE = 1 << 0,
	PLANK_POPUP_BUTTON_LEFT = 1 << 1,
	PLANK_POPUP_BUTTON_MIDDLE = 1 << 2,
	PLANK_POPUP_BUTTON_RIGHT = 1 << 3
} PlankPopupButton;

#define PLANK_TYPE_POPUP_BUTTON (plank_popup_button_get_type ())

GType plank_animation_type_get_type (void) G_GNUC_CONST;
GType plank_indicator_state_get_type (void) G_GNUC_CONST;
GType plank_item_state_get_type (void) G_GNUC_CONST;
GType plank_popup_button_get_type (void) G_GNUC_CONST;
PlankPopupButton plank_popup_button_from_event_button (GdkEventButton* event);

/**
 * What type of animation to perform when an item is or was interacted with.
 */
static GType
plank_animation_type_get_type_once (void)
{
	static const GEnumValue values[] = {{PLANK_ANIMATION_TYPE_NONE, "PLANK_ANIMATION_TYPE_NONE", "none"}, {PLANK_ANIMATION_TYPE_BOUNCE, "PLANK_ANIMATION_TYPE_BOUNCE", "bounce"}, {PLANK_ANIMATION_TYPE_DARKEN, "PLANK_ANIMATION_TYPE_DARKEN", "darken"}, {PLANK_ANIMATION_TYPE_LIGHTEN, "PLANK_ANIMATION_TYPE_LIGHTEN", "lighten"}, {0, NULL, NULL}};
	GType plank_animation_type_type_id;
	plank_animation_type_type_id = g_enum_register_static ("PlankAnimationType", values);
	return plank_animation_type_type_id;
}

GType
plank_animation_type_get_type (void)
{
	static volatile gsize plank_animation_type_type_id__volatile = 0;
	if (g_once_init_enter (&plank_animation_type_type_id__volatile)) {
		GType plank_animation_type_type_id;
		plank_animation_type_type_id = plank_animation_type_get_type_once ();
		g_once_init_leave (&plank_animation_type_type_id__volatile, plank_animation_type_type_id);
	}
	return plank_animation_type_type_id__volatile;
}

/**
 * What item indicator to show.
 */
static GType
plank_indicator_state_get_type_once (void)
{
	static const GEnumValue values[] = {{PLANK_INDICATOR_STATE_NONE, "PLANK_INDICATOR_STATE_NONE", "none"}, {PLANK_INDICATOR_STATE_SINGLE, "PLANK_INDICATOR_STATE_SINGLE", "single"}, {PLANK_INDICATOR_STATE_SINGLE_PLUS, "PLANK_INDICATOR_STATE_SINGLE_PLUS", "single-plus"}, {0, NULL, NULL}};
	GType plank_indicator_state_type_id;
	plank_indicator_state_type_id = g_enum_register_static ("PlankIndicatorState", values);
	return plank_indicator_state_type_id;
}

GType
plank_indicator_state_get_type (void)
{
	static volatile gsize plank_indicator_state_type_id__volatile = 0;
	if (g_once_init_enter (&plank_indicator_state_type_id__volatile)) {
		GType plank_indicator_state_type_id;
		plank_indicator_state_type_id = plank_indicator_state_get_type_once ();
		g_once_init_leave (&plank_indicator_state_type_id__volatile, plank_indicator_state_type_id);
	}
	return plank_indicator_state_type_id__volatile;
}

/**
 * The current activity state of an item.  The item has several
 * states to track and can be in any combination of them.
 */
static GType
plank_item_state_get_type_once (void)
{
	static const GFlagsValue values[] = {{PLANK_ITEM_STATE_NORMAL, "PLANK_ITEM_STATE_NORMAL", "normal"}, {PLANK_ITEM_STATE_ACTIVE, "PLANK_ITEM_STATE_ACTIVE", "active"}, {PLANK_ITEM_STATE_URGENT, "PLANK_ITEM_STATE_URGENT", "urgent"}, {PLANK_ITEM_STATE_MOVE, "PLANK_ITEM_STATE_MOVE", "move"}, {PLANK_ITEM_STATE_INVALID, "PLANK_ITEM_STATE_INVALID", "invalid"}, {0, NULL, NULL}};
	GType plank_item_state_type_id;
	plank_item_state_type_id = g_flags_register_static ("PlankItemState", values);
	return plank_item_state_type_id;
}

GType
plank_item_state_get_type (void)
{
	static volatile gsize plank_item_state_type_id__volatile = 0;
	if (g_once_init_enter (&plank_item_state_type_id__volatile)) {
		GType plank_item_state_type_id;
		plank_item_state_type_id = plank_item_state_get_type_once ();
		g_once_init_leave (&plank_item_state_type_id__volatile, plank_item_state_type_id);
	}
	return plank_item_state_type_id__volatile;
}

/**
 * What mouse button pops up the context menu on an item.
 * Can be multiple buttons.
 */
/**
 * Convenience method to map {@link Gdk.EventButton} to this enum.
 *
 * @param event the event to map
 * @return the PopupButton representation of the event
 */
PlankPopupButton
plank_popup_button_from_event_button (GdkEventButton* event)
{
	PlankPopupButton result = 0U;
#line 123 "../lib/Items/Enums.vala"
	g_return_val_if_fail (event != NULL, 0U);
#line 125 "../lib/Items/Enums.vala"
	switch (event->button) {
#line 158 "Enums.c"
		default:
#line 125 "../lib/Items/Enums.vala"
		case GDK_BUTTON_PRIMARY:
#line 162 "Enums.c"
		{
#line 128 "../lib/Items/Enums.vala"
			result = PLANK_POPUP_BUTTON_LEFT;
#line 128 "../lib/Items/Enums.vala"
			return result;
#line 168 "Enums.c"
		}
#line 125 "../lib/Items/Enums.vala"
		case GDK_BUTTON_MIDDLE:
#line 172 "Enums.c"
		{
#line 131 "../lib/Items/Enums.vala"
			result = PLANK_POPUP_BUTTON_MIDDLE;
#line 131 "../lib/Items/Enums.vala"
			return result;
#line 178 "Enums.c"
		}
#line 125 "../lib/Items/Enums.vala"
		case GDK_BUTTON_SECONDARY:
#line 182 "Enums.c"
		{
#line 134 "../lib/Items/Enums.vala"
			result = PLANK_POPUP_BUTTON_RIGHT;
#line 134 "../lib/Items/Enums.vala"
			return result;
#line 188 "Enums.c"
		}
	}
}

static GType
plank_popup_button_get_type_once (void)
{
	static const GFlagsValue values[] = {{PLANK_POPUP_BUTTON_NONE, "PLANK_POPUP_BUTTON_NONE", "none"}, {PLANK_POPUP_BUTTON_LEFT, "PLANK_POPUP_BUTTON_LEFT", "left"}, {PLANK_POPUP_BUTTON_MIDDLE, "PLANK_POPUP_BUTTON_MIDDLE", "middle"}, {PLANK_POPUP_BUTTON_RIGHT, "PLANK_POPUP_BUTTON_RIGHT", "right"}, {0, NULL, NULL}};
	GType plank_popup_button_type_id;
	plank_popup_button_type_id = g_flags_register_static ("PlankPopupButton", values);
	return plank_popup_button_type_id;
}

GType
plank_popup_button_get_type (void)
{
	static volatile gsize plank_popup_button_type_id__volatile = 0;
	if (g_once_init_enter (&plank_popup_button_type_id__volatile)) {
		GType plank_popup_button_type_id;
		plank_popup_button_type_id = plank_popup_button_get_type_once ();
		g_once_init_leave (&plank_popup_button_type_id__volatile, plank_popup_button_type_id);
	}
	return plank_popup_button_type_id__volatile;
}

