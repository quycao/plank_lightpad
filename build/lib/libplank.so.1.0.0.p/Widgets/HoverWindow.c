/* HoverWindow.c generated by valac 0.48.17, the Vala compiler
 * generated from HoverWindow.vala, do not modify */

/**/
/*  Copyright (C) 2011-2012 Robert Dyer, Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <gtk/gtk.h>
#include <glib-object.h>
#include <cairo-gobject.h>
#include <glib.h>
#include <gdk/gdk.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <atk/atk.h>
#include <gtk-compat.h>

#define PLANK_TYPE_HOVER_WINDOW (plank_hover_window_get_type ())
#define PLANK_HOVER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_HOVER_WINDOW, PlankHoverWindow))
#define PLANK_HOVER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_HOVER_WINDOW, PlankHoverWindowClass))
#define PLANK_IS_HOVER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_HOVER_WINDOW))
#define PLANK_IS_HOVER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_HOVER_WINDOW))
#define PLANK_HOVER_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_HOVER_WINDOW, PlankHoverWindowClass))

typedef struct _PlankHoverWindow PlankHoverWindow;
typedef struct _PlankHoverWindowClass PlankHoverWindowClass;
typedef struct _PlankHoverWindowPrivate PlankHoverWindowPrivate;
enum  {
	PLANK_HOVER_WINDOW_0_PROPERTY,
	PLANK_HOVER_WINDOW_NUM_PROPERTIES
};
static GParamSpec* plank_hover_window_properties[PLANK_HOVER_WINDOW_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cairo_region_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_region_destroy (var), NULL)))
#define _cairo_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_destroy (var), NULL)))
#define _cairo_surface_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_surface_destroy (var), NULL)))
#define _g_type_class_unref0(var) ((var == NULL) ? NULL : (var = (g_type_class_unref (var), NULL)))

struct _PlankHoverWindow {
	GtkWindow parent_instance;
	PlankHoverWindowPrivate * priv;
};

struct _PlankHoverWindowClass {
	GtkWindowClass parent_class;
};

struct _PlankHoverWindowPrivate {
	GtkBox* box;
	GtkLabel* label;
};

static gint PlankHoverWindow_private_offset;
static gpointer plank_hover_window_parent_class = NULL;

GType plank_hover_window_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankHoverWindow, g_object_unref)
#define PLANK_HOVER_WINDOW_PADDING 10
PlankHoverWindow* plank_hover_window_new (void);
PlankHoverWindow* plank_hover_window_construct (GType object_type);
void plank_hover_window_show_at (PlankHoverWindow* self,
                                 gint x,
                                 gint y,
                                 GtkPositionType position);
void plank_hover_window_set_text (PlankHoverWindow* self,
                                  const gchar* text);
static gboolean plank_hover_window_real_draw (GtkWidget* base,
                                       cairo_t* cr);
static GObject * plank_hover_window_constructor (GType type,
                                          guint n_construct_properties,
                                          GObjectConstructParam * construct_properties);
static void plank_hover_window_finalize (GObject * obj);
static GType plank_hover_window_get_type_once (void);

static inline gpointer
plank_hover_window_get_instance_private (PlankHoverWindow* self)
{
	return G_STRUCT_MEMBER_P (self, PlankHoverWindow_private_offset);
}

PlankHoverWindow*
plank_hover_window_construct (GType object_type)
{
	PlankHoverWindow * self = NULL;
#line 41 "../lib/Widgets/HoverWindow.vala"
	self = (PlankHoverWindow*) g_object_new (object_type, "type", GTK_WINDOW_POPUP, "type-hint", GDK_WINDOW_TYPE_HINT_TOOLTIP, NULL);
#line 39 "../lib/Widgets/HoverWindow.vala"
	return self;
#line 107 "HoverWindow.c"
}

PlankHoverWindow*
plank_hover_window_new (void)
{
#line 39 "../lib/Widgets/HoverWindow.vala"
	return plank_hover_window_construct (PLANK_TYPE_HOVER_WINDOW);
#line 115 "HoverWindow.c"
}

/**
 * Shows and centers the window according to the x/y location specified
 * while accounting the dock's position.
 *
 * @param x the x location
 * @param y the y location
 * @param position the dock's position
 */
void
plank_hover_window_show_at (PlankHoverWindow* self,
                            gint x,
                            gint y,
                            GtkPositionType position)
{
	GdkScreen* screen = NULL;
	GdkScreen* _tmp0_;
	GdkRectangle monitor = {0};
	GdkScreen* _tmp1_;
	GdkScreen* _tmp2_;
	GdkRectangle _tmp3_ = {0};
	gint width = 0;
	gint height = 0;
	GdkRectangle _tmp4_;
	GdkRectangle _tmp5_;
	GdkRectangle _tmp6_;
	GdkRectangle _tmp7_;
	GdkRectangle _tmp8_;
	GdkRectangle _tmp9_;
#line 75 "../lib/Widgets/HoverWindow.vala"
	g_return_if_fail (self != NULL);
#line 77 "../lib/Widgets/HoverWindow.vala"
	_tmp0_ = gtk_window_get_screen ((GtkWindow*) self);
#line 77 "../lib/Widgets/HoverWindow.vala"
	screen = _tmp0_;
#line 79 "../lib/Widgets/HoverWindow.vala"
	_tmp1_ = screen;
#line 79 "../lib/Widgets/HoverWindow.vala"
	_tmp2_ = screen;
#line 79 "../lib/Widgets/HoverWindow.vala"
	gdk_screen_get_monitor_geometry (_tmp1_, gdk_screen_get_monitor_at_point (_tmp2_, x, y), &_tmp3_);
#line 79 "../lib/Widgets/HoverWindow.vala"
	monitor = _tmp3_;
#line 84 "../lib/Widgets/HoverWindow.vala"
	gtk_widget_show ((GtkWidget*) self);
#line 86 "../lib/Widgets/HoverWindow.vala"
	width = gtk_widget_get_allocated_width ((GtkWidget*) self);
#line 87 "../lib/Widgets/HoverWindow.vala"
	height = gtk_widget_get_allocated_height ((GtkWidget*) self);
#line 89 "../lib/Widgets/HoverWindow.vala"
	switch (position) {
#line 89 "../lib/Widgets/HoverWindow.vala"
		case GTK_POS_BOTTOM:
#line 170 "HoverWindow.c"
		{
#line 91 "../lib/Widgets/HoverWindow.vala"
			x = x - (width / 2);
#line 92 "../lib/Widgets/HoverWindow.vala"
			y = (y - height) - PLANK_HOVER_WINDOW_PADDING;
#line 93 "../lib/Widgets/HoverWindow.vala"
			break;
#line 178 "HoverWindow.c"
		}
#line 89 "../lib/Widgets/HoverWindow.vala"
		case GTK_POS_TOP:
#line 182 "HoverWindow.c"
		{
#line 95 "../lib/Widgets/HoverWindow.vala"
			x = x - (width / 2);
#line 96 "../lib/Widgets/HoverWindow.vala"
			y = y + PLANK_HOVER_WINDOW_PADDING;
#line 97 "../lib/Widgets/HoverWindow.vala"
			break;
#line 190 "HoverWindow.c"
		}
#line 89 "../lib/Widgets/HoverWindow.vala"
		case GTK_POS_LEFT:
#line 194 "HoverWindow.c"
		{
#line 99 "../lib/Widgets/HoverWindow.vala"
			x = x + PLANK_HOVER_WINDOW_PADDING;
#line 100 "../lib/Widgets/HoverWindow.vala"
			y = y - (height / 2);
#line 101 "../lib/Widgets/HoverWindow.vala"
			break;
#line 202 "HoverWindow.c"
		}
#line 89 "../lib/Widgets/HoverWindow.vala"
		case GTK_POS_RIGHT:
#line 206 "HoverWindow.c"
		{
#line 103 "../lib/Widgets/HoverWindow.vala"
			x = (x - width) - PLANK_HOVER_WINDOW_PADDING;
#line 104 "../lib/Widgets/HoverWindow.vala"
			y = y - (height / 2);
#line 105 "../lib/Widgets/HoverWindow.vala"
			break;
#line 214 "HoverWindow.c"
		}
		default:
#line 89 "../lib/Widgets/HoverWindow.vala"
		break;
#line 219 "HoverWindow.c"
	}
#line 108 "../lib/Widgets/HoverWindow.vala"
	_tmp4_ = monitor;
#line 108 "../lib/Widgets/HoverWindow.vala"
	_tmp5_ = monitor;
#line 108 "../lib/Widgets/HoverWindow.vala"
	_tmp6_ = monitor;
#line 108 "../lib/Widgets/HoverWindow.vala"
	x = CLAMP (x, _tmp4_.x, (_tmp5_.x + _tmp6_.width) - width);
#line 109 "../lib/Widgets/HoverWindow.vala"
	_tmp7_ = monitor;
#line 109 "../lib/Widgets/HoverWindow.vala"
	_tmp8_ = monitor;
#line 109 "../lib/Widgets/HoverWindow.vala"
	_tmp9_ = monitor;
#line 109 "../lib/Widgets/HoverWindow.vala"
	y = CLAMP (y, _tmp7_.y, (_tmp8_.y + _tmp9_.height) - height);
#line 111 "../lib/Widgets/HoverWindow.vala"
	gtk_window_move ((GtkWindow*) self, x, y);
#line 239 "HoverWindow.c"
}

/**
 * Set the tooltip-text to show
 *
 * @param text the text to show
 */
void
plank_hover_window_set_text (PlankHoverWindow* self,
                             const gchar* text)
{
	GtkLabel* _tmp0_;
#line 119 "../lib/Widgets/HoverWindow.vala"
	g_return_if_fail (self != NULL);
#line 119 "../lib/Widgets/HoverWindow.vala"
	g_return_if_fail (text != NULL);
#line 121 "../lib/Widgets/HoverWindow.vala"
	_tmp0_ = self->priv->label;
#line 121 "../lib/Widgets/HoverWindow.vala"
	gtk_label_set_text (_tmp0_, text);
#line 122 "../lib/Widgets/HoverWindow.vala"
	if (text != NULL) {
#line 262 "HoverWindow.c"
		GtkLabel* _tmp1_;
#line 123 "../lib/Widgets/HoverWindow.vala"
		_tmp1_ = self->priv->label;
#line 123 "../lib/Widgets/HoverWindow.vala"
		gtk_widget_show ((GtkWidget*) _tmp1_);
#line 268 "HoverWindow.c"
	} else {
		GtkLabel* _tmp2_;
#line 125 "../lib/Widgets/HoverWindow.vala"
		_tmp2_ = self->priv->label;
#line 125 "../lib/Widgets/HoverWindow.vala"
		gtk_widget_hide ((GtkWidget*) _tmp2_);
#line 275 "HoverWindow.c"
	}
}

/**
 * {@inheritDoc}
 */
static gboolean
plank_hover_window_real_draw (GtkWidget* base,
                              cairo_t* cr)
{
	PlankHoverWindow * self;
	gint width = 0;
	gint height = 0;
	GtkStyleContext* context = NULL;
	GtkStyleContext* _tmp0_;
	gboolean result = FALSE;
#line 131 "../lib/Widgets/HoverWindow.vala"
	self = (PlankHoverWindow*) base;
#line 131 "../lib/Widgets/HoverWindow.vala"
	g_return_val_if_fail (cr != NULL, FALSE);
#line 133 "../lib/Widgets/HoverWindow.vala"
	width = gtk_widget_get_allocated_width ((GtkWidget*) self);
#line 134 "../lib/Widgets/HoverWindow.vala"
	height = gtk_widget_get_allocated_height ((GtkWidget*) self);
#line 135 "../lib/Widgets/HoverWindow.vala"
	_tmp0_ = gtk_widget_get_style_context ((GtkWidget*) self);
#line 135 "../lib/Widgets/HoverWindow.vala"
	context = _tmp0_;
#line 137 "../lib/Widgets/HoverWindow.vala"
	if (gtk_widget_is_composited ((GtkWidget*) self)) {
#line 306 "HoverWindow.c"
		GtkStyleContext* _tmp1_;
		GtkStyleContext* _tmp2_;
#line 138 "../lib/Widgets/HoverWindow.vala"
		cairo_save (cr);
#line 139 "../lib/Widgets/HoverWindow.vala"
		cairo_set_operator (cr, CAIRO_OPERATOR_CLEAR);
#line 140 "../lib/Widgets/HoverWindow.vala"
		cairo_paint (cr);
#line 141 "../lib/Widgets/HoverWindow.vala"
		cairo_restore (cr);
#line 143 "../lib/Widgets/HoverWindow.vala"
		gtk_widget_shape_combine_region ((GtkWidget*) self, NULL);
#line 145 "../lib/Widgets/HoverWindow.vala"
		_tmp1_ = context;
#line 145 "../lib/Widgets/HoverWindow.vala"
		gtk_render_background (_tmp1_, cr, (gdouble) 0, (gdouble) 0, (gdouble) width, (gdouble) height);
#line 146 "../lib/Widgets/HoverWindow.vala"
		_tmp2_ = context;
#line 146 "../lib/Widgets/HoverWindow.vala"
		gtk_render_frame (_tmp2_, cr, (gdouble) 0, (gdouble) 0, (gdouble) width, (gdouble) height);
#line 327 "HoverWindow.c"
	} else {
		cairo_surface_t* surface = NULL;
		GdkWindow* _tmp3_;
		cairo_surface_t* _tmp4_;
		cairo_t* compat_cr = NULL;
		cairo_surface_t* _tmp5_;
		cairo_t* _tmp6_;
		GtkStyleContext* _tmp7_;
		cairo_t* _tmp8_;
		GtkStyleContext* _tmp9_;
		cairo_t* _tmp10_;
		cairo_region_t* region = NULL;
		cairo_surface_t* _tmp11_;
		cairo_region_t* _tmp12_;
		cairo_region_t* _tmp13_;
#line 148 "../lib/Widgets/HoverWindow.vala"
		_tmp3_ = gtk_widget_get_window ((GtkWidget*) self);
#line 148 "../lib/Widgets/HoverWindow.vala"
		_tmp4_ = gdk_window_create_similar_surface (_tmp3_, CAIRO_CONTENT_COLOR_ALPHA, width, height);
#line 148 "../lib/Widgets/HoverWindow.vala"
		surface = _tmp4_;
#line 149 "../lib/Widgets/HoverWindow.vala"
		_tmp5_ = surface;
#line 149 "../lib/Widgets/HoverWindow.vala"
		_tmp6_ = cairo_create (_tmp5_);
#line 149 "../lib/Widgets/HoverWindow.vala"
		compat_cr = _tmp6_;
#line 151 "../lib/Widgets/HoverWindow.vala"
		_tmp7_ = context;
#line 151 "../lib/Widgets/HoverWindow.vala"
		_tmp8_ = compat_cr;
#line 151 "../lib/Widgets/HoverWindow.vala"
		gtk_render_background (_tmp7_, _tmp8_, (gdouble) 0, (gdouble) 0, (gdouble) width, (gdouble) height);
#line 152 "../lib/Widgets/HoverWindow.vala"
		_tmp9_ = context;
#line 152 "../lib/Widgets/HoverWindow.vala"
		_tmp10_ = compat_cr;
#line 152 "../lib/Widgets/HoverWindow.vala"
		gtk_render_frame (_tmp9_, _tmp10_, (gdouble) 0, (gdouble) 0, (gdouble) width, (gdouble) height);
#line 154 "../lib/Widgets/HoverWindow.vala"
		_tmp11_ = surface;
#line 154 "../lib/Widgets/HoverWindow.vala"
		_tmp12_ = gdk_cairo_region_create_from_surface (_tmp11_);
#line 154 "../lib/Widgets/HoverWindow.vala"
		region = _tmp12_;
#line 155 "../lib/Widgets/HoverWindow.vala"
		_tmp13_ = region;
#line 155 "../lib/Widgets/HoverWindow.vala"
		gtk_widget_shape_combine_region ((GtkWidget*) self, _tmp13_);
#line 137 "../lib/Widgets/HoverWindow.vala"
		_cairo_region_destroy0 (region);
#line 137 "../lib/Widgets/HoverWindow.vala"
		_cairo_destroy0 (compat_cr);
#line 137 "../lib/Widgets/HoverWindow.vala"
		_cairo_surface_destroy0 (surface);
#line 383 "HoverWindow.c"
	}
#line 158 "../lib/Widgets/HoverWindow.vala"
	result = GTK_WIDGET_CLASS (plank_hover_window_parent_class)->draw ((GtkWidget*) G_TYPE_CHECK_INSTANCE_CAST (self, gtk_window_get_type (), GtkWindow), cr);
#line 158 "../lib/Widgets/HoverWindow.vala"
	return result;
#line 389 "HoverWindow.c"
}

static GObject *
plank_hover_window_constructor (GType type,
                                guint n_construct_properties,
                                GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	PlankHoverWindow * self;
	GdkScreen* screen = NULL;
	GdkScreen* _tmp0_;
	GdkVisual* _tmp1_ = NULL;
	GdkScreen* _tmp2_;
	GdkVisual* _tmp3_;
	GtkStyleContext* _tmp6_;
	GtkBox* _tmp7_;
	GtkBox* _tmp8_;
	GtkBox* _tmp9_;
	GtkBox* _tmp10_;
	GtkBox* _tmp11_;
	GtkBox* _tmp12_;
	GtkBox* _tmp13_;
	GtkLabel* _tmp14_;
	GtkLabel* _tmp15_;
	GtkBox* _tmp16_;
	GtkLabel* _tmp17_;
#line 44 "../lib/Widgets/HoverWindow.vala"
	parent_class = G_OBJECT_CLASS (plank_hover_window_parent_class);
#line 44 "../lib/Widgets/HoverWindow.vala"
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
#line 44 "../lib/Widgets/HoverWindow.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_HOVER_WINDOW, PlankHoverWindow);
#line 46 "../lib/Widgets/HoverWindow.vala"
	gtk_widget_set_app_paintable ((GtkWidget*) self, TRUE);
#line 47 "../lib/Widgets/HoverWindow.vala"
	gtk_window_set_resizable ((GtkWindow*) self, FALSE);
#line 49 "../lib/Widgets/HoverWindow.vala"
	_tmp0_ = gtk_window_get_screen ((GtkWindow*) self);
#line 49 "../lib/Widgets/HoverWindow.vala"
	screen = _tmp0_;
#line 50 "../lib/Widgets/HoverWindow.vala"
	_tmp2_ = screen;
#line 50 "../lib/Widgets/HoverWindow.vala"
	_tmp3_ = gdk_screen_get_rgba_visual (_tmp2_);
#line 50 "../lib/Widgets/HoverWindow.vala"
	_tmp1_ = _tmp3_;
#line 50 "../lib/Widgets/HoverWindow.vala"
	if (_tmp1_ == NULL) {
#line 439 "HoverWindow.c"
		GdkScreen* _tmp4_;
		GdkVisual* _tmp5_;
#line 50 "../lib/Widgets/HoverWindow.vala"
		_tmp4_ = screen;
#line 50 "../lib/Widgets/HoverWindow.vala"
		_tmp5_ = gdk_screen_get_system_visual (_tmp4_);
#line 50 "../lib/Widgets/HoverWindow.vala"
		_tmp1_ = _tmp5_;
#line 448 "HoverWindow.c"
	}
#line 50 "../lib/Widgets/HoverWindow.vala"
	gtk_widget_set_visual ((GtkWidget*) self, _tmp1_);
#line 52 "../lib/Widgets/HoverWindow.vala"
	_tmp6_ = gtk_widget_get_style_context ((GtkWidget*) self);
#line 52 "../lib/Widgets/HoverWindow.vala"
	gtk_style_context_add_class (_tmp6_, GTK_STYLE_CLASS_TOOLTIP);
#line 54 "../lib/Widgets/HoverWindow.vala"
	_tmp7_ = (GtkBox*) gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
#line 54 "../lib/Widgets/HoverWindow.vala"
	g_object_ref_sink (_tmp7_);
#line 54 "../lib/Widgets/HoverWindow.vala"
	_g_object_unref0 (self->priv->box);
#line 54 "../lib/Widgets/HoverWindow.vala"
	self->priv->box = _tmp7_;
#line 55 "../lib/Widgets/HoverWindow.vala"
	_tmp8_ = self->priv->box;
#line 55 "../lib/Widgets/HoverWindow.vala"
	gtk_widget_set_margin_left ((GtkWidget*) _tmp8_, 6);
#line 56 "../lib/Widgets/HoverWindow.vala"
	_tmp9_ = self->priv->box;
#line 56 "../lib/Widgets/HoverWindow.vala"
	gtk_widget_set_margin_right ((GtkWidget*) _tmp9_, 6);
#line 57 "../lib/Widgets/HoverWindow.vala"
	_tmp10_ = self->priv->box;
#line 57 "../lib/Widgets/HoverWindow.vala"
	gtk_widget_set_margin_top ((GtkWidget*) _tmp10_, 6);
#line 58 "../lib/Widgets/HoverWindow.vala"
	_tmp11_ = self->priv->box;
#line 58 "../lib/Widgets/HoverWindow.vala"
	gtk_widget_set_margin_bottom ((GtkWidget*) _tmp11_, 6);
#line 59 "../lib/Widgets/HoverWindow.vala"
	_tmp12_ = self->priv->box;
#line 59 "../lib/Widgets/HoverWindow.vala"
	gtk_container_add ((GtkContainer*) self, (GtkWidget*) _tmp12_);
#line 60 "../lib/Widgets/HoverWindow.vala"
	_tmp13_ = self->priv->box;
#line 60 "../lib/Widgets/HoverWindow.vala"
	gtk_widget_show ((GtkWidget*) _tmp13_);
#line 62 "../lib/Widgets/HoverWindow.vala"
	_tmp14_ = (GtkLabel*) gtk_label_new (NULL);
#line 62 "../lib/Widgets/HoverWindow.vala"
	g_object_ref_sink (_tmp14_);
#line 62 "../lib/Widgets/HoverWindow.vala"
	_g_object_unref0 (self->priv->label);
#line 62 "../lib/Widgets/HoverWindow.vala"
	self->priv->label = _tmp14_;
#line 63 "../lib/Widgets/HoverWindow.vala"
	_tmp15_ = self->priv->label;
#line 63 "../lib/Widgets/HoverWindow.vala"
	gtk_label_set_line_wrap (_tmp15_, TRUE);
#line 64 "../lib/Widgets/HoverWindow.vala"
	_tmp16_ = self->priv->box;
#line 64 "../lib/Widgets/HoverWindow.vala"
	_tmp17_ = self->priv->label;
#line 64 "../lib/Widgets/HoverWindow.vala"
	gtk_box_pack_start (_tmp16_, (GtkWidget*) _tmp17_, FALSE, FALSE, (guint) 0);
#line 44 "../lib/Widgets/HoverWindow.vala"
	return obj;
#line 508 "HoverWindow.c"
}

static void
plank_hover_window_class_init (PlankHoverWindowClass * klass,
                               gpointer klass_data)
{
	GTypeClass* _tmp0_;
	GObjectClass* _tmp1_;
#line 26 "../lib/Widgets/HoverWindow.vala"
	plank_hover_window_parent_class = g_type_class_peek_parent (klass);
#line 26 "../lib/Widgets/HoverWindow.vala"
	g_type_class_adjust_private_offset (klass, &PlankHoverWindow_private_offset);
#line 26 "../lib/Widgets/HoverWindow.vala"
	((GtkWidgetClass *) klass)->draw = (gboolean (*) (GtkWidget*, cairo_t*)) plank_hover_window_real_draw;
#line 26 "../lib/Widgets/HoverWindow.vala"
	G_OBJECT_CLASS (klass)->constructor = plank_hover_window_constructor;
#line 26 "../lib/Widgets/HoverWindow.vala"
	G_OBJECT_CLASS (klass)->finalize = plank_hover_window_finalize;
#line 32 "../lib/Widgets/HoverWindow.vala"
	gtk_widget_class_set_accessible_role (GTK_WIDGET_CLASS (klass), ATK_ROLE_TOOL_TIP);
#line 33 "../lib/Widgets/HoverWindow.vala"
	_tmp0_ = g_type_class_ref (PLANK_TYPE_HOVER_WINDOW);
#line 33 "../lib/Widgets/HoverWindow.vala"
	_tmp1_ = (GObjectClass*) _tmp0_;
#line 33 "../lib/Widgets/HoverWindow.vala"
	plank_compat_gtk_widget_class_set_css_name (_tmp1_, "tooltip");
#line 33 "../lib/Widgets/HoverWindow.vala"
	_g_type_class_unref0 (_tmp1_);
#line 537 "HoverWindow.c"
}

static void
plank_hover_window_instance_init (PlankHoverWindow * self,
                                  gpointer klass)
{
#line 26 "../lib/Widgets/HoverWindow.vala"
	self->priv = plank_hover_window_get_instance_private (self);
#line 546 "HoverWindow.c"
}

static void
plank_hover_window_finalize (GObject * obj)
{
	PlankHoverWindow * self;
#line 26 "../lib/Widgets/HoverWindow.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_HOVER_WINDOW, PlankHoverWindow);
#line 36 "../lib/Widgets/HoverWindow.vala"
	_g_object_unref0 (self->priv->box);
#line 37 "../lib/Widgets/HoverWindow.vala"
	_g_object_unref0 (self->priv->label);
#line 26 "../lib/Widgets/HoverWindow.vala"
	G_OBJECT_CLASS (plank_hover_window_parent_class)->finalize (obj);
#line 561 "HoverWindow.c"
}

/**
 * A hover window that shows labels for dock items.
 * This window floats outside (but near) the dock.
 */
static GType
plank_hover_window_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankHoverWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_hover_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankHoverWindow), 0, (GInstanceInitFunc) plank_hover_window_instance_init, NULL };
	GType plank_hover_window_type_id;
	plank_hover_window_type_id = g_type_register_static (gtk_window_get_type (), "PlankHoverWindow", &g_define_type_info, 0);
	PlankHoverWindow_private_offset = g_type_add_instance_private (plank_hover_window_type_id, sizeof (PlankHoverWindowPrivate));
	return plank_hover_window_type_id;
}

GType
plank_hover_window_get_type (void)
{
	static volatile gsize plank_hover_window_type_id__volatile = 0;
	if (g_once_init_enter (&plank_hover_window_type_id__volatile)) {
		GType plank_hover_window_type_id;
		plank_hover_window_type_id = plank_hover_window_get_type_once ();
		g_once_init_leave (&plank_hover_window_type_id__volatile, plank_hover_window_type_id);
	}
	return plank_hover_window_type_id__volatile;
}

