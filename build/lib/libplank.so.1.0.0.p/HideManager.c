/* HideManager.c generated by valac 0.48.17, the Vala compiler
 * generated from HideManager.vala, do not modify */

/**/
/*  Copyright (C) 2011-2012 Robert Dyer, Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <glib.h>
#include <gdk/gdk.h>
#include <X11/extensions/Xfixes.h>
#include <float.h>
#include <math.h>
#include <gtk/gtk.h>
#include <libwnck/libwnck.h>
#include <gdk/gdkx.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xregion.h>
#include <cairo-gobject.h>
#include <X11/extensions/XI2.h>
#include <X11/extensions/XInput2.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

typedef enum  {
	PLANK_HIDE_TYPE_NONE,
	PLANK_HIDE_TYPE_INTELLIGENT,
	PLANK_HIDE_TYPE_AUTO,
	PLANK_HIDE_TYPE_DODGE_MAXIMIZED,
	PLANK_HIDE_TYPE_WINDOW_DODGE,
	PLANK_HIDE_TYPE_DODGE_ACTIVE
} PlankHideType;

#define PLANK_TYPE_HIDE_TYPE (plank_hide_type_get_type ())

#define PLANK_TYPE_HIDE_MANAGER (plank_hide_manager_get_type ())
#define PLANK_HIDE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_HIDE_MANAGER, PlankHideManager))
#define PLANK_HIDE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_HIDE_MANAGER, PlankHideManagerClass))
#define PLANK_IS_HIDE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_HIDE_MANAGER))
#define PLANK_IS_HIDE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_HIDE_MANAGER))
#define PLANK_HIDE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_HIDE_MANAGER, PlankHideManagerClass))

typedef struct _PlankHideManager PlankHideManager;
typedef struct _PlankHideManagerClass PlankHideManagerClass;
typedef struct _PlankHideManagerPrivate PlankHideManagerPrivate;

#define PLANK_TYPE_DOCK_ELEMENT (plank_dock_element_get_type ())
#define PLANK_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElement))
#define PLANK_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))
#define PLANK_IS_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_IS_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_DOCK_ELEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))

typedef struct _PlankDockElement PlankDockElement;
typedef struct _PlankDockElementClass PlankDockElementClass;

#define PLANK_TYPE_DOCK_CONTAINER (plank_dock_container_get_type ())
#define PLANK_DOCK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainer))
#define PLANK_DOCK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainerClass))
#define PLANK_IS_DOCK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_CONTAINER))
#define PLANK_IS_DOCK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_CONTAINER))
#define PLANK_DOCK_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainerClass))

typedef struct _PlankDockContainer PlankDockContainer;
typedef struct _PlankDockContainerClass PlankDockContainerClass;

#define PLANK_TYPE_DOCK_CONTROLLER (plank_dock_controller_get_type ())
#define PLANK_DOCK_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_CONTROLLER, PlankDockController))
#define PLANK_DOCK_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_CONTROLLER, PlankDockControllerClass))
#define PLANK_IS_DOCK_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_CONTROLLER))
#define PLANK_IS_DOCK_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_CONTROLLER))
#define PLANK_DOCK_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_CONTROLLER, PlankDockControllerClass))

typedef struct _PlankDockController PlankDockController;
typedef struct _PlankDockControllerClass PlankDockControllerClass;
enum  {
	PLANK_HIDE_MANAGER_0_PROPERTY,
	PLANK_HIDE_MANAGER_CONTROLLER_PROPERTY,
	PLANK_HIDE_MANAGER_HIDDEN_PROPERTY,
	PLANK_HIDE_MANAGER_DISABLED_PROPERTY,
	PLANK_HIDE_MANAGER_HOVERED_PROPERTY,
	PLANK_HIDE_MANAGER_NUM_PROPERTIES
};
static GParamSpec* plank_hide_manager_properties[PLANK_HIDE_MANAGER_NUM_PROPERTIES];

#define PLANK_TYPE_COMPOSITED_WINDOW (plank_composited_window_get_type ())
#define PLANK_COMPOSITED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_COMPOSITED_WINDOW, PlankCompositedWindow))
#define PLANK_COMPOSITED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_COMPOSITED_WINDOW, PlankCompositedWindowClass))
#define PLANK_IS_COMPOSITED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_COMPOSITED_WINDOW))
#define PLANK_IS_COMPOSITED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_COMPOSITED_WINDOW))
#define PLANK_COMPOSITED_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_COMPOSITED_WINDOW, PlankCompositedWindowClass))

typedef struct _PlankCompositedWindow PlankCompositedWindow;
typedef struct _PlankCompositedWindowClass PlankCompositedWindowClass;

#define PLANK_TYPE_DOCK_WINDOW (plank_dock_window_get_type ())
#define PLANK_DOCK_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_WINDOW, PlankDockWindow))
#define PLANK_DOCK_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_WINDOW, PlankDockWindowClass))
#define PLANK_IS_DOCK_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_WINDOW))
#define PLANK_IS_DOCK_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_WINDOW))
#define PLANK_DOCK_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_WINDOW, PlankDockWindowClass))

typedef struct _PlankDockWindow PlankDockWindow;
typedef struct _PlankDockWindowClass PlankDockWindowClass;

#define PLANK_TYPE_DRAG_MANAGER (plank_drag_manager_get_type ())
#define PLANK_DRAG_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DRAG_MANAGER, PlankDragManager))
#define PLANK_DRAG_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DRAG_MANAGER, PlankDragManagerClass))
#define PLANK_IS_DRAG_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DRAG_MANAGER))
#define PLANK_IS_DRAG_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DRAG_MANAGER))
#define PLANK_DRAG_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DRAG_MANAGER, PlankDragManagerClass))

typedef struct _PlankDragManager PlankDragManager;
typedef struct _PlankDragManagerClass PlankDragManagerClass;

#define PLANK_TYPE_SETTINGS (plank_settings_get_type ())
#define PLANK_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_SETTINGS, PlankSettings))
#define PLANK_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_SETTINGS, PlankSettingsClass))
#define PLANK_IS_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_SETTINGS))
#define PLANK_IS_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_SETTINGS))
#define PLANK_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_SETTINGS, PlankSettingsClass))

typedef struct _PlankSettings PlankSettings;
typedef struct _PlankSettingsClass PlankSettingsClass;

#define PLANK_TYPE_DOCK_PREFERENCES (plank_dock_preferences_get_type ())
#define PLANK_DOCK_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_PREFERENCES, PlankDockPreferences))
#define PLANK_DOCK_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_PREFERENCES, PlankDockPreferencesClass))
#define PLANK_IS_DOCK_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_PREFERENCES))
#define PLANK_IS_DOCK_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_PREFERENCES))
#define PLANK_DOCK_PREFERENCES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_PREFERENCES, PlankDockPreferencesClass))

typedef struct _PlankDockPreferences PlankDockPreferences;
typedef struct _PlankDockPreferencesClass PlankDockPreferencesClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define PLANK_TYPE_POSITION_MANAGER (plank_position_manager_get_type ())
#define PLANK_POSITION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_POSITION_MANAGER, PlankPositionManager))
#define PLANK_POSITION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_POSITION_MANAGER, PlankPositionManagerClass))
#define PLANK_IS_POSITION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_POSITION_MANAGER))
#define PLANK_IS_POSITION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_POSITION_MANAGER))
#define PLANK_POSITION_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_POSITION_MANAGER, PlankPositionManagerClass))

typedef struct _PlankPositionManager PlankPositionManager;
typedef struct _PlankPositionManagerClass PlankPositionManagerClass;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _PlankHideManager {
	GObject parent_instance;
	PlankHideManagerPrivate * priv;
};

struct _PlankHideManagerClass {
	GObjectClass parent_class;
};

struct _PlankHideManagerPrivate {
	PlankDockController* _controller;
	gboolean _Hidden;
	gboolean _Disabled;
	gboolean _Hovered;
	guint hide_timer_id;
	guint unhide_timer_id;
	guint prefs_changed_timer_id;
	guint geometry_timer_id;
	guint window_changed_timer_id;
	gboolean pointer_update;
	gboolean window_intersect;
	gboolean active_window_intersect;
	gboolean active_application_intersect;
	gboolean active_maximized_window_intersect;
	gboolean dialog_windows_intersect;
	GdkRectangle last_window_rect;
	PointerBarrier barrier;
	gint opcode;
	gdouble pressure;
	guint pressure_timer_id;
	gboolean barriers_supported;
};

static gint PlankHideManager_private_offset;
static gpointer plank_hide_manager_parent_class = NULL;
static gint plank_hide_manager_plank_pid;
static gint plank_hide_manager_plank_pid = 0;

GType plank_hide_type_get_type (void) G_GNUC_CONST;
GType plank_hide_manager_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankHideManager, g_object_unref)
GType plank_dock_element_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockElement, g_object_unref)
GType plank_dock_container_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockContainer, g_object_unref)
GType plank_dock_controller_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockController, g_object_unref)
GType plank_composited_window_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankCompositedWindow, g_object_unref)
GType plank_dock_window_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockWindow, g_object_unref)
static PlankDockController* plank_hide_manager_get_controller (PlankHideManager* self);
PlankDockWindow* plank_dock_controller_get_window (PlankDockController* self);
GType plank_drag_manager_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDragManager, g_object_unref)
PlankDragManager* plank_dock_controller_get_drag_manager (PlankDockController* self);
GType plank_settings_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankSettings, g_object_unref)
GType plank_dock_preferences_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockPreferences, g_object_unref)
PlankDockPreferences* plank_dock_controller_get_prefs (PlankDockController* self);
static void plank_hide_manager_prefs_changed (PlankHideManager* self,
                                       GObject* prefs,
                                       GParamSpec* prop);
static void _plank_hide_manager_prefs_changed_g_object_notify (GObject* _sender,
                                                        GParamSpec* pspec,
                                                        gpointer self);
static gboolean plank_hide_manager_handle_enter_notify_event (GtkWidget* widget,
                                                       GdkEventCrossing* event,
                                                       PlankHideManager* self);
static gboolean _plank_hide_manager_handle_enter_notify_event_gtk_widget_enter_notify_event (GtkWidget* _sender,
                                                                                      GdkEventCrossing* event,
                                                                                      gpointer self);
static gboolean plank_hide_manager_handle_leave_notify_event (GtkWidget* widget,
                                                       GdkEventCrossing* event,
                                                       PlankHideManager* self);
static gboolean _plank_hide_manager_handle_leave_notify_event_gtk_widget_leave_notify_event (GtkWidget* _sender,
                                                                                      GdkEventCrossing* event,
                                                                                      gpointer self);
static void plank_hide_manager_schedule_update (PlankHideManager* self);
static void _plank_hide_manager_schedule_update_wnck_screen_window_opened (WnckScreen* _sender,
                                                                    WnckWindow* window,
                                                                    gpointer self);
static void _plank_hide_manager_schedule_update_wnck_screen_window_closed (WnckScreen* _sender,
                                                                    WnckWindow* window,
                                                                    gpointer self);
static void plank_hide_manager_handle_active_window_changed (WnckScreen* screen,
                                                      WnckWindow* previous,
                                                      PlankHideManager* self);
static void _plank_hide_manager_handle_active_window_changed_wnck_screen_active_window_changed (WnckScreen* _sender,
                                                                                         WnckWindow* previous_window,
                                                                                         gpointer self);
static void plank_hide_manager_handle_workspace_changed (WnckScreen* screen,
                                                  WnckWorkspace* previous,
                                                  PlankHideManager* self);
static void _plank_hide_manager_handle_workspace_changed_wnck_screen_active_workspace_changed (WnckScreen* _sender,
                                                                                        WnckWorkspace* previous_workspace,
                                                                                        gpointer self);
static void plank_hide_manager_stop_timers (PlankHideManager* self);
static GdkFilterReturn plank_hide_manager_xevent_filter (GdkXEvent* gdk_xevent,
                                                  GdkEvent* gdk_event,
                                                  PlankHideManager* self);
#define PLANK_HIDE_MANAGER_UPDATE_TIMEOUT 200U
#define PLANK_HIDE_MANAGER_PRESSURE_THRESHOLD 60.0
#define PLANK_HIDE_MANAGER_PRESSURE_TIMEOUT 1000U
PlankHideManager* plank_hide_manager_new (PlankDockController* controller);
PlankHideManager* plank_hide_manager_construct (GType object_type,
                                                PlankDockController* controller);
void plank_hide_manager_initialize (PlankHideManager* self);
static void plank_hide_manager_initialize_barriers_support (PlankHideManager* self);
static void plank_hide_manager_setup_active_window (PlankHideManager* self,
                                             WnckScreen* screen);
void plank_hide_manager_update_hovered (PlankHideManager* self);
GType plank_position_manager_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankPositionManager, g_object_unref)
PlankPositionManager* plank_dock_controller_get_position_manager (PlankDockController* self);
void plank_position_manager_get_dock_window_region (PlankPositionManager* self,
                                                    GdkRectangle* result);
void plank_hide_manager_update_hovered_with_coords (PlankHideManager* self,
                                                    gint x,
                                                    gint y);
void plank_position_manager_get_cursor_region (PlankPositionManager* self,
                                               GdkRectangle* result);
gboolean plank_hide_manager_get_Hovered (PlankHideManager* self);
static void plank_hide_manager_set_Hovered (PlankHideManager* self,
                                     gboolean value);
gboolean plank_dock_window_menu_is_visible (PlankDockWindow* self);
gboolean plank_drag_manager_get_InternalDragActive (PlankDragManager* self);
gboolean plank_drag_manager_get_ExternalDragActive (PlankDragManager* self);
gboolean plank_hide_manager_get_Disabled (PlankHideManager* self);
static void plank_hide_manager_set_Disabled (PlankHideManager* self,
                                      gboolean value);
static void plank_hide_manager_update_hidden (PlankHideManager* self);
static gboolean ___lambda50_ (PlankHideManager* self);
static void plank_hide_manager_update_window_intersect (PlankHideManager* self);
void plank_hide_manager_update_barrier (PlankHideManager* self);
static gboolean ____lambda50__gsource_func (gpointer self);
gboolean plank_hide_manager_get_Hidden (PlankHideManager* self);
static void plank_hide_manager_set_Hidden (PlankHideManager* self,
                                    gboolean value);
PlankHideType plank_dock_preferences_get_HideMode (PlankDockPreferences* self);
static void plank_hide_manager_show (PlankHideManager* self);
static void plank_hide_manager_hide (PlankHideManager* self);
guint plank_dock_preferences_get_HideDelay (PlankDockPreferences* self);
static gboolean __lambda12_ (PlankHideManager* self);
static gboolean ___lambda12__gsource_func (gpointer self);
guint plank_dock_preferences_get_UnhideDelay (PlankDockPreferences* self);
static gboolean __lambda11_ (PlankHideManager* self);
static gboolean ___lambda11__gsource_func (gpointer self);
gboolean plank_dock_preferences_get_PressureReveal (PlankDockPreferences* self);
static inline gboolean plank_hide_manager_device_supports_pressure (PlankHideManager* self,
                                                      GdkDevice* device);
void plank_position_manager_get_static_dock_region (PlankPositionManager* self,
                                                    GdkRectangle* result);
static void plank_hide_manager_window_geometry (WnckWindow* window,
                                         GdkRectangle* result);
static gboolean __lambda48_ (PlankHideManager* self);
static gboolean ___lambda48__gsource_func (gpointer self);
static void plank_hide_manager_handle_geometry_changed (WnckWindow* window,
                                                 PlankHideManager* self);
static void _plank_hide_manager_handle_geometry_changed_wnck_window_geometry_changed (WnckWindow* _sender,
                                                                               gpointer self);
static void plank_hide_manager_handle_state_changed (WnckWindow* window,
                                              WnckWindowState changed_mask,
                                              WnckWindowState new_state,
                                              PlankHideManager* self);
static void _plank_hide_manager_handle_state_changed_wnck_window_state_changed (WnckWindow* _sender,
                                                                         WnckWindowState changed_mask,
                                                                         WnckWindowState new_state,
                                                                         gpointer self);
static gboolean _cairo_rectangle_int_equal (const cairo_rectangle_int_t * s1,
                                     const cairo_rectangle_int_t * s2);
static gboolean __lambda49_ (PlankHideManager* self);
static gboolean ___lambda49__gsource_func (gpointer self);
GtkPositionType plank_position_manager_get_Position (PlankPositionManager* self);
void plank_logger_verbose (const gchar* msg,
                           ...);
static gboolean ____lambda13_ (PlankHideManager* self);
static gboolean _____lambda13__gsource_func (gpointer self);
void plank_position_manager_get_barrier (PlankPositionManager* self,
                                         GdkRectangle* result);
static void xinput_event_mask_destroy (XIEventMask * self);
static void plank_hide_manager_set_controller (PlankHideManager* self,
                                        PlankDockController* value);
static GObject * plank_hide_manager_constructor (GType type,
                                          guint n_construct_properties,
                                          GObjectConstructParam * construct_properties);
static void plank_hide_manager_finalize (GObject * obj);
static GType plank_hide_manager_get_type_once (void);
static void _vala_plank_hide_manager_get_property (GObject * object,
                                            guint property_id,
                                            GValue * value,
                                            GParamSpec * pspec);
static void _vala_plank_hide_manager_set_property (GObject * object,
                                            guint property_id,
                                            const GValue * value,
                                            GParamSpec * pspec);

/**
 * If/How the dock should hide itself.
 */
static GType
plank_hide_type_get_type_once (void)
{
	static const GEnumValue values[] = {{PLANK_HIDE_TYPE_NONE, "PLANK_HIDE_TYPE_NONE", "none"}, {PLANK_HIDE_TYPE_INTELLIGENT, "PLANK_HIDE_TYPE_INTELLIGENT", "intelligent"}, {PLANK_HIDE_TYPE_AUTO, "PLANK_HIDE_TYPE_AUTO", "auto"}, {PLANK_HIDE_TYPE_DODGE_MAXIMIZED, "PLANK_HIDE_TYPE_DODGE_MAXIMIZED", "dodge-maximized"}, {PLANK_HIDE_TYPE_WINDOW_DODGE, "PLANK_HIDE_TYPE_WINDOW_DODGE", "window-dodge"}, {PLANK_HIDE_TYPE_DODGE_ACTIVE, "PLANK_HIDE_TYPE_DODGE_ACTIVE", "dodge-active"}, {0, NULL, NULL}};
	GType plank_hide_type_type_id;
	plank_hide_type_type_id = g_enum_register_static ("PlankHideType", values);
	return plank_hide_type_type_id;
}

GType
plank_hide_type_get_type (void)
{
	static volatile gsize plank_hide_type_type_id__volatile = 0;
	if (g_once_init_enter (&plank_hide_type_type_id__volatile)) {
		GType plank_hide_type_type_id;
		plank_hide_type_type_id = plank_hide_type_get_type_once ();
		g_once_init_leave (&plank_hide_type_type_id__volatile, plank_hide_type_type_id);
	}
	return plank_hide_type_type_id__volatile;
}

static inline gpointer
plank_hide_manager_get_instance_private (PlankHideManager* self)
{
	return G_STRUCT_MEMBER_P (self, PlankHideManager_private_offset);
}

static void
_plank_hide_manager_prefs_changed_g_object_notify (GObject* _sender,
                                                   GParamSpec* pspec,
                                                   gpointer self)
{
#line 161 "../lib/HideManager.vala"
	plank_hide_manager_prefs_changed ((PlankHideManager*) self, _sender, pspec);
#line 405 "HideManager.c"
}

static gboolean
_plank_hide_manager_handle_enter_notify_event_gtk_widget_enter_notify_event (GtkWidget* _sender,
                                                                             GdkEventCrossing* event,
                                                                             gpointer self)
{
	gboolean result;
	result = plank_hide_manager_handle_enter_notify_event (_sender, event, (PlankHideManager*) self);
#line 163 "../lib/HideManager.vala"
	return result;
#line 417 "HideManager.c"
}

static gboolean
_plank_hide_manager_handle_leave_notify_event_gtk_widget_leave_notify_event (GtkWidget* _sender,
                                                                             GdkEventCrossing* event,
                                                                             gpointer self)
{
	gboolean result;
	result = plank_hide_manager_handle_leave_notify_event (_sender, event, (PlankHideManager*) self);
#line 164 "../lib/HideManager.vala"
	return result;
#line 429 "HideManager.c"
}

static void
_plank_hide_manager_schedule_update_wnck_screen_window_opened (WnckScreen* _sender,
                                                               WnckWindow* window,
                                                               gpointer self)
{
#line 166 "../lib/HideManager.vala"
	plank_hide_manager_schedule_update ((PlankHideManager*) self);
#line 439 "HideManager.c"
}

static void
_plank_hide_manager_schedule_update_wnck_screen_window_closed (WnckScreen* _sender,
                                                               WnckWindow* window,
                                                               gpointer self)
{
#line 167 "../lib/HideManager.vala"
	plank_hide_manager_schedule_update ((PlankHideManager*) self);
#line 449 "HideManager.c"
}

static void
_plank_hide_manager_handle_active_window_changed_wnck_screen_active_window_changed (WnckScreen* _sender,
                                                                                    WnckWindow* previous_window,
                                                                                    gpointer self)
{
#line 168 "../lib/HideManager.vala"
	plank_hide_manager_handle_active_window_changed (_sender, previous_window, (PlankHideManager*) self);
#line 459 "HideManager.c"
}

static void
_plank_hide_manager_handle_workspace_changed_wnck_screen_active_workspace_changed (WnckScreen* _sender,
                                                                                   WnckWorkspace* previous_workspace,
                                                                                   gpointer self)
{
#line 169 "../lib/HideManager.vala"
	plank_hide_manager_handle_workspace_changed (_sender, previous_workspace, (PlankHideManager*) self);
#line 469 "HideManager.c"
}

/**
 * Creates a new instance of a HideManager, which handles
 * checking if a dock should hide or not.
 *
 * @param controller the {@link DockController} to manage hiding for
 */
PlankHideManager*
plank_hide_manager_construct (GType object_type,
                              PlankDockController* controller)
{
	PlankHideManager * self = NULL;
#line 121 "../lib/HideManager.vala"
	g_return_val_if_fail (controller != NULL, NULL);
#line 123 "../lib/HideManager.vala"
	self = (PlankHideManager*) g_object_new (object_type, "controller", controller, NULL);
#line 121 "../lib/HideManager.vala"
	return self;
#line 489 "HideManager.c"
}

PlankHideManager*
plank_hide_manager_new (PlankDockController* controller)
{
#line 121 "../lib/HideManager.vala"
	return plank_hide_manager_construct (PLANK_TYPE_HIDE_MANAGER, controller);
#line 497 "HideManager.c"
}

/**
 * Initializes the hide manager.  Call after the DockWindow is constructed.
 */
void
plank_hide_manager_initialize (PlankHideManager* self)
{
	PlankDockController* _tmp0_;
	PlankDockWindow* _tmp1_;
	PlankDockWindow* _tmp2_;
	PlankDockWindow* window = NULL;
	PlankDockController* _tmp3_;
	PlankDockWindow* _tmp4_;
	PlankDockWindow* _tmp5_;
	WnckScreen* wnck_screen = NULL;
	WnckScreen* _tmp6_;
#line 134 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 134 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_controller;
#line 134 "../lib/HideManager.vala"
	_tmp1_ = plank_dock_controller_get_window (_tmp0_);
#line 134 "../lib/HideManager.vala"
	_tmp2_ = _tmp1_;
#line 134 "../lib/HideManager.vala"
	_vala_return_if_fail (_tmp2_ != NULL, "controller.window != null");
#line 137 "../lib/HideManager.vala"
	_tmp3_ = self->priv->_controller;
#line 137 "../lib/HideManager.vala"
	_tmp4_ = plank_dock_controller_get_window (_tmp3_);
#line 137 "../lib/HideManager.vala"
	_tmp5_ = _tmp4_;
#line 137 "../lib/HideManager.vala"
	window = _tmp5_;
#line 138 "../lib/HideManager.vala"
	_tmp6_ = wnck_screen_get_default ();
#line 138 "../lib/HideManager.vala"
	wnck_screen = _tmp6_;
#line 141 "../lib/HideManager.vala"
	plank_hide_manager_initialize_barriers_support (self);
#line 144 "../lib/HideManager.vala"
	g_signal_connect_object ((GtkWidget*) window, "enter-notify-event", (GCallback) _plank_hide_manager_handle_enter_notify_event_gtk_widget_enter_notify_event, self, 0);
#line 145 "../lib/HideManager.vala"
	g_signal_connect_object ((GtkWidget*) window, "leave-notify-event", (GCallback) _plank_hide_manager_handle_leave_notify_event_gtk_widget_leave_notify_event, self, 0);
#line 147 "../lib/HideManager.vala"
	g_signal_connect_object (wnck_screen, "window-opened", (GCallback) _plank_hide_manager_schedule_update_wnck_screen_window_opened, self, G_CONNECT_AFTER);
#line 148 "../lib/HideManager.vala"
	g_signal_connect_object (wnck_screen, "window-closed", (GCallback) _plank_hide_manager_schedule_update_wnck_screen_window_closed, self, G_CONNECT_AFTER);
#line 149 "../lib/HideManager.vala"
	g_signal_connect_object (wnck_screen, "active-window-changed", (GCallback) _plank_hide_manager_handle_active_window_changed_wnck_screen_active_window_changed, self, G_CONNECT_AFTER);
#line 150 "../lib/HideManager.vala"
	g_signal_connect_object (wnck_screen, "active-workspace-changed", (GCallback) _plank_hide_manager_handle_workspace_changed_wnck_screen_active_workspace_changed, self, G_CONNECT_AFTER);
#line 152 "../lib/HideManager.vala"
	plank_hide_manager_setup_active_window (self, wnck_screen);
#line 553 "HideManager.c"
}

/**
 * Checks to see if the dock is being hovered by the mouse cursor.
 */
void
plank_hide_manager_update_hovered (PlankHideManager* self)
{
	PlankPositionManager* position_manager = NULL;
	PlankDockController* _tmp0_;
	PlankPositionManager* _tmp1_;
	PlankPositionManager* _tmp2_;
	PlankDockWindow* window = NULL;
	PlankDockController* _tmp3_;
	PlankDockWindow* _tmp4_;
	PlankDockWindow* _tmp5_;
	gint x = 0;
	gint y = 0;
	GdkDisplay* _tmp6_;
	GdkDeviceManager* _tmp7_;
	GdkDevice* _tmp8_;
	gint _tmp9_ = 0;
	gint _tmp10_ = 0;
	GdkRectangle win_rect = {0};
	GdkRectangle _tmp11_ = {0};
	GdkRectangle _tmp12_;
	GdkRectangle _tmp13_;
#line 188 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 190 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_controller;
#line 190 "../lib/HideManager.vala"
	_tmp1_ = plank_dock_controller_get_position_manager (_tmp0_);
#line 190 "../lib/HideManager.vala"
	_tmp2_ = _tmp1_;
#line 190 "../lib/HideManager.vala"
	position_manager = _tmp2_;
#line 191 "../lib/HideManager.vala"
	_tmp3_ = self->priv->_controller;
#line 191 "../lib/HideManager.vala"
	_tmp4_ = plank_dock_controller_get_window (_tmp3_);
#line 191 "../lib/HideManager.vala"
	_tmp5_ = _tmp4_;
#line 191 "../lib/HideManager.vala"
	window = _tmp5_;
#line 196 "../lib/HideManager.vala"
	_tmp6_ = gtk_widget_get_display ((GtkWidget*) window);
#line 196 "../lib/HideManager.vala"
	_tmp7_ = gdk_display_get_device_manager (_tmp6_);
#line 196 "../lib/HideManager.vala"
	_tmp8_ = gdk_device_manager_get_client_pointer (_tmp7_);
#line 196 "../lib/HideManager.vala"
	gdk_device_get_position (_tmp8_, NULL, &_tmp9_, &_tmp10_);
#line 196 "../lib/HideManager.vala"
	x = _tmp9_;
#line 196 "../lib/HideManager.vala"
	y = _tmp10_;
#line 200 "../lib/HideManager.vala"
	plank_position_manager_get_dock_window_region (position_manager, &_tmp11_);
#line 200 "../lib/HideManager.vala"
	win_rect = _tmp11_;
#line 201 "../lib/HideManager.vala"
	_tmp12_ = win_rect;
#line 201 "../lib/HideManager.vala"
	x -= _tmp12_.x;
#line 202 "../lib/HideManager.vala"
	_tmp13_ = win_rect;
#line 202 "../lib/HideManager.vala"
	y -= _tmp13_.y;
#line 204 "../lib/HideManager.vala"
	plank_hide_manager_update_hovered_with_coords (self, x, y);
#line 625 "HideManager.c"
}

/**
 * Checks to see if the dock is being hovered by the mouse cursor.
 *
 * @param x the x coordinate of the pointer relative to the dock window
 * @param y the y coordinate of the pointer relative to the dock window
 */
void
plank_hide_manager_update_hovered_with_coords (PlankHideManager* self,
                                               gint x,
                                               gint y)
{
	PlankPositionManager* position_manager = NULL;
	PlankDockController* _tmp0_;
	PlankPositionManager* _tmp1_;
	PlankPositionManager* _tmp2_;
	PlankDockWindow* window = NULL;
	PlankDockController* _tmp3_;
	PlankDockWindow* _tmp4_;
	PlankDockWindow* _tmp5_;
	PlankDragManager* drag_manager = NULL;
	PlankDockController* _tmp6_;
	PlankDragManager* _tmp7_;
	PlankDragManager* _tmp8_;
	gboolean update_needed = FALSE;
	GdkRectangle dock_rect = {0};
	PlankPositionManager* _tmp9_;
	GdkRectangle _tmp10_ = {0};
	gboolean _tmp11_ = FALSE;
	gboolean _tmp12_ = FALSE;
	gboolean _tmp13_ = FALSE;
	GdkRectangle _tmp14_;
	gboolean hovered = FALSE;
	gboolean _tmp20_;
	gboolean _tmp21_ = FALSE;
	gboolean _tmp22_ = FALSE;
	PlankDockWindow* _tmp23_;
	gboolean disabled = FALSE;
	gboolean _tmp30_;
#line 213 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 215 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_controller;
#line 215 "../lib/HideManager.vala"
	_tmp1_ = plank_dock_controller_get_position_manager (_tmp0_);
#line 215 "../lib/HideManager.vala"
	_tmp2_ = _tmp1_;
#line 215 "../lib/HideManager.vala"
	position_manager = _tmp2_;
#line 216 "../lib/HideManager.vala"
	_tmp3_ = self->priv->_controller;
#line 216 "../lib/HideManager.vala"
	_tmp4_ = plank_dock_controller_get_window (_tmp3_);
#line 216 "../lib/HideManager.vala"
	_tmp5_ = _tmp4_;
#line 216 "../lib/HideManager.vala"
	window = _tmp5_;
#line 217 "../lib/HideManager.vala"
	_tmp6_ = self->priv->_controller;
#line 217 "../lib/HideManager.vala"
	_tmp7_ = plank_dock_controller_get_drag_manager (_tmp6_);
#line 217 "../lib/HideManager.vala"
	_tmp8_ = _tmp7_;
#line 217 "../lib/HideManager.vala"
	drag_manager = _tmp8_;
#line 219 "../lib/HideManager.vala"
	g_object_freeze_notify ((GObject*) self);
#line 221 "../lib/HideManager.vala"
	update_needed = FALSE;
#line 224 "../lib/HideManager.vala"
	_tmp9_ = position_manager;
#line 224 "../lib/HideManager.vala"
	plank_position_manager_get_cursor_region (_tmp9_, &_tmp10_);
#line 224 "../lib/HideManager.vala"
	dock_rect = _tmp10_;
#line 227 "../lib/HideManager.vala"
	_tmp14_ = dock_rect;
#line 227 "../lib/HideManager.vala"
	if (x >= _tmp14_.x) {
#line 706 "HideManager.c"
		GdkRectangle _tmp15_;
		GdkRectangle _tmp16_;
#line 227 "../lib/HideManager.vala"
		_tmp15_ = dock_rect;
#line 227 "../lib/HideManager.vala"
		_tmp16_ = dock_rect;
#line 227 "../lib/HideManager.vala"
		_tmp13_ = x < (_tmp15_.x + _tmp16_.width);
#line 715 "HideManager.c"
	} else {
#line 227 "../lib/HideManager.vala"
		_tmp13_ = FALSE;
#line 719 "HideManager.c"
	}
#line 227 "../lib/HideManager.vala"
	if (_tmp13_) {
#line 723 "HideManager.c"
		GdkRectangle _tmp17_;
#line 228 "../lib/HideManager.vala"
		_tmp17_ = dock_rect;
#line 228 "../lib/HideManager.vala"
		_tmp12_ = y >= _tmp17_.y;
#line 729 "HideManager.c"
	} else {
#line 227 "../lib/HideManager.vala"
		_tmp12_ = FALSE;
#line 733 "HideManager.c"
	}
#line 227 "../lib/HideManager.vala"
	if (_tmp12_) {
#line 737 "HideManager.c"
		GdkRectangle _tmp18_;
		GdkRectangle _tmp19_;
#line 228 "../lib/HideManager.vala"
		_tmp18_ = dock_rect;
#line 228 "../lib/HideManager.vala"
		_tmp19_ = dock_rect;
#line 228 "../lib/HideManager.vala"
		_tmp11_ = y < (_tmp18_.y + _tmp19_.height);
#line 746 "HideManager.c"
	} else {
#line 227 "../lib/HideManager.vala"
		_tmp11_ = FALSE;
#line 750 "HideManager.c"
	}
#line 227 "../lib/HideManager.vala"
	hovered = _tmp11_;
#line 230 "../lib/HideManager.vala"
	_tmp20_ = self->priv->_Hovered;
#line 230 "../lib/HideManager.vala"
	if (_tmp20_ != hovered) {
#line 231 "../lib/HideManager.vala"
		plank_hide_manager_set_Hovered (self, hovered);
#line 232 "../lib/HideManager.vala"
		update_needed = TRUE;
#line 762 "HideManager.c"
	}
#line 236 "../lib/HideManager.vala"
	_tmp23_ = window;
#line 236 "../lib/HideManager.vala"
	if (plank_dock_window_menu_is_visible (_tmp23_)) {
#line 236 "../lib/HideManager.vala"
		_tmp22_ = TRUE;
#line 770 "HideManager.c"
	} else {
		PlankDragManager* _tmp24_;
		gboolean _tmp25_;
		gboolean _tmp26_;
#line 236 "../lib/HideManager.vala"
		_tmp24_ = drag_manager;
#line 236 "../lib/HideManager.vala"
		_tmp25_ = plank_drag_manager_get_InternalDragActive (_tmp24_);
#line 236 "../lib/HideManager.vala"
		_tmp26_ = _tmp25_;
#line 236 "../lib/HideManager.vala"
		_tmp22_ = _tmp26_;
#line 783 "HideManager.c"
	}
#line 236 "../lib/HideManager.vala"
	if (_tmp22_) {
#line 236 "../lib/HideManager.vala"
		_tmp21_ = TRUE;
#line 789 "HideManager.c"
	} else {
		PlankDragManager* _tmp27_;
		gboolean _tmp28_;
		gboolean _tmp29_;
#line 236 "../lib/HideManager.vala"
		_tmp27_ = drag_manager;
#line 236 "../lib/HideManager.vala"
		_tmp28_ = plank_drag_manager_get_ExternalDragActive (_tmp27_);
#line 236 "../lib/HideManager.vala"
		_tmp29_ = _tmp28_;
#line 236 "../lib/HideManager.vala"
		_tmp21_ = _tmp29_;
#line 802 "HideManager.c"
	}
#line 236 "../lib/HideManager.vala"
	disabled = _tmp21_;
#line 237 "../lib/HideManager.vala"
	_tmp30_ = self->priv->_Disabled;
#line 237 "../lib/HideManager.vala"
	if (_tmp30_ != disabled) {
#line 238 "../lib/HideManager.vala"
		plank_hide_manager_set_Disabled (self, disabled);
#line 239 "../lib/HideManager.vala"
		update_needed = TRUE;
#line 814 "HideManager.c"
	}
#line 242 "../lib/HideManager.vala"
	if (update_needed) {
#line 243 "../lib/HideManager.vala"
		plank_hide_manager_update_hidden (self);
#line 820 "HideManager.c"
	}
#line 245 "../lib/HideManager.vala"
	g_object_thaw_notify ((GObject*) self);
#line 824 "HideManager.c"
}

static gboolean
___lambda50_ (PlankHideManager* self)
{
	gboolean result = FALSE;
#line 259 "../lib/HideManager.vala"
	plank_hide_manager_update_window_intersect (self);
#line 261 "../lib/HideManager.vala"
	plank_hide_manager_update_barrier (self);
#line 263 "../lib/HideManager.vala"
	self->priv->prefs_changed_timer_id = 0U;
#line 264 "../lib/HideManager.vala"
	result = FALSE;
#line 264 "../lib/HideManager.vala"
	return result;
#line 841 "HideManager.c"
}

static gboolean
____lambda50__gsource_func (gpointer self)
{
	gboolean result;
	result = ___lambda50_ ((PlankHideManager*) self);
#line 258 "../lib/HideManager.vala"
	return result;
#line 851 "HideManager.c"
}

static void
plank_hide_manager_prefs_changed (PlankHideManager* self,
                                  GObject* prefs,
                                  GParamSpec* prop)
{
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	GQuark _tmp3_ = 0U;
#line 250 "../lib/HideManager.vala"
	static GQuark _tmp2_label0 = 0;
#line 250 "../lib/HideManager.vala"
	static GQuark _tmp2_label1 = 0;
#line 250 "../lib/HideManager.vala"
	static GQuark _tmp2_label2 = 0;
#line 248 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 248 "../lib/HideManager.vala"
	g_return_if_fail (prefs != NULL);
#line 248 "../lib/HideManager.vala"
	g_return_if_fail (prop != NULL);
#line 250 "../lib/HideManager.vala"
	_tmp0_ = prop->name;
#line 250 "../lib/HideManager.vala"
	_tmp1_ = _tmp0_;
#line 250 "../lib/HideManager.vala"
	_tmp3_ = (NULL == _tmp1_) ? 0 : g_quark_from_string (_tmp1_);
#line 250 "../lib/HideManager.vala"
	if ((_tmp3_ == ((0 != _tmp2_label0) ? _tmp2_label0 : (_tmp2_label0 = g_quark_from_static_string ("HideMode")))) || (_tmp3_ == ((0 != _tmp2_label1) ? _tmp2_label1 : (_tmp2_label1 = g_quark_from_static_string ("Position"))))) {
#line 250 "../lib/HideManager.vala"
		switch (0) {
#line 884 "HideManager.c"
			default:
			{
#line 253 "../lib/HideManager.vala"
				if (self->priv->prefs_changed_timer_id > 0U) {
#line 254 "../lib/HideManager.vala"
					g_source_remove (self->priv->prefs_changed_timer_id);
#line 255 "../lib/HideManager.vala"
					self->priv->prefs_changed_timer_id = 0U;
#line 893 "HideManager.c"
				}
#line 258 "../lib/HideManager.vala"
				self->priv->prefs_changed_timer_id = gdk_threads_add_timeout (PLANK_HIDE_MANAGER_UPDATE_TIMEOUT, ____lambda50__gsource_func, self);
#line 266 "../lib/HideManager.vala"
				break;
#line 899 "HideManager.c"
			}
		}
	} else if (_tmp3_ == ((0 != _tmp2_label2) ? _tmp2_label2 : (_tmp2_label2 = g_quark_from_static_string ("PressureReveal")))) {
#line 250 "../lib/HideManager.vala"
		switch (0) {
#line 905 "HideManager.c"
			default:
			{
#line 269 "../lib/HideManager.vala"
				plank_hide_manager_update_barrier (self);
#line 271 "../lib/HideManager.vala"
				break;
#line 912 "HideManager.c"
			}
		}
	} else {
#line 250 "../lib/HideManager.vala"
		switch (0) {
#line 918 "HideManager.c"
			default:
			{
#line 274 "../lib/HideManager.vala"
				break;
#line 923 "HideManager.c"
			}
		}
	}
}

static void
plank_hide_manager_update_hidden (PlankHideManager* self)
{
	gboolean _tmp0_;
	PlankDockController* _tmp2_;
	PlankDockPreferences* _tmp3_;
	PlankDockPreferences* _tmp4_;
	PlankHideType _tmp5_;
	PlankHideType _tmp6_;
#line 278 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 280 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_Disabled;
#line 280 "../lib/HideManager.vala"
	if (_tmp0_) {
#line 944 "HideManager.c"
		gboolean _tmp1_;
#line 281 "../lib/HideManager.vala"
		_tmp1_ = self->priv->_Hidden;
#line 281 "../lib/HideManager.vala"
		if (_tmp1_) {
#line 282 "../lib/HideManager.vala"
			plank_hide_manager_set_Hidden (self, FALSE);
#line 952 "HideManager.c"
		}
#line 283 "../lib/HideManager.vala"
		return;
#line 956 "HideManager.c"
	}
#line 286 "../lib/HideManager.vala"
	_tmp2_ = self->priv->_controller;
#line 286 "../lib/HideManager.vala"
	_tmp3_ = plank_dock_controller_get_prefs (_tmp2_);
#line 286 "../lib/HideManager.vala"
	_tmp4_ = _tmp3_;
#line 286 "../lib/HideManager.vala"
	_tmp5_ = plank_dock_preferences_get_HideMode (_tmp4_);
#line 286 "../lib/HideManager.vala"
	_tmp6_ = _tmp5_;
#line 286 "../lib/HideManager.vala"
	switch (_tmp6_) {
#line 970 "HideManager.c"
		default:
#line 286 "../lib/HideManager.vala"
		case PLANK_HIDE_TYPE_NONE:
#line 974 "HideManager.c"
		{
#line 289 "../lib/HideManager.vala"
			plank_hide_manager_show (self);
#line 290 "../lib/HideManager.vala"
			break;
#line 980 "HideManager.c"
		}
#line 286 "../lib/HideManager.vala"
		case PLANK_HIDE_TYPE_INTELLIGENT:
#line 984 "HideManager.c"
		{
			gboolean _tmp7_ = FALSE;
			gboolean _tmp8_;
#line 293 "../lib/HideManager.vala"
			_tmp8_ = self->priv->_Hovered;
#line 293 "../lib/HideManager.vala"
			if (_tmp8_) {
#line 293 "../lib/HideManager.vala"
				_tmp7_ = TRUE;
#line 994 "HideManager.c"
			} else {
#line 293 "../lib/HideManager.vala"
				_tmp7_ = !self->priv->active_application_intersect;
#line 998 "HideManager.c"
			}
#line 293 "../lib/HideManager.vala"
			if (_tmp7_) {
#line 294 "../lib/HideManager.vala"
				plank_hide_manager_show (self);
#line 1004 "HideManager.c"
			} else {
#line 296 "../lib/HideManager.vala"
				plank_hide_manager_hide (self);
#line 1008 "HideManager.c"
			}
#line 297 "../lib/HideManager.vala"
			break;
#line 1012 "HideManager.c"
		}
#line 286 "../lib/HideManager.vala"
		case PLANK_HIDE_TYPE_AUTO:
#line 1016 "HideManager.c"
		{
			gboolean _tmp9_;
#line 300 "../lib/HideManager.vala"
			_tmp9_ = self->priv->_Hovered;
#line 300 "../lib/HideManager.vala"
			if (_tmp9_) {
#line 301 "../lib/HideManager.vala"
				plank_hide_manager_show (self);
#line 1025 "HideManager.c"
			} else {
#line 303 "../lib/HideManager.vala"
				plank_hide_manager_hide (self);
#line 1029 "HideManager.c"
			}
#line 304 "../lib/HideManager.vala"
			break;
#line 1033 "HideManager.c"
		}
#line 286 "../lib/HideManager.vala"
		case PLANK_HIDE_TYPE_DODGE_MAXIMIZED:
#line 1037 "HideManager.c"
		{
			gboolean _tmp10_ = FALSE;
			gboolean _tmp11_;
#line 307 "../lib/HideManager.vala"
			_tmp11_ = self->priv->_Hovered;
#line 307 "../lib/HideManager.vala"
			if (_tmp11_) {
#line 307 "../lib/HideManager.vala"
				_tmp10_ = TRUE;
#line 1047 "HideManager.c"
			} else {
				gboolean _tmp12_ = FALSE;
#line 307 "../lib/HideManager.vala"
				if (self->priv->active_maximized_window_intersect) {
#line 307 "../lib/HideManager.vala"
					_tmp12_ = TRUE;
#line 1054 "HideManager.c"
				} else {
#line 307 "../lib/HideManager.vala"
					_tmp12_ = self->priv->dialog_windows_intersect;
#line 1058 "HideManager.c"
				}
#line 307 "../lib/HideManager.vala"
				_tmp10_ = !_tmp12_;
#line 1062 "HideManager.c"
			}
#line 307 "../lib/HideManager.vala"
			if (_tmp10_) {
#line 308 "../lib/HideManager.vala"
				plank_hide_manager_show (self);
#line 1068 "HideManager.c"
			} else {
#line 310 "../lib/HideManager.vala"
				plank_hide_manager_hide (self);
#line 1072 "HideManager.c"
			}
#line 311 "../lib/HideManager.vala"
			break;
#line 1076 "HideManager.c"
		}
#line 286 "../lib/HideManager.vala"
		case PLANK_HIDE_TYPE_WINDOW_DODGE:
#line 1080 "HideManager.c"
		{
			gboolean _tmp13_ = FALSE;
			gboolean _tmp14_;
#line 314 "../lib/HideManager.vala"
			_tmp14_ = self->priv->_Hovered;
#line 314 "../lib/HideManager.vala"
			if (_tmp14_) {
#line 314 "../lib/HideManager.vala"
				_tmp13_ = TRUE;
#line 1090 "HideManager.c"
			} else {
#line 314 "../lib/HideManager.vala"
				_tmp13_ = !self->priv->window_intersect;
#line 1094 "HideManager.c"
			}
#line 314 "../lib/HideManager.vala"
			if (_tmp13_) {
#line 315 "../lib/HideManager.vala"
				plank_hide_manager_show (self);
#line 1100 "HideManager.c"
			} else {
#line 317 "../lib/HideManager.vala"
				plank_hide_manager_hide (self);
#line 1104 "HideManager.c"
			}
#line 318 "../lib/HideManager.vala"
			break;
#line 1108 "HideManager.c"
		}
#line 286 "../lib/HideManager.vala"
		case PLANK_HIDE_TYPE_DODGE_ACTIVE:
#line 1112 "HideManager.c"
		{
			gboolean _tmp15_ = FALSE;
			gboolean _tmp16_;
#line 321 "../lib/HideManager.vala"
			_tmp16_ = self->priv->_Hovered;
#line 321 "../lib/HideManager.vala"
			if (_tmp16_) {
#line 321 "../lib/HideManager.vala"
				_tmp15_ = TRUE;
#line 1122 "HideManager.c"
			} else {
#line 321 "../lib/HideManager.vala"
				_tmp15_ = !self->priv->active_window_intersect;
#line 1126 "HideManager.c"
			}
#line 321 "../lib/HideManager.vala"
			if (_tmp15_) {
#line 322 "../lib/HideManager.vala"
				plank_hide_manager_show (self);
#line 1132 "HideManager.c"
			} else {
#line 324 "../lib/HideManager.vala"
				plank_hide_manager_hide (self);
#line 1136 "HideManager.c"
			}
#line 325 "../lib/HideManager.vala"
			break;
#line 1140 "HideManager.c"
		}
	}
#line 327 "../lib/HideManager.vala"
	self->priv->pointer_update = TRUE;
#line 1145 "HideManager.c"
}

static gboolean
__lambda12_ (PlankHideManager* self)
{
	gboolean _tmp0_;
	gboolean result = FALSE;
#line 350 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_Hidden;
#line 350 "../lib/HideManager.vala"
	if (!_tmp0_) {
#line 351 "../lib/HideManager.vala"
		plank_hide_manager_set_Hidden (self, TRUE);
#line 1159 "HideManager.c"
	}
#line 352 "../lib/HideManager.vala"
	self->priv->hide_timer_id = 0U;
#line 353 "../lib/HideManager.vala"
	result = FALSE;
#line 353 "../lib/HideManager.vala"
	return result;
#line 1167 "HideManager.c"
}

static gboolean
___lambda12__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda12_ ((PlankHideManager*) self);
#line 349 "../lib/HideManager.vala"
	return result;
#line 1177 "HideManager.c"
}

static void
plank_hide_manager_hide (PlankHideManager* self)
{
	gboolean _tmp0_;
	PlankDockController* _tmp1_;
	PlankDockPreferences* _tmp2_;
	PlankDockPreferences* _tmp3_;
	guint _tmp4_;
	guint _tmp5_;
	PlankDockController* _tmp7_;
	PlankDockPreferences* _tmp8_;
	PlankDockPreferences* _tmp9_;
	guint _tmp10_;
	guint _tmp11_;
#line 330 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 332 "../lib/HideManager.vala"
	if (self->priv->unhide_timer_id > 0U) {
#line 333 "../lib/HideManager.vala"
		g_source_remove (self->priv->unhide_timer_id);
#line 334 "../lib/HideManager.vala"
		self->priv->unhide_timer_id = 0U;
#line 1202 "HideManager.c"
	}
#line 337 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_Hidden;
#line 337 "../lib/HideManager.vala"
	if (_tmp0_) {
#line 338 "../lib/HideManager.vala"
		return;
#line 1210 "HideManager.c"
	}
#line 340 "../lib/HideManager.vala"
	_tmp1_ = self->priv->_controller;
#line 340 "../lib/HideManager.vala"
	_tmp2_ = plank_dock_controller_get_prefs (_tmp1_);
#line 340 "../lib/HideManager.vala"
	_tmp3_ = _tmp2_;
#line 340 "../lib/HideManager.vala"
	_tmp4_ = plank_dock_preferences_get_HideDelay (_tmp3_);
#line 340 "../lib/HideManager.vala"
	_tmp5_ = _tmp4_;
#line 340 "../lib/HideManager.vala"
	if (_tmp5_ == 0U) {
#line 1224 "HideManager.c"
		gboolean _tmp6_;
#line 341 "../lib/HideManager.vala"
		_tmp6_ = self->priv->_Hidden;
#line 341 "../lib/HideManager.vala"
		if (!_tmp6_) {
#line 342 "../lib/HideManager.vala"
			plank_hide_manager_set_Hidden (self, TRUE);
#line 1232 "HideManager.c"
		}
#line 343 "../lib/HideManager.vala"
		return;
#line 1236 "HideManager.c"
	}
#line 346 "../lib/HideManager.vala"
	if (self->priv->hide_timer_id > 0U) {
#line 347 "../lib/HideManager.vala"
		return;
#line 1242 "HideManager.c"
	}
#line 349 "../lib/HideManager.vala"
	_tmp7_ = self->priv->_controller;
#line 349 "../lib/HideManager.vala"
	_tmp8_ = plank_dock_controller_get_prefs (_tmp7_);
#line 349 "../lib/HideManager.vala"
	_tmp9_ = _tmp8_;
#line 349 "../lib/HideManager.vala"
	_tmp10_ = plank_dock_preferences_get_HideDelay (_tmp9_);
#line 349 "../lib/HideManager.vala"
	_tmp11_ = _tmp10_;
#line 349 "../lib/HideManager.vala"
	self->priv->hide_timer_id = gdk_threads_add_timeout (_tmp11_, ___lambda12__gsource_func, self);
#line 1256 "HideManager.c"
}

static gboolean
__lambda11_ (PlankHideManager* self)
{
	gboolean _tmp0_;
	gboolean result = FALSE;
#line 377 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_Hidden;
#line 377 "../lib/HideManager.vala"
	if (_tmp0_) {
#line 378 "../lib/HideManager.vala"
		plank_hide_manager_set_Hidden (self, FALSE);
#line 1270 "HideManager.c"
	}
#line 379 "../lib/HideManager.vala"
	self->priv->unhide_timer_id = 0U;
#line 380 "../lib/HideManager.vala"
	result = FALSE;
#line 380 "../lib/HideManager.vala"
	return result;
#line 1278 "HideManager.c"
}

static gboolean
___lambda11__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda11_ ((PlankHideManager*) self);
#line 376 "../lib/HideManager.vala"
	return result;
#line 1288 "HideManager.c"
}

static void
plank_hide_manager_show (PlankHideManager* self)
{
	gboolean _tmp0_;
	gboolean _tmp1_ = FALSE;
	PlankDockController* _tmp8_;
	PlankDockPreferences* _tmp9_;
	PlankDockPreferences* _tmp10_;
	guint _tmp11_;
	guint _tmp12_;
#line 357 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 359 "../lib/HideManager.vala"
	if (self->priv->hide_timer_id > 0U) {
#line 360 "../lib/HideManager.vala"
		g_source_remove (self->priv->hide_timer_id);
#line 361 "../lib/HideManager.vala"
		self->priv->hide_timer_id = 0U;
#line 1309 "HideManager.c"
	}
#line 364 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_Hidden;
#line 364 "../lib/HideManager.vala"
	if (!_tmp0_) {
#line 365 "../lib/HideManager.vala"
		return;
#line 1317 "HideManager.c"
	}
#line 367 "../lib/HideManager.vala"
	if (!self->priv->pointer_update) {
#line 367 "../lib/HideManager.vala"
		_tmp1_ = TRUE;
#line 1323 "HideManager.c"
	} else {
		PlankDockController* _tmp2_;
		PlankDockPreferences* _tmp3_;
		PlankDockPreferences* _tmp4_;
		guint _tmp5_;
		guint _tmp6_;
#line 367 "../lib/HideManager.vala"
		_tmp2_ = self->priv->_controller;
#line 367 "../lib/HideManager.vala"
		_tmp3_ = plank_dock_controller_get_prefs (_tmp2_);
#line 367 "../lib/HideManager.vala"
		_tmp4_ = _tmp3_;
#line 367 "../lib/HideManager.vala"
		_tmp5_ = plank_dock_preferences_get_UnhideDelay (_tmp4_);
#line 367 "../lib/HideManager.vala"
		_tmp6_ = _tmp5_;
#line 367 "../lib/HideManager.vala"
		_tmp1_ = _tmp6_ == 0U;
#line 1342 "HideManager.c"
	}
#line 367 "../lib/HideManager.vala"
	if (_tmp1_) {
#line 1346 "HideManager.c"
		gboolean _tmp7_;
#line 368 "../lib/HideManager.vala"
		_tmp7_ = self->priv->_Hidden;
#line 368 "../lib/HideManager.vala"
		if (_tmp7_) {
#line 369 "../lib/HideManager.vala"
			plank_hide_manager_set_Hidden (self, FALSE);
#line 1354 "HideManager.c"
		}
#line 370 "../lib/HideManager.vala"
		return;
#line 1358 "HideManager.c"
	}
#line 373 "../lib/HideManager.vala"
	if (self->priv->unhide_timer_id > 0U) {
#line 374 "../lib/HideManager.vala"
		return;
#line 1364 "HideManager.c"
	}
#line 376 "../lib/HideManager.vala"
	_tmp8_ = self->priv->_controller;
#line 376 "../lib/HideManager.vala"
	_tmp9_ = plank_dock_controller_get_prefs (_tmp8_);
#line 376 "../lib/HideManager.vala"
	_tmp10_ = _tmp9_;
#line 376 "../lib/HideManager.vala"
	_tmp11_ = plank_dock_preferences_get_UnhideDelay (_tmp10_);
#line 376 "../lib/HideManager.vala"
	_tmp12_ = _tmp11_;
#line 376 "../lib/HideManager.vala"
	self->priv->unhide_timer_id = gdk_threads_add_timeout (_tmp12_, ___lambda11__gsource_func, self);
#line 1378 "HideManager.c"
}

static gboolean
plank_hide_manager_handle_enter_notify_event (GtkWidget* widget,
                                              GdkEventCrossing* event,
                                              PlankHideManager* self)
{
	GdkNotifyType _tmp0_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp5_;
	gboolean _tmp13_;
	gboolean _tmp14_;
	gboolean result = FALSE;
#line 385 "../lib/HideManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 385 "../lib/HideManager.vala"
	g_return_val_if_fail (widget != NULL, FALSE);
#line 385 "../lib/HideManager.vala"
	g_return_val_if_fail (event != NULL, FALSE);
#line 387 "../lib/HideManager.vala"
	_tmp0_ = event->detail;
#line 387 "../lib/HideManager.vala"
	if (_tmp0_ == GDK_NOTIFY_INFERIOR) {
#line 1404 "HideManager.c"
		gboolean _tmp1_;
#line 388 "../lib/HideManager.vala"
		_tmp1_ = self->priv->_Hidden;
#line 388 "../lib/HideManager.vala"
		result = _tmp1_;
#line 388 "../lib/HideManager.vala"
		return result;
#line 1412 "HideManager.c"
	}
#line 391 "../lib/HideManager.vala"
	_tmp5_ = self->priv->_Hidden;
#line 391 "../lib/HideManager.vala"
	if (_tmp5_) {
#line 391 "../lib/HideManager.vala"
		_tmp4_ = self->priv->barriers_supported;
#line 1420 "HideManager.c"
	} else {
#line 391 "../lib/HideManager.vala"
		_tmp4_ = FALSE;
#line 1424 "HideManager.c"
	}
#line 391 "../lib/HideManager.vala"
	if (_tmp4_) {
#line 1428 "HideManager.c"
		PlankDockController* _tmp6_;
		PlankDockPreferences* _tmp7_;
		PlankDockPreferences* _tmp8_;
		gboolean _tmp9_;
		gboolean _tmp10_;
#line 392 "../lib/HideManager.vala"
		_tmp6_ = self->priv->_controller;
#line 392 "../lib/HideManager.vala"
		_tmp7_ = plank_dock_controller_get_prefs (_tmp6_);
#line 392 "../lib/HideManager.vala"
		_tmp8_ = _tmp7_;
#line 392 "../lib/HideManager.vala"
		_tmp9_ = plank_dock_preferences_get_PressureReveal (_tmp8_);
#line 392 "../lib/HideManager.vala"
		_tmp10_ = _tmp9_;
#line 392 "../lib/HideManager.vala"
		_tmp3_ = _tmp10_;
#line 1446 "HideManager.c"
	} else {
#line 391 "../lib/HideManager.vala"
		_tmp3_ = FALSE;
#line 1450 "HideManager.c"
	}
#line 391 "../lib/HideManager.vala"
	if (_tmp3_) {
#line 1454 "HideManager.c"
		GdkDevice* _tmp11_;
#line 393 "../lib/HideManager.vala"
		_tmp11_ = gdk_event_get_source_device ((GdkEvent*) event);
#line 393 "../lib/HideManager.vala"
		_tmp2_ = plank_hide_manager_device_supports_pressure (self, _tmp11_);
#line 1460 "HideManager.c"
	} else {
#line 391 "../lib/HideManager.vala"
		_tmp2_ = FALSE;
#line 1464 "HideManager.c"
	}
#line 391 "../lib/HideManager.vala"
	if (_tmp2_) {
#line 1468 "HideManager.c"
		gboolean _tmp12_;
#line 394 "../lib/HideManager.vala"
		_tmp12_ = self->priv->_Hidden;
#line 394 "../lib/HideManager.vala"
		result = _tmp12_;
#line 394 "../lib/HideManager.vala"
		return result;
#line 1476 "HideManager.c"
	}
#line 397 "../lib/HideManager.vala"
	_tmp13_ = self->priv->_Hovered;
#line 397 "../lib/HideManager.vala"
	if (!_tmp13_) {
#line 398 "../lib/HideManager.vala"
		plank_hide_manager_update_hovered_with_coords (self, (gint) event->x, (gint) event->y);
#line 1484 "HideManager.c"
	}
#line 400 "../lib/HideManager.vala"
	_tmp14_ = self->priv->_Hidden;
#line 400 "../lib/HideManager.vala"
	result = _tmp14_;
#line 400 "../lib/HideManager.vala"
	return result;
#line 1492 "HideManager.c"
}

static gboolean
plank_hide_manager_handle_leave_notify_event (GtkWidget* widget,
                                              GdkEventCrossing* event,
                                              PlankHideManager* self)
{
	GdkNotifyType _tmp0_;
	gboolean _tmp1_;
	gboolean result = FALSE;
#line 404 "../lib/HideManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 404 "../lib/HideManager.vala"
	g_return_val_if_fail (widget != NULL, FALSE);
#line 404 "../lib/HideManager.vala"
	g_return_val_if_fail (event != NULL, FALSE);
#line 406 "../lib/HideManager.vala"
	_tmp0_ = event->detail;
#line 406 "../lib/HideManager.vala"
	if (_tmp0_ == GDK_NOTIFY_INFERIOR) {
#line 407 "../lib/HideManager.vala"
		result = GDK_EVENT_PROPAGATE;
#line 407 "../lib/HideManager.vala"
		return result;
#line 1517 "HideManager.c"
	}
#line 410 "../lib/HideManager.vala"
	if ((gboolean) event->send_event) {
#line 411 "../lib/HideManager.vala"
		result = GDK_EVENT_PROPAGATE;
#line 411 "../lib/HideManager.vala"
		return result;
#line 1525 "HideManager.c"
	}
#line 413 "../lib/HideManager.vala"
	_tmp1_ = self->priv->_Hovered;
#line 413 "../lib/HideManager.vala"
	if (_tmp1_) {
#line 414 "../lib/HideManager.vala"
		plank_hide_manager_update_hovered_with_coords (self, -1, -1);
#line 1533 "HideManager.c"
	}
#line 416 "../lib/HideManager.vala"
	result = GDK_EVENT_PROPAGATE;
#line 416 "../lib/HideManager.vala"
	return result;
#line 1539 "HideManager.c"
}

static inline gboolean
plank_hide_manager_device_supports_pressure (PlankHideManager* self,
                                             GdkDevice* device)
{
	gboolean _tmp0_ = FALSE;
	GdkInputSource _tmp1_;
	GdkInputSource _tmp2_;
	gboolean result = FALSE;
#line 419 "../lib/HideManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 419 "../lib/HideManager.vala"
	g_return_val_if_fail (device != NULL, FALSE);
#line 421 "../lib/HideManager.vala"
	g_object_get (device, "input-source", &_tmp1_, NULL);
#line 421 "../lib/HideManager.vala"
	_tmp2_ = _tmp1_;
#line 421 "../lib/HideManager.vala"
	if (_tmp2_ == GDK_SOURCE_MOUSE) {
#line 421 "../lib/HideManager.vala"
		_tmp0_ = TRUE;
#line 1562 "HideManager.c"
	} else {
		GdkInputSource _tmp3_;
		GdkInputSource _tmp4_;
#line 422 "../lib/HideManager.vala"
		g_object_get (device, "input-source", &_tmp3_, NULL);
#line 422 "../lib/HideManager.vala"
		_tmp4_ = _tmp3_;
#line 422 "../lib/HideManager.vala"
		_tmp0_ = _tmp4_ == GDK_SOURCE_TOUCHPAD;
#line 1572 "HideManager.c"
	}
#line 421 "../lib/HideManager.vala"
	result = _tmp0_;
#line 421 "../lib/HideManager.vala"
	return result;
#line 1578 "HideManager.c"
}

static gpointer
_g_object_ref0 (gpointer self)
{
#line 451 "../lib/HideManager.vala"
	return self ? g_object_ref (self) : NULL;
#line 1586 "HideManager.c"
}

static void
plank_hide_manager_update_window_intersect (PlankHideManager* self)
{
	GdkRectangle dock_rect = {0};
	PlankDockController* _tmp0_;
	PlankPositionManager* _tmp1_;
	PlankPositionManager* _tmp2_;
	GdkRectangle _tmp3_ = {0};
	gint window_scale_factor = 0;
	PlankDockController* _tmp4_;
	PlankDockWindow* _tmp5_;
	PlankDockWindow* _tmp6_;
	GdkWindow* _tmp7_;
	gboolean intersect = FALSE;
	gboolean dialog_intersect = FALSE;
	gboolean active_intersect = FALSE;
	gboolean new_active_window_intersect = FALSE;
	gboolean active_maximized_intersect = FALSE;
	WnckScreen* screen = NULL;
	WnckScreen* _tmp8_;
	WnckWindow* active_window = NULL;
	WnckScreen* _tmp9_;
	WnckWindow* _tmp10_;
	WnckWorkspace* active_workspace = NULL;
	WnckScreen* _tmp11_;
	WnckWorkspace* _tmp12_;
	gboolean _tmp13_ = FALSE;
	WnckWindow* _tmp14_;
#line 429 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 431 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_controller;
#line 431 "../lib/HideManager.vala"
	_tmp1_ = plank_dock_controller_get_position_manager (_tmp0_);
#line 431 "../lib/HideManager.vala"
	_tmp2_ = _tmp1_;
#line 431 "../lib/HideManager.vala"
	plank_position_manager_get_static_dock_region (_tmp2_, &_tmp3_);
#line 431 "../lib/HideManager.vala"
	dock_rect = _tmp3_;
#line 432 "../lib/HideManager.vala"
	_tmp4_ = self->priv->_controller;
#line 432 "../lib/HideManager.vala"
	_tmp5_ = plank_dock_controller_get_window (_tmp4_);
#line 432 "../lib/HideManager.vala"
	_tmp6_ = _tmp5_;
#line 432 "../lib/HideManager.vala"
	_tmp7_ = gtk_widget_get_window ((GtkWidget*) _tmp6_);
#line 432 "../lib/HideManager.vala"
	window_scale_factor = gdk_window_get_scale_factor (_tmp7_);
#line 433 "../lib/HideManager.vala"
	if (window_scale_factor > 1) {
#line 434 "../lib/HideManager.vala"
		dock_rect.x = dock_rect.x * window_scale_factor;
#line 435 "../lib/HideManager.vala"
		dock_rect.y = dock_rect.y * window_scale_factor;
#line 436 "../lib/HideManager.vala"
		dock_rect.width = dock_rect.width * window_scale_factor;
#line 437 "../lib/HideManager.vala"
		dock_rect.height = dock_rect.height * window_scale_factor;
#line 1649 "HideManager.c"
	}
#line 440 "../lib/HideManager.vala"
	intersect = FALSE;
#line 441 "../lib/HideManager.vala"
	dialog_intersect = FALSE;
#line 442 "../lib/HideManager.vala"
	active_intersect = FALSE;
#line 443 "../lib/HideManager.vala"
	new_active_window_intersect = FALSE;
#line 444 "../lib/HideManager.vala"
	active_maximized_intersect = FALSE;
#line 445 "../lib/HideManager.vala"
	_tmp8_ = wnck_screen_get_default ();
#line 445 "../lib/HideManager.vala"
	screen = _tmp8_;
#line 446 "../lib/HideManager.vala"
	_tmp9_ = screen;
#line 446 "../lib/HideManager.vala"
	_tmp10_ = wnck_screen_get_active_window (_tmp9_);
#line 446 "../lib/HideManager.vala"
	active_window = _tmp10_;
#line 447 "../lib/HideManager.vala"
	_tmp11_ = screen;
#line 447 "../lib/HideManager.vala"
	_tmp12_ = wnck_screen_get_active_workspace (_tmp11_);
#line 447 "../lib/HideManager.vala"
	active_workspace = _tmp12_;
#line 449 "../lib/HideManager.vala"
	_tmp14_ = active_window;
#line 449 "../lib/HideManager.vala"
	if (_tmp14_ != NULL) {
#line 1681 "HideManager.c"
		WnckWorkspace* _tmp15_;
#line 449 "../lib/HideManager.vala"
		_tmp15_ = active_workspace;
#line 449 "../lib/HideManager.vala"
		_tmp13_ = _tmp15_ != NULL;
#line 1687 "HideManager.c"
	} else {
#line 449 "../lib/HideManager.vala"
		_tmp13_ = FALSE;
#line 1691 "HideManager.c"
	}
#line 449 "../lib/HideManager.vala"
	if (_tmp13_) {
#line 1695 "HideManager.c"
		gint active_pid = 0;
		WnckWindow* _tmp16_;
		WnckScreen* _tmp17_;
		GList* _tmp18_;
#line 450 "../lib/HideManager.vala"
		_tmp16_ = active_window;
#line 450 "../lib/HideManager.vala"
		active_pid = wnck_window_get_pid (_tmp16_);
#line 451 "../lib/HideManager.vala"
		_tmp17_ = screen;
#line 451 "../lib/HideManager.vala"
		_tmp18_ = wnck_screen_get_windows (_tmp17_);
#line 1708 "HideManager.c"
		{
			GList* w_collection = NULL;
			GList* w_it = NULL;
#line 451 "../lib/HideManager.vala"
			w_collection = _tmp18_;
#line 451 "../lib/HideManager.vala"
			for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
#line 1716 "HideManager.c"
				WnckWindow* _tmp19_;
				WnckWindow* w = NULL;
#line 451 "../lib/HideManager.vala"
				_tmp19_ = _g_object_ref0 ((WnckWindow*) w_it->data);
#line 451 "../lib/HideManager.vala"
				w = _tmp19_;
#line 1723 "HideManager.c"
				{
					WnckWindow* _tmp20_;
					WnckWindowType type = 0;
					WnckWindow* _tmp21_;
					gboolean _tmp22_ = FALSE;
					gboolean _tmp23_ = FALSE;
					gboolean _tmp24_ = FALSE;
					WnckWindowType _tmp25_;
					WnckWindow* _tmp29_;
					WnckWorkspace* _tmp30_;
					gint pid = 0;
					WnckWindow* _tmp31_;
					WnckWindow* _tmp32_;
					GdkRectangle _tmp33_ = {0};
					GdkRectangle _tmp34_;
#line 452 "../lib/HideManager.vala"
					_tmp20_ = w;
#line 452 "../lib/HideManager.vala"
					if (wnck_window_is_minimized (_tmp20_)) {
#line 453 "../lib/HideManager.vala"
						_g_object_unref0 (w);
#line 453 "../lib/HideManager.vala"
						continue;
#line 1747 "HideManager.c"
					}
#line 454 "../lib/HideManager.vala"
					_tmp21_ = w;
#line 454 "../lib/HideManager.vala"
					type = wnck_window_get_window_type (_tmp21_);
#line 455 "../lib/HideManager.vala"
					_tmp25_ = type;
#line 455 "../lib/HideManager.vala"
					if (_tmp25_ == WNCK_WINDOW_DESKTOP) {
#line 455 "../lib/HideManager.vala"
						_tmp24_ = TRUE;
#line 1759 "HideManager.c"
					} else {
						WnckWindowType _tmp26_;
#line 455 "../lib/HideManager.vala"
						_tmp26_ = type;
#line 455 "../lib/HideManager.vala"
						_tmp24_ = _tmp26_ == WNCK_WINDOW_DOCK;
#line 1766 "HideManager.c"
					}
#line 455 "../lib/HideManager.vala"
					if (_tmp24_) {
#line 455 "../lib/HideManager.vala"
						_tmp23_ = TRUE;
#line 1772 "HideManager.c"
					} else {
						WnckWindowType _tmp27_;
#line 456 "../lib/HideManager.vala"
						_tmp27_ = type;
#line 456 "../lib/HideManager.vala"
						_tmp23_ = _tmp27_ == WNCK_WINDOW_MENU;
#line 1779 "HideManager.c"
					}
#line 455 "../lib/HideManager.vala"
					if (_tmp23_) {
#line 455 "../lib/HideManager.vala"
						_tmp22_ = TRUE;
#line 1785 "HideManager.c"
					} else {
						WnckWindowType _tmp28_;
#line 456 "../lib/HideManager.vala"
						_tmp28_ = type;
#line 456 "../lib/HideManager.vala"
						_tmp22_ = _tmp28_ == WNCK_WINDOW_SPLASHSCREEN;
#line 1792 "HideManager.c"
					}
#line 455 "../lib/HideManager.vala"
					if (_tmp22_) {
#line 457 "../lib/HideManager.vala"
						_g_object_unref0 (w);
#line 457 "../lib/HideManager.vala"
						continue;
#line 1800 "HideManager.c"
					}
#line 458 "../lib/HideManager.vala"
					_tmp29_ = w;
#line 458 "../lib/HideManager.vala"
					_tmp30_ = active_workspace;
#line 458 "../lib/HideManager.vala"
					if (!wnck_window_is_visible_on_workspace (_tmp29_, _tmp30_)) {
#line 459 "../lib/HideManager.vala"
						_g_object_unref0 (w);
#line 459 "../lib/HideManager.vala"
						continue;
#line 1812 "HideManager.c"
					}
#line 460 "../lib/HideManager.vala"
					_tmp31_ = w;
#line 460 "../lib/HideManager.vala"
					pid = wnck_window_get_pid (_tmp31_);
#line 461 "../lib/HideManager.vala"
					if (pid == plank_hide_manager_plank_pid) {
#line 462 "../lib/HideManager.vala"
						_g_object_unref0 (w);
#line 462 "../lib/HideManager.vala"
						continue;
#line 1824 "HideManager.c"
					}
#line 464 "../lib/HideManager.vala"
					_tmp32_ = w;
#line 464 "../lib/HideManager.vala"
					plank_hide_manager_window_geometry (_tmp32_, &_tmp33_);
#line 464 "../lib/HideManager.vala"
					_tmp34_ = dock_rect;
#line 464 "../lib/HideManager.vala"
					if (gdk_rectangle_intersect (&_tmp33_, &_tmp34_, NULL)) {
#line 1834 "HideManager.c"
						gboolean _tmp35_ = FALSE;
						gboolean _tmp38_ = FALSE;
						gboolean _tmp47_ = FALSE;
						gboolean _tmp49_ = FALSE;
#line 465 "../lib/HideManager.vala"
						intersect = TRUE;
#line 467 "../lib/HideManager.vala"
						if (pid != active_pid) {
#line 468 "../lib/HideManager.vala"
							_g_object_unref0 (w);
#line 468 "../lib/HideManager.vala"
							continue;
#line 1847 "HideManager.c"
						}
#line 470 "../lib/HideManager.vala"
						active_intersect = TRUE;
#line 472 "../lib/HideManager.vala"
						if (new_active_window_intersect) {
#line 472 "../lib/HideManager.vala"
							_tmp35_ = TRUE;
#line 1855 "HideManager.c"
						} else {
							WnckWindow* _tmp36_;
							WnckWindow* _tmp37_;
#line 472 "../lib/HideManager.vala"
							_tmp36_ = active_window;
#line 472 "../lib/HideManager.vala"
							_tmp37_ = w;
#line 472 "../lib/HideManager.vala"
							_tmp35_ = _tmp36_ == _tmp37_;
#line 1865 "HideManager.c"
						}
#line 472 "../lib/HideManager.vala"
						new_active_window_intersect = _tmp35_;
#line 474 "../lib/HideManager.vala"
						if (active_maximized_intersect) {
#line 474 "../lib/HideManager.vala"
							_tmp38_ = TRUE;
#line 1873 "HideManager.c"
						} else {
							gboolean _tmp39_ = FALSE;
							WnckWindow* _tmp40_;
							WnckWindow* _tmp41_;
#line 474 "../lib/HideManager.vala"
							_tmp40_ = active_window;
#line 474 "../lib/HideManager.vala"
							_tmp41_ = w;
#line 474 "../lib/HideManager.vala"
							if (_tmp40_ == _tmp41_) {
#line 1884 "HideManager.c"
								gboolean _tmp42_ = FALSE;
								gboolean _tmp43_ = FALSE;
								WnckWindow* _tmp44_;
#line 475 "../lib/HideManager.vala"
								_tmp44_ = w;
#line 475 "../lib/HideManager.vala"
								if (wnck_window_is_maximized (_tmp44_)) {
#line 475 "../lib/HideManager.vala"
									_tmp43_ = TRUE;
#line 1894 "HideManager.c"
								} else {
									WnckWindow* _tmp45_;
#line 475 "../lib/HideManager.vala"
									_tmp45_ = w;
#line 475 "../lib/HideManager.vala"
									_tmp43_ = wnck_window_is_maximized_vertically (_tmp45_);
#line 1901 "HideManager.c"
								}
#line 475 "../lib/HideManager.vala"
								if (_tmp43_) {
#line 475 "../lib/HideManager.vala"
									_tmp42_ = TRUE;
#line 1907 "HideManager.c"
								} else {
									WnckWindow* _tmp46_;
#line 475 "../lib/HideManager.vala"
									_tmp46_ = w;
#line 475 "../lib/HideManager.vala"
									_tmp42_ = wnck_window_is_maximized_horizontally (_tmp46_);
#line 1914 "HideManager.c"
								}
#line 475 "../lib/HideManager.vala"
								_tmp39_ = _tmp42_;
#line 1918 "HideManager.c"
							} else {
#line 474 "../lib/HideManager.vala"
								_tmp39_ = FALSE;
#line 1922 "HideManager.c"
							}
#line 474 "../lib/HideManager.vala"
							_tmp38_ = _tmp39_;
#line 1926 "HideManager.c"
						}
#line 474 "../lib/HideManager.vala"
						active_maximized_intersect = _tmp38_;
#line 477 "../lib/HideManager.vala"
						if (dialog_intersect) {
#line 477 "../lib/HideManager.vala"
							_tmp47_ = TRUE;
#line 1934 "HideManager.c"
						} else {
							WnckWindowType _tmp48_;
#line 477 "../lib/HideManager.vala"
							_tmp48_ = type;
#line 477 "../lib/HideManager.vala"
							_tmp47_ = _tmp48_ == WNCK_WINDOW_DIALOG;
#line 1941 "HideManager.c"
						}
#line 477 "../lib/HideManager.vala"
						dialog_intersect = _tmp47_;
#line 479 "../lib/HideManager.vala"
						if (active_maximized_intersect) {
#line 479 "../lib/HideManager.vala"
							_tmp49_ = dialog_intersect;
#line 1949 "HideManager.c"
						} else {
#line 479 "../lib/HideManager.vala"
							_tmp49_ = FALSE;
#line 1953 "HideManager.c"
						}
#line 479 "../lib/HideManager.vala"
						if (_tmp49_) {
#line 480 "../lib/HideManager.vala"
							_g_object_unref0 (w);
#line 480 "../lib/HideManager.vala"
							break;
#line 1961 "HideManager.c"
						}
					}
#line 451 "../lib/HideManager.vala"
					_g_object_unref0 (w);
#line 1966 "HideManager.c"
				}
			}
		}
	}
#line 485 "../lib/HideManager.vala"
	self->priv->window_intersect = intersect;
#line 486 "../lib/HideManager.vala"
	self->priv->dialog_windows_intersect = dialog_intersect;
#line 487 "../lib/HideManager.vala"
	self->priv->active_application_intersect = active_intersect;
#line 488 "../lib/HideManager.vala"
	self->priv->active_window_intersect = new_active_window_intersect;
#line 489 "../lib/HideManager.vala"
	self->priv->active_maximized_window_intersect = active_maximized_intersect;
#line 491 "../lib/HideManager.vala"
	self->priv->pointer_update = FALSE;
#line 492 "../lib/HideManager.vala"
	plank_hide_manager_update_hidden (self);
#line 1985 "HideManager.c"
}

static gboolean
__lambda48_ (PlankHideManager* self)
{
	gboolean result = FALSE;
#line 501 "../lib/HideManager.vala"
	plank_hide_manager_update_window_intersect (self);
#line 502 "../lib/HideManager.vala"
	self->priv->window_changed_timer_id = 0U;
#line 503 "../lib/HideManager.vala"
	result = FALSE;
#line 503 "../lib/HideManager.vala"
	return result;
#line 2000 "HideManager.c"
}

static gboolean
___lambda48__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda48_ ((PlankHideManager*) self);
#line 500 "../lib/HideManager.vala"
	return result;
#line 2010 "HideManager.c"
}

static void
plank_hide_manager_schedule_update (PlankHideManager* self)
{
#line 495 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 497 "../lib/HideManager.vala"
	if (self->priv->window_changed_timer_id > 0U) {
#line 498 "../lib/HideManager.vala"
		return;
#line 2022 "HideManager.c"
	}
#line 500 "../lib/HideManager.vala"
	self->priv->window_changed_timer_id = gdk_threads_add_timeout (PLANK_HIDE_MANAGER_UPDATE_TIMEOUT, ___lambda48__gsource_func, self);
#line 2026 "HideManager.c"
}

static void
plank_hide_manager_handle_workspace_changed (WnckScreen* screen,
                                             WnckWorkspace* previous,
                                             PlankHideManager* self)
{
#line 508 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 508 "../lib/HideManager.vala"
	g_return_if_fail (screen != NULL);
#line 510 "../lib/HideManager.vala"
	plank_hide_manager_schedule_update (self);
#line 2040 "HideManager.c"
}

static void
_plank_hide_manager_handle_geometry_changed_wnck_window_geometry_changed (WnckWindow* _sender,
                                                                          gpointer self)
{
#line 517 "../lib/HideManager.vala"
	plank_hide_manager_handle_geometry_changed (_sender, (PlankHideManager*) self);
#line 2049 "HideManager.c"
}

static void
_plank_hide_manager_handle_state_changed_wnck_window_state_changed (WnckWindow* _sender,
                                                                    WnckWindowState changed_mask,
                                                                    WnckWindowState new_state,
                                                                    gpointer self)
{
#line 518 "../lib/HideManager.vala"
	plank_hide_manager_handle_state_changed (_sender, changed_mask, new_state, (PlankHideManager*) self);
#line 2060 "HideManager.c"
}

static void
plank_hide_manager_handle_active_window_changed (WnckScreen* screen,
                                                 WnckWindow* previous,
                                                 PlankHideManager* self)
{
#line 514 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 514 "../lib/HideManager.vala"
	g_return_if_fail (screen != NULL);
#line 516 "../lib/HideManager.vala"
	if (previous != NULL) {
#line 2074 "HideManager.c"
		guint _tmp0_;
		guint _tmp1_;
#line 517 "../lib/HideManager.vala"
		g_signal_parse_name ("geometry-changed", wnck_window_get_type (), &_tmp0_, NULL, FALSE);
#line 517 "../lib/HideManager.vala"
		g_signal_handlers_disconnect_matched (previous, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp0_, 0, NULL, (GCallback) _plank_hide_manager_handle_geometry_changed_wnck_window_geometry_changed, self);
#line 518 "../lib/HideManager.vala"
		g_signal_parse_name ("state-changed", wnck_window_get_type (), &_tmp1_, NULL, FALSE);
#line 518 "../lib/HideManager.vala"
		g_signal_handlers_disconnect_matched (previous, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _plank_hide_manager_handle_state_changed_wnck_window_state_changed, self);
#line 2085 "HideManager.c"
	}
#line 521 "../lib/HideManager.vala"
	plank_hide_manager_setup_active_window (self, screen);
#line 2089 "HideManager.c"
}

static void
plank_hide_manager_setup_active_window (PlankHideManager* self,
                                        WnckScreen* screen)
{
	WnckWindow* active_window = NULL;
	WnckWindow* _tmp0_;
	WnckWindow* _tmp1_;
	WnckWindow* _tmp2_;
#line 524 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 524 "../lib/HideManager.vala"
	g_return_if_fail (screen != NULL);
#line 526 "../lib/HideManager.vala"
	_tmp0_ = wnck_screen_get_active_window (screen);
#line 526 "../lib/HideManager.vala"
	_tmp1_ = _g_object_ref0 (_tmp0_);
#line 526 "../lib/HideManager.vala"
	active_window = _tmp1_;
#line 528 "../lib/HideManager.vala"
	_tmp2_ = active_window;
#line 528 "../lib/HideManager.vala"
	if (_tmp2_ != NULL) {
#line 2114 "HideManager.c"
		WnckWindow* _tmp3_;
		GdkRectangle _tmp4_ = {0};
		WnckWindow* _tmp5_;
		WnckWindow* _tmp6_;
#line 529 "../lib/HideManager.vala"
		_tmp3_ = active_window;
#line 529 "../lib/HideManager.vala"
		plank_hide_manager_window_geometry (_tmp3_, &_tmp4_);
#line 529 "../lib/HideManager.vala"
		self->priv->last_window_rect = _tmp4_;
#line 530 "../lib/HideManager.vala"
		_tmp5_ = active_window;
#line 530 "../lib/HideManager.vala"
		g_signal_connect_object (_tmp5_, "geometry-changed", (GCallback) _plank_hide_manager_handle_geometry_changed_wnck_window_geometry_changed, self, G_CONNECT_AFTER);
#line 531 "../lib/HideManager.vala"
		_tmp6_ = active_window;
#line 531 "../lib/HideManager.vala"
		g_signal_connect_object (_tmp6_, "state-changed", (GCallback) _plank_hide_manager_handle_state_changed_wnck_window_state_changed, self, G_CONNECT_AFTER);
#line 2133 "HideManager.c"
	}
#line 534 "../lib/HideManager.vala"
	plank_hide_manager_schedule_update (self);
#line 524 "../lib/HideManager.vala"
	_g_object_unref0 (active_window);
#line 2139 "HideManager.c"
}

static void
plank_hide_manager_handle_state_changed (WnckWindow* window,
                                         WnckWindowState changed_mask,
                                         WnckWindowState new_state,
                                         PlankHideManager* self)
{
#line 538 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 538 "../lib/HideManager.vala"
	g_return_if_fail (window != NULL);
#line 540 "../lib/HideManager.vala"
	if ((changed_mask & WNCK_WINDOW_STATE_MINIMIZED) == 0) {
#line 541 "../lib/HideManager.vala"
		return;
#line 2156 "HideManager.c"
	}
#line 543 "../lib/HideManager.vala"
	plank_hide_manager_schedule_update (self);
#line 2160 "HideManager.c"
}

static gboolean
_cairo_rectangle_int_equal (const cairo_rectangle_int_t * s1,
                            const cairo_rectangle_int_t * s2)
{
#line 550 "../lib/HideManager.vala"
	if (s1 == s2) {
#line 550 "../lib/HideManager.vala"
		return TRUE;
#line 2171 "HideManager.c"
	}
#line 550 "../lib/HideManager.vala"
	if (s1 == NULL) {
#line 550 "../lib/HideManager.vala"
		return FALSE;
#line 2177 "HideManager.c"
	}
#line 550 "../lib/HideManager.vala"
	if (s2 == NULL) {
#line 550 "../lib/HideManager.vala"
		return FALSE;
#line 2183 "HideManager.c"
	}
#line 550 "../lib/HideManager.vala"
	if (s1->x != s2->x) {
#line 550 "../lib/HideManager.vala"
		return FALSE;
#line 2189 "HideManager.c"
	}
#line 550 "../lib/HideManager.vala"
	if (s1->y != s2->y) {
#line 550 "../lib/HideManager.vala"
		return FALSE;
#line 2195 "HideManager.c"
	}
#line 550 "../lib/HideManager.vala"
	if (s1->width != s2->width) {
#line 550 "../lib/HideManager.vala"
		return FALSE;
#line 2201 "HideManager.c"
	}
#line 550 "../lib/HideManager.vala"
	if (s1->height != s2->height) {
#line 550 "../lib/HideManager.vala"
		return FALSE;
#line 2207 "HideManager.c"
	}
#line 550 "../lib/HideManager.vala"
	return TRUE;
#line 2211 "HideManager.c"
}

static gboolean
__lambda49_ (PlankHideManager* self)
{
	gboolean result = FALSE;
#line 559 "../lib/HideManager.vala"
	plank_hide_manager_update_window_intersect (self);
#line 560 "../lib/HideManager.vala"
	self->priv->geometry_timer_id = 0U;
#line 561 "../lib/HideManager.vala"
	result = FALSE;
#line 561 "../lib/HideManager.vala"
	return result;
#line 2226 "HideManager.c"
}

static gboolean
___lambda49__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda49_ ((PlankHideManager*) self);
#line 558 "../lib/HideManager.vala"
	return result;
#line 2236 "HideManager.c"
}

static void
plank_hide_manager_handle_geometry_changed (WnckWindow* window,
                                            PlankHideManager* self)
{
	GdkRectangle geo = {0};
	GdkRectangle _tmp0_ = {0};
	GdkRectangle _tmp1_;
	GdkRectangle _tmp2_;
	GdkRectangle _tmp3_;
#line 547 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 547 "../lib/HideManager.vala"
	g_return_if_fail (window != NULL);
#line 549 "../lib/HideManager.vala"
	plank_hide_manager_window_geometry (window, &_tmp0_);
#line 549 "../lib/HideManager.vala"
	geo = _tmp0_;
#line 550 "../lib/HideManager.vala"
	_tmp1_ = geo;
#line 550 "../lib/HideManager.vala"
	_tmp2_ = self->priv->last_window_rect;
#line 550 "../lib/HideManager.vala"
	if (_cairo_rectangle_int_equal (&_tmp1_, &_tmp2_) == TRUE) {
#line 551 "../lib/HideManager.vala"
		return;
#line 2264 "HideManager.c"
	}
#line 553 "../lib/HideManager.vala"
	_tmp3_ = geo;
#line 553 "../lib/HideManager.vala"
	self->priv->last_window_rect = _tmp3_;
#line 555 "../lib/HideManager.vala"
	if (self->priv->geometry_timer_id > 0U) {
#line 556 "../lib/HideManager.vala"
		return;
#line 2274 "HideManager.c"
	}
#line 558 "../lib/HideManager.vala"
	self->priv->geometry_timer_id = gdk_threads_add_timeout (PLANK_HIDE_MANAGER_UPDATE_TIMEOUT, ___lambda49__gsource_func, self);
#line 2278 "HideManager.c"
}

static void
plank_hide_manager_window_geometry (WnckWindow* window,
                                    GdkRectangle* result)
{
	GdkRectangle win_rect = {0};
	GdkRectangle _tmp0_ = {0};
	gint _tmp1_ = 0;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
#line 565 "../lib/HideManager.vala"
	g_return_if_fail (window != NULL);
#line 567 "../lib/HideManager.vala"
	win_rect = _tmp0_;
#line 568 "../lib/HideManager.vala"
	wnck_window_get_geometry (window, &_tmp1_, &_tmp2_, &_tmp3_, &_tmp4_);
#line 568 "../lib/HideManager.vala"
	win_rect.x = _tmp1_;
#line 568 "../lib/HideManager.vala"
	win_rect.y = _tmp2_;
#line 568 "../lib/HideManager.vala"
	win_rect.width = _tmp3_;
#line 568 "../lib/HideManager.vala"
	win_rect.height = _tmp4_;
#line 569 "../lib/HideManager.vala"
	*result = win_rect;
#line 569 "../lib/HideManager.vala"
	return;
#line 2309 "HideManager.c"
}

static void
plank_hide_manager_stop_timers (PlankHideManager* self)
{
#line 572 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 574 "../lib/HideManager.vala"
	if (self->priv->geometry_timer_id > 0U) {
#line 575 "../lib/HideManager.vala"
		g_source_remove (self->priv->geometry_timer_id);
#line 576 "../lib/HideManager.vala"
		self->priv->geometry_timer_id = 0U;
#line 2323 "HideManager.c"
	}
#line 579 "../lib/HideManager.vala"
	if (self->priv->window_changed_timer_id > 0U) {
#line 580 "../lib/HideManager.vala"
		g_source_remove (self->priv->window_changed_timer_id);
#line 581 "../lib/HideManager.vala"
		self->priv->window_changed_timer_id = 0U;
#line 2331 "HideManager.c"
	}
#line 584 "../lib/HideManager.vala"
	if (self->priv->prefs_changed_timer_id > 0U) {
#line 585 "../lib/HideManager.vala"
		g_source_remove (self->priv->prefs_changed_timer_id);
#line 586 "../lib/HideManager.vala"
		self->priv->prefs_changed_timer_id = 0U;
#line 2339 "HideManager.c"
	}
#line 589 "../lib/HideManager.vala"
	if (self->priv->hide_timer_id > 0U) {
#line 590 "../lib/HideManager.vala"
		g_source_remove (self->priv->hide_timer_id);
#line 591 "../lib/HideManager.vala"
		self->priv->hide_timer_id = 0U;
#line 2347 "HideManager.c"
	}
#line 594 "../lib/HideManager.vala"
	if (self->priv->unhide_timer_id > 0U) {
#line 595 "../lib/HideManager.vala"
		g_source_remove (self->priv->unhide_timer_id);
#line 596 "../lib/HideManager.vala"
		self->priv->unhide_timer_id = 0U;
#line 2355 "HideManager.c"
	}
}

static void
plank_hide_manager_initialize_barriers_support (PlankHideManager* self)
{
	GdkX11Display* gdk_display = NULL;
	PlankDockController* _tmp0_;
	PlankDockWindow* _tmp1_;
	PlankDockWindow* _tmp2_;
	GdkDisplay* _tmp3_;
	Display* display = NULL;
	GdkX11Display* _tmp4_;
	Display* _tmp5_;
	gint error_base = 0;
	gint first_event_return = 0;
	Display* _tmp6_;
	gint _tmp7_ = 0;
	gint _tmp8_ = 0;
	gint _tmp9_ = 0;
	gboolean _tmp10_;
#line 601 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 603 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_controller;
#line 603 "../lib/HideManager.vala"
	_tmp1_ = plank_dock_controller_get_window (_tmp0_);
#line 603 "../lib/HideManager.vala"
	_tmp2_ = _tmp1_;
#line 603 "../lib/HideManager.vala"
	_tmp3_ = gtk_widget_get_display ((GtkWidget*) _tmp2_);
#line 603 "../lib/HideManager.vala"
	gdk_display = G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, gdk_x11_display_get_type ()) ? ((GdkX11Display*) _tmp3_) : NULL;
#line 604 "../lib/HideManager.vala"
	_tmp4_ = gdk_display;
#line 604 "../lib/HideManager.vala"
	_tmp5_ = gdk_x11_display_get_xdisplay (_tmp4_);
#line 604 "../lib/HideManager.vala"
	display = _tmp5_;
#line 607 "../lib/HideManager.vala"
	gdk_window_add_filter (NULL, (GdkFilterFunc) plank_hide_manager_xevent_filter, self);
#line 609 "../lib/HideManager.vala"
	_tmp6_ = display;
#line 609 "../lib/HideManager.vala"
	_tmp10_ = XQueryExtension (_tmp6_, "XInputExtension", &_tmp7_, &_tmp8_, &_tmp9_);
#line 609 "../lib/HideManager.vala"
	self->priv->opcode = _tmp7_;
#line 609 "../lib/HideManager.vala"
	first_event_return = _tmp8_;
#line 609 "../lib/HideManager.vala"
	error_base = _tmp9_;
#line 609 "../lib/HideManager.vala"
	if (!_tmp10_) {
#line 610 "../lib/HideManager.vala"
		g_debug ("HideManager.vala:610: Barriers disabled (XInput needed)");
#line 611 "../lib/HideManager.vala"
		self->priv->barriers_supported = FALSE;
#line 2413 "HideManager.c"
	} else {
		gint major = 0;
		gint minor = 0;
		gboolean has_xinput = FALSE;
		Display* _tmp11_;
		Status _tmp12_;
		gboolean _tmp13_ = FALSE;
		gboolean _tmp14_ = FALSE;
#line 613 "../lib/HideManager.vala"
		major = 2;
#line 613 "../lib/HideManager.vala"
		minor = 3;
#line 614 "../lib/HideManager.vala"
		_tmp11_ = display;
#line 614 "../lib/HideManager.vala"
		_tmp12_ = XIQueryVersion (_tmp11_, &major, &minor);
#line 614 "../lib/HideManager.vala"
		has_xinput = _tmp12_ == ((Status) Success);
#line 615 "../lib/HideManager.vala"
		if (has_xinput) {
#line 615 "../lib/HideManager.vala"
			_tmp14_ = major >= 2;
#line 2436 "HideManager.c"
		} else {
#line 615 "../lib/HideManager.vala"
			_tmp14_ = FALSE;
#line 2440 "HideManager.c"
		}
#line 615 "../lib/HideManager.vala"
		if (_tmp14_) {
#line 615 "../lib/HideManager.vala"
			_tmp13_ = minor >= 3;
#line 2446 "HideManager.c"
		} else {
#line 615 "../lib/HideManager.vala"
			_tmp13_ = FALSE;
#line 2450 "HideManager.c"
		}
#line 615 "../lib/HideManager.vala"
		if (_tmp13_) {
#line 616 "../lib/HideManager.vala"
			g_message ("HideManager.vala:616: Barriers enabled (XInput %i.%i support)\n", major, minor);
#line 617 "../lib/HideManager.vala"
			self->priv->barriers_supported = TRUE;
#line 618 "../lib/HideManager.vala"
			gdk_window_add_filter (NULL, (GdkFilterFunc) plank_hide_manager_xevent_filter, self);
#line 2460 "HideManager.c"
		} else {
#line 620 "../lib/HideManager.vala"
			g_debug ("HideManager.vala:620: Barriers disabled (XInput %i.%i not sufficient)", major, minor);
#line 621 "../lib/HideManager.vala"
			self->priv->barriers_supported = FALSE;
#line 2466 "HideManager.c"
		}
	}
}

/**
 * Event filter method needed to fetch X.Events
 */
static gboolean
____lambda13_ (PlankHideManager* self)
{
	gboolean result = FALSE;
#line 697 "../lib/HideManager.vala"
	self->priv->pressure = 0.0;
#line 698 "../lib/HideManager.vala"
	self->priv->pressure_timer_id = 0U;
#line 699 "../lib/HideManager.vala"
	result = FALSE;
#line 699 "../lib/HideManager.vala"
	return result;
#line 2486 "HideManager.c"
}

static gboolean
_____lambda13__gsource_func (gpointer self)
{
	gboolean result;
	result = ____lambda13_ ((PlankHideManager*) self);
#line 696 "../lib/HideManager.vala"
	return result;
#line 2496 "HideManager.c"
}

static GdkFilterReturn
plank_hide_manager_xevent_filter (GdkXEvent* gdk_xevent,
                                  GdkEvent* gdk_event,
                                  PlankHideManager* self)
{
	XEvent* xevent = NULL;
	XGenericEventCookie* xcookie = NULL;
	Display* display = NULL;
	XGenericEventCookie* _tmp0_;
	Display* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	Display* _tmp8_;
	XGenericEventCookie* _tmp9_;
	XIBarrierEvent* barrier_event = NULL;
	XGenericEventCookie* _tmp10_;
	void* _tmp11_;
	XIBarrierEvent* _tmp12_;
	XGenericEventCookie* _tmp15_;
	Display* _tmp26_;
	XIBarrierEvent* _tmp27_;
	XIBarrierEvent* _tmp28_;
	Display* _tmp29_;
	Display* _tmp30_;
	XGenericEventCookie* _tmp31_;
	GdkFilterReturn result = 0;
#line 630 "../lib/HideManager.vala"
	g_return_val_if_fail (self != NULL, 0);
#line 630 "../lib/HideManager.vala"
	g_return_val_if_fail (gdk_xevent != NULL, 0);
#line 630 "../lib/HideManager.vala"
	g_return_val_if_fail (gdk_event != NULL, 0);
#line 632 "../lib/HideManager.vala"
	xevent = (XEvent*) gdk_xevent;
#line 633 "../lib/HideManager.vala"
	xcookie = &(*xevent).xcookie;
#line 634 "../lib/HideManager.vala"
	_tmp0_ = xcookie;
#line 634 "../lib/HideManager.vala"
	_tmp1_ = (*_tmp0_).display;
#line 634 "../lib/HideManager.vala"
	display = _tmp1_;
#line 637 "../lib/HideManager.vala"
	if (self->priv->barrier == ((PointerBarrier) 0)) {
#line 637 "../lib/HideManager.vala"
		_tmp3_ = TRUE;
#line 2545 "HideManager.c"
	} else {
		XGenericEventCookie* _tmp4_;
#line 638 "../lib/HideManager.vala"
		_tmp4_ = xcookie;
#line 638 "../lib/HideManager.vala"
		_tmp3_ = (*_tmp4_).extension != self->priv->opcode;
#line 2552 "HideManager.c"
	}
#line 637 "../lib/HideManager.vala"
	if (_tmp3_) {
#line 637 "../lib/HideManager.vala"
		_tmp2_ = TRUE;
#line 2558 "HideManager.c"
	} else {
		gboolean _tmp5_ = FALSE;
		XGenericEventCookie* _tmp6_;
#line 639 "../lib/HideManager.vala"
		_tmp6_ = xcookie;
#line 639 "../lib/HideManager.vala"
		if ((*_tmp6_).evtype != ((gint) XI_BarrierHit)) {
#line 2566 "HideManager.c"
			XGenericEventCookie* _tmp7_;
#line 639 "../lib/HideManager.vala"
			_tmp7_ = xcookie;
#line 639 "../lib/HideManager.vala"
			_tmp5_ = (*_tmp7_).evtype != ((gint) XI_BarrierLeave);
#line 2572 "HideManager.c"
		} else {
#line 639 "../lib/HideManager.vala"
			_tmp5_ = FALSE;
#line 2576 "HideManager.c"
		}
#line 639 "../lib/HideManager.vala"
		_tmp2_ = _tmp5_;
#line 2580 "HideManager.c"
	}
#line 637 "../lib/HideManager.vala"
	if (_tmp2_) {
#line 640 "../lib/HideManager.vala"
		result = GDK_FILTER_CONTINUE;
#line 640 "../lib/HideManager.vala"
		return result;
#line 2588 "HideManager.c"
	}
#line 642 "../lib/HideManager.vala"
	_tmp8_ = display;
#line 642 "../lib/HideManager.vala"
	_tmp9_ = xcookie;
#line 642 "../lib/HideManager.vala"
	XGetEventData (_tmp8_, _tmp9_);
#line 645 "../lib/HideManager.vala"
	_tmp10_ = xcookie;
#line 645 "../lib/HideManager.vala"
	_tmp11_ = (*_tmp10_).data;
#line 645 "../lib/HideManager.vala"
	barrier_event = (XIBarrierEvent*) _tmp11_;
#line 646 "../lib/HideManager.vala"
	_tmp12_ = barrier_event;
#line 646 "../lib/HideManager.vala"
	if ((*_tmp12_).barrier != self->priv->barrier) {
#line 2606 "HideManager.c"
		Display* _tmp13_;
		XGenericEventCookie* _tmp14_;
#line 647 "../lib/HideManager.vala"
		_tmp13_ = display;
#line 647 "../lib/HideManager.vala"
		_tmp14_ = xcookie;
#line 647 "../lib/HideManager.vala"
		XFreeEventData (_tmp13_, _tmp14_);
#line 648 "../lib/HideManager.vala"
		result = GDK_FILTER_CONTINUE;
#line 648 "../lib/HideManager.vala"
		return result;
#line 2619 "HideManager.c"
	}
#line 651 "../lib/HideManager.vala"
	_tmp15_ = xcookie;
#line 651 "../lib/HideManager.vala"
	switch ((*_tmp15_).evtype) {
#line 651 "../lib/HideManager.vala"
		case XI_BarrierHit:
#line 2627 "HideManager.c"
		{
			gdouble slide = 0.0;
			gdouble distance = 0.0;
			PlankDockController* _tmp16_;
			PlankPositionManager* _tmp17_;
			PlankPositionManager* _tmp18_;
			GtkPositionType _tmp19_;
			GtkPositionType _tmp20_;
#line 653 "../lib/HideManager.vala"
			slide = 0.0;
#line 653 "../lib/HideManager.vala"
			distance = 0.0;
#line 654 "../lib/HideManager.vala"
			_tmp16_ = self->priv->_controller;
#line 654 "../lib/HideManager.vala"
			_tmp17_ = plank_dock_controller_get_position_manager (_tmp16_);
#line 654 "../lib/HideManager.vala"
			_tmp18_ = _tmp17_;
#line 654 "../lib/HideManager.vala"
			_tmp19_ = plank_position_manager_get_Position (_tmp18_);
#line 654 "../lib/HideManager.vala"
			_tmp20_ = _tmp19_;
#line 654 "../lib/HideManager.vala"
			switch (_tmp20_) {
#line 2652 "HideManager.c"
				default:
#line 654 "../lib/HideManager.vala"
				case GTK_POS_BOTTOM:
#line 654 "../lib/HideManager.vala"
				case GTK_POS_TOP:
#line 2658 "HideManager.c"
				{
					XIBarrierEvent* _tmp21_;
					XIBarrierEvent* _tmp22_;
#line 658 "../lib/HideManager.vala"
					_tmp21_ = barrier_event;
#line 658 "../lib/HideManager.vala"
					distance = fabs ((*_tmp21_).dy);
#line 659 "../lib/HideManager.vala"
					_tmp22_ = barrier_event;
#line 659 "../lib/HideManager.vala"
					slide = fabs ((*_tmp22_).dx);
#line 660 "../lib/HideManager.vala"
					break;
#line 2672 "HideManager.c"
				}
#line 654 "../lib/HideManager.vala"
				case GTK_POS_LEFT:
#line 654 "../lib/HideManager.vala"
				case GTK_POS_RIGHT:
#line 2678 "HideManager.c"
				{
					XIBarrierEvent* _tmp23_;
					XIBarrierEvent* _tmp24_;
#line 663 "../lib/HideManager.vala"
					_tmp23_ = barrier_event;
#line 663 "../lib/HideManager.vala"
					distance = fabs ((*_tmp23_).dx);
#line 664 "../lib/HideManager.vala"
					_tmp24_ = barrier_event;
#line 664 "../lib/HideManager.vala"
					slide = fabs ((*_tmp24_).dy);
#line 665 "../lib/HideManager.vala"
					break;
#line 2692 "HideManager.c"
				}
			}
#line 668 "../lib/HideManager.vala"
			if (slide < distance) {
#line 669 "../lib/HideManager.vala"
				distance = fmin (15.0, distance);
#line 670 "../lib/HideManager.vala"
				self->priv->pressure = self->priv->pressure + distance;
#line 671 "../lib/HideManager.vala"
				plank_logger_verbose ("HideManager (pressure = %f)", self->priv->pressure, NULL);
#line 2703 "HideManager.c"
			}
#line 674 "../lib/HideManager.vala"
			if (self->priv->pressure >= PLANK_HIDE_MANAGER_PRESSURE_THRESHOLD) {
#line 2707 "HideManager.c"
				gboolean _tmp25_;
#line 675 "../lib/HideManager.vala"
				self->priv->pressure = 0.0;
#line 677 "../lib/HideManager.vala"
				if (self->priv->pressure_timer_id > 0U) {
#line 678 "../lib/HideManager.vala"
					g_source_remove (self->priv->pressure_timer_id);
#line 679 "../lib/HideManager.vala"
					self->priv->pressure_timer_id = 0U;
#line 2717 "HideManager.c"
				}
#line 682 "../lib/HideManager.vala"
				plank_logger_verbose ("HideManager (pressure-threshold reached > unhide (%f))", PLANK_HIDE_MANAGER_PRESSURE_THRESHOLD, NULL);
#line 684 "../lib/HideManager.vala"
				g_object_freeze_notify ((GObject*) self);
#line 686 "../lib/HideManager.vala"
				_tmp25_ = self->priv->_Hovered;
#line 686 "../lib/HideManager.vala"
				if (!_tmp25_) {
#line 687 "../lib/HideManager.vala"
					plank_hide_manager_set_Hovered (self, TRUE);
#line 688 "../lib/HideManager.vala"
					plank_hide_manager_update_hidden (self);
#line 2731 "HideManager.c"
				}
#line 691 "../lib/HideManager.vala"
				g_object_thaw_notify ((GObject*) self);
#line 2735 "HideManager.c"
			}
#line 693 "../lib/HideManager.vala"
			break;
#line 2739 "HideManager.c"
		}
#line 651 "../lib/HideManager.vala"
		case XI_BarrierLeave:
#line 2743 "HideManager.c"
		{
#line 695 "../lib/HideManager.vala"
			if (self->priv->pressure_timer_id == 0U) {
#line 696 "../lib/HideManager.vala"
				self->priv->pressure_timer_id = gdk_threads_add_timeout (PLANK_HIDE_MANAGER_PRESSURE_TIMEOUT, _____lambda13__gsource_func, self);
#line 2749 "HideManager.c"
			}
#line 701 "../lib/HideManager.vala"
			break;
#line 2753 "HideManager.c"
		}
		default:
		{
#line 703 "../lib/HideManager.vala"
			break;
#line 2759 "HideManager.c"
		}
	}
#line 706 "../lib/HideManager.vala"
	_tmp26_ = display;
#line 706 "../lib/HideManager.vala"
	_tmp27_ = barrier_event;
#line 706 "../lib/HideManager.vala"
	_tmp28_ = barrier_event;
#line 706 "../lib/HideManager.vala"
	XIBarrierReleasePointer (_tmp26_, (*_tmp27_).deviceid, self->priv->barrier, (*_tmp28_).eventid);
#line 709 "../lib/HideManager.vala"
	_tmp29_ = display;
#line 709 "../lib/HideManager.vala"
	XFlush (_tmp29_);
#line 711 "../lib/HideManager.vala"
	_tmp30_ = display;
#line 711 "../lib/HideManager.vala"
	_tmp31_ = xcookie;
#line 711 "../lib/HideManager.vala"
	XFreeEventData (_tmp30_, _tmp31_);
#line 712 "../lib/HideManager.vala"
	result = GDK_FILTER_REMOVE;
#line 712 "../lib/HideManager.vala"
	return result;
#line 2784 "HideManager.c"
}

static void
xinput_event_mask_destroy (XIEventMask * self)
{
#line 715 "../lib/HideManager.vala"
	(*self).mask = (g_free ((*self).mask), NULL);
#line 2792 "HideManager.c"
}

void
plank_hide_manager_update_barrier (PlankHideManager* self)
{
	GdkX11Display* gdk_display = NULL;
	PlankDockController* _tmp0_;
	PlankDockWindow* _tmp1_;
	PlankDockWindow* _tmp2_;
	GdkDisplay* _tmp3_;
	Display* display = NULL;
	GdkX11Display* _tmp4_;
	Display* _tmp5_;
	PlankDockController* _tmp7_;
	PlankDockPreferences* _tmp8_;
	PlankDockPreferences* _tmp9_;
	gboolean _tmp10_;
	gboolean _tmp11_;
	PlankDockController* _tmp12_;
	PlankDockPreferences* _tmp13_;
	PlankDockPreferences* _tmp14_;
	PlankHideType _tmp15_;
	PlankHideType _tmp16_;
	Window root_xwindow = 0;
	Display* _tmp17_;
	GdkRectangle barrier_area = {0};
	PlankDockController* _tmp18_;
	PlankPositionManager* _tmp19_;
	PlankPositionManager* _tmp20_;
	GdkRectangle _tmp21_ = {0};
	guchar* mask_bits = NULL;
	guchar* _tmp22_;
	gint mask_bits_length1;
	gint _mask_bits_size_;
	XIEventMask mask = {0};
	guchar* _tmp23_;
	gint _tmp23__length1;
	guchar* _tmp24_;
	gint _tmp24__length1;
	XIEventMask _tmp25_ = {0};
	XIEventMask _tmp26_;
	guchar* _tmp27_;
	gint _tmp27__length1;
	XIEventMask _tmp28_;
	guchar* _tmp29_;
	gint _tmp29__length1;
	Display* _tmp30_;
	GdkRectangle _tmp31_;
	GdkRectangle _tmp32_;
	GdkRectangle _tmp33_;
	GdkRectangle _tmp34_;
	GdkRectangle _tmp35_;
	GdkRectangle _tmp36_;
	Display* _tmp37_;
	GdkRectangle _tmp38_;
	GdkRectangle _tmp39_;
	GdkRectangle _tmp40_;
	GdkRectangle _tmp41_;
	GdkRectangle _tmp42_;
	GdkRectangle _tmp43_;
#line 715 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 717 "../lib/HideManager.vala"
	if (!self->priv->barriers_supported) {
#line 718 "../lib/HideManager.vala"
		return;
#line 2859 "HideManager.c"
	}
#line 720 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_controller;
#line 720 "../lib/HideManager.vala"
	_tmp1_ = plank_dock_controller_get_window (_tmp0_);
#line 720 "../lib/HideManager.vala"
	_tmp2_ = _tmp1_;
#line 720 "../lib/HideManager.vala"
	_tmp3_ = gtk_widget_get_display ((GtkWidget*) _tmp2_);
#line 720 "../lib/HideManager.vala"
	gdk_display = G_TYPE_CHECK_INSTANCE_TYPE (_tmp3_, gdk_x11_display_get_type ()) ? ((GdkX11Display*) _tmp3_) : NULL;
#line 721 "../lib/HideManager.vala"
	_tmp4_ = gdk_display;
#line 721 "../lib/HideManager.vala"
	_tmp5_ = gdk_x11_display_get_xdisplay (_tmp4_);
#line 721 "../lib/HideManager.vala"
	display = _tmp5_;
#line 723 "../lib/HideManager.vala"
	if (self->priv->barrier > ((PointerBarrier) 0)) {
#line 2879 "HideManager.c"
		Display* _tmp6_;
#line 724 "../lib/HideManager.vala"
		_tmp6_ = display;
#line 724 "../lib/HideManager.vala"
		XFixesDestroyPointerBarrier (_tmp6_, self->priv->barrier);
#line 725 "../lib/HideManager.vala"
		self->priv->barrier = (PointerBarrier) 0;
#line 2887 "HideManager.c"
	}
#line 728 "../lib/HideManager.vala"
	_tmp7_ = self->priv->_controller;
#line 728 "../lib/HideManager.vala"
	_tmp8_ = plank_dock_controller_get_prefs (_tmp7_);
#line 728 "../lib/HideManager.vala"
	_tmp9_ = _tmp8_;
#line 728 "../lib/HideManager.vala"
	_tmp10_ = plank_dock_preferences_get_PressureReveal (_tmp9_);
#line 728 "../lib/HideManager.vala"
	_tmp11_ = _tmp10_;
#line 728 "../lib/HideManager.vala"
	if (!_tmp11_) {
#line 729 "../lib/HideManager.vala"
		return;
#line 2903 "HideManager.c"
	}
#line 731 "../lib/HideManager.vala"
	_tmp12_ = self->priv->_controller;
#line 731 "../lib/HideManager.vala"
	_tmp13_ = plank_dock_controller_get_prefs (_tmp12_);
#line 731 "../lib/HideManager.vala"
	_tmp14_ = _tmp13_;
#line 731 "../lib/HideManager.vala"
	_tmp15_ = plank_dock_preferences_get_HideMode (_tmp14_);
#line 731 "../lib/HideManager.vala"
	_tmp16_ = _tmp15_;
#line 731 "../lib/HideManager.vala"
	if (_tmp16_ == PLANK_HIDE_TYPE_NONE) {
#line 732 "../lib/HideManager.vala"
		return;
#line 2919 "HideManager.c"
	}
#line 734 "../lib/HideManager.vala"
	_tmp17_ = display;
#line 734 "../lib/HideManager.vala"
	root_xwindow = DefaultRootWindow (_tmp17_);
#line 735 "../lib/HideManager.vala"
	_tmp18_ = self->priv->_controller;
#line 735 "../lib/HideManager.vala"
	_tmp19_ = plank_dock_controller_get_position_manager (_tmp18_);
#line 735 "../lib/HideManager.vala"
	_tmp20_ = _tmp19_;
#line 735 "../lib/HideManager.vala"
	plank_position_manager_get_barrier (_tmp20_, &_tmp21_);
#line 735 "../lib/HideManager.vala"
	barrier_area = _tmp21_;
#line 738 "../lib/HideManager.vala"
	_tmp22_ = g_new0 (guchar, XIMaskLen (XI_LASTEVENT));
#line 738 "../lib/HideManager.vala"
	mask_bits = _tmp22_;
#line 738 "../lib/HideManager.vala"
	mask_bits_length1 = XIMaskLen (XI_LASTEVENT);
#line 738 "../lib/HideManager.vala"
	_mask_bits_size_ = mask_bits_length1;
#line 739 "../lib/HideManager.vala"
	_tmp23_ = mask_bits;
#line 739 "../lib/HideManager.vala"
	_tmp23__length1 = mask_bits_length1;
#line 739 "../lib/HideManager.vala"
	_tmp24_ = mask_bits;
#line 739 "../lib/HideManager.vala"
	_tmp24__length1 = mask_bits_length1;
#line 739 "../lib/HideManager.vala"
	mask_bits = NULL;
#line 739 "../lib/HideManager.vala"
	mask_bits_length1 = 0;
#line 739 "../lib/HideManager.vala"
	_tmp25_.deviceid = XIAllMasterDevices;
#line 739 "../lib/HideManager.vala"
	_tmp25_.mask_len = (gint) (sizeof (guchar) * _tmp23__length1);
#line 739 "../lib/HideManager.vala"
	_tmp25_.mask = (g_free (_tmp25_.mask), NULL);
#line 739 "../lib/HideManager.vala"
	_tmp25_.mask = _tmp24_;
#line 739 "../lib/HideManager.vala"
	_tmp25_.mask_len = _tmp24__length1;
#line 739 "../lib/HideManager.vala"
	mask = _tmp25_;
#line 740 "../lib/HideManager.vala"
	_tmp26_ = mask;
#line 740 "../lib/HideManager.vala"
	_tmp27_ = _tmp26_.mask;
#line 740 "../lib/HideManager.vala"
	_tmp27__length1 = _tmp26_.mask_len;
#line 740 "../lib/HideManager.vala"
	XISetMask (_tmp27_, XI_BarrierHit);
#line 741 "../lib/HideManager.vala"
	_tmp28_ = mask;
#line 741 "../lib/HideManager.vala"
	_tmp29_ = _tmp28_.mask;
#line 741 "../lib/HideManager.vala"
	_tmp29__length1 = _tmp28_.mask_len;
#line 741 "../lib/HideManager.vala"
	XISetMask (_tmp29_, XI_BarrierLeave);
#line 742 "../lib/HideManager.vala"
	_tmp30_ = display;
#line 742 "../lib/HideManager.vala"
	XISelectEvents (_tmp30_, root_xwindow, &mask, 1);
#line 744 "../lib/HideManager.vala"
	_tmp31_ = barrier_area;
#line 744 "../lib/HideManager.vala"
	_tmp32_ = barrier_area;
#line 744 "../lib/HideManager.vala"
	_tmp33_ = barrier_area;
#line 744 "../lib/HideManager.vala"
	_tmp34_ = barrier_area;
#line 744 "../lib/HideManager.vala"
	_tmp35_ = barrier_area;
#line 744 "../lib/HideManager.vala"
	_tmp36_ = barrier_area;
#line 744 "../lib/HideManager.vala"
	g_debug ("HideManager.vala:744: Barrier: %i,%i - %i,%i\n", _tmp31_.x, _tmp32_.y, _tmp33_.x + _tmp34_.width, _tmp35_.y + _tmp36_.height);
#line 746 "../lib/HideManager.vala"
	_tmp37_ = display;
#line 746 "../lib/HideManager.vala"
	_tmp38_ = barrier_area;
#line 746 "../lib/HideManager.vala"
	_tmp39_ = barrier_area;
#line 746 "../lib/HideManager.vala"
	_tmp40_ = barrier_area;
#line 746 "../lib/HideManager.vala"
	_tmp41_ = barrier_area;
#line 746 "../lib/HideManager.vala"
	_tmp42_ = barrier_area;
#line 746 "../lib/HideManager.vala"
	_tmp43_ = barrier_area;
#line 746 "../lib/HideManager.vala"
	self->priv->barrier = XFixesCreatePointerBarrier (_tmp37_, root_xwindow, _tmp38_.x, _tmp39_.y, _tmp40_.x + _tmp41_.width, _tmp42_.y + _tmp43_.height, 0, 0, NULL);
#line 753 "../lib/HideManager.vala"
	g_warn_if_fail (self->priv->barrier > ((PointerBarrier) 0));
#line 715 "../lib/HideManager.vala"
	xinput_event_mask_destroy (&mask);
#line 715 "../lib/HideManager.vala"
	mask_bits = (g_free (mask_bits), NULL);
#line 3023 "HideManager.c"
}

static PlankDockController*
plank_hide_manager_get_controller (PlankHideManager* self)
{
	PlankDockController* result;
	PlankDockController* _tmp0_;
#line 76 "../lib/HideManager.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 76 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_controller;
#line 76 "../lib/HideManager.vala"
	result = _tmp0_;
#line 76 "../lib/HideManager.vala"
	return result;
#line 3039 "HideManager.c"
}

static void
plank_hide_manager_set_controller (PlankHideManager* self,
                                   PlankDockController* value)
{
	PlankDockController* old_value;
#line 76 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 76 "../lib/HideManager.vala"
	old_value = plank_hide_manager_get_controller (self);
#line 76 "../lib/HideManager.vala"
	if (old_value != value) {
#line 3053 "HideManager.c"
		PlankDockController* _tmp0_;
#line 76 "../lib/HideManager.vala"
		_tmp0_ = _g_object_ref0 (value);
#line 76 "../lib/HideManager.vala"
		_g_object_unref0 (self->priv->_controller);
#line 76 "../lib/HideManager.vala"
		self->priv->_controller = _tmp0_;
#line 76 "../lib/HideManager.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_hide_manager_properties[PLANK_HIDE_MANAGER_CONTROLLER_PROPERTY]);
#line 3063 "HideManager.c"
	}
}

gboolean
plank_hide_manager_get_Hidden (PlankHideManager* self)
{
	gboolean result;
#line 81 "../lib/HideManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 81 "../lib/HideManager.vala"
	result = self->priv->_Hidden;
#line 81 "../lib/HideManager.vala"
	return result;
#line 3077 "HideManager.c"
}

static void
plank_hide_manager_set_Hidden (PlankHideManager* self,
                               gboolean value)
{
	gboolean old_value;
#line 81 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 81 "../lib/HideManager.vala"
	old_value = plank_hide_manager_get_Hidden (self);
#line 81 "../lib/HideManager.vala"
	if (old_value != value) {
#line 81 "../lib/HideManager.vala"
		self->priv->_Hidden = value;
#line 81 "../lib/HideManager.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_hide_manager_properties[PLANK_HIDE_MANAGER_HIDDEN_PROPERTY]);
#line 3095 "HideManager.c"
	}
}

gboolean
plank_hide_manager_get_Disabled (PlankHideManager* self)
{
	gboolean result;
#line 86 "../lib/HideManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 86 "../lib/HideManager.vala"
	result = self->priv->_Disabled;
#line 86 "../lib/HideManager.vala"
	return result;
#line 3109 "HideManager.c"
}

static void
plank_hide_manager_set_Disabled (PlankHideManager* self,
                                 gboolean value)
{
	gboolean old_value;
#line 86 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 86 "../lib/HideManager.vala"
	old_value = plank_hide_manager_get_Disabled (self);
#line 86 "../lib/HideManager.vala"
	if (old_value != value) {
#line 86 "../lib/HideManager.vala"
		self->priv->_Disabled = value;
#line 86 "../lib/HideManager.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_hide_manager_properties[PLANK_HIDE_MANAGER_DISABLED_PROPERTY]);
#line 3127 "HideManager.c"
	}
}

gboolean
plank_hide_manager_get_Hovered (PlankHideManager* self)
{
	gboolean result;
#line 91 "../lib/HideManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 91 "../lib/HideManager.vala"
	result = self->priv->_Hovered;
#line 91 "../lib/HideManager.vala"
	return result;
#line 3141 "HideManager.c"
}

static void
plank_hide_manager_set_Hovered (PlankHideManager* self,
                                gboolean value)
{
	gboolean old_value;
#line 91 "../lib/HideManager.vala"
	g_return_if_fail (self != NULL);
#line 91 "../lib/HideManager.vala"
	old_value = plank_hide_manager_get_Hovered (self);
#line 91 "../lib/HideManager.vala"
	if (old_value != value) {
#line 91 "../lib/HideManager.vala"
		self->priv->_Hovered = value;
#line 91 "../lib/HideManager.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_hide_manager_properties[PLANK_HIDE_MANAGER_HOVERED_PROPERTY]);
#line 3159 "HideManager.c"
	}
}

static GObject *
plank_hide_manager_constructor (GType type,
                                guint n_construct_properties,
                                GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	PlankHideManager * self;
	PlankDockController* _tmp0_;
	PlankDockPreferences* _tmp1_;
	PlankDockPreferences* _tmp2_;
#line 126 "../lib/HideManager.vala"
	parent_class = G_OBJECT_CLASS (plank_hide_manager_parent_class);
#line 126 "../lib/HideManager.vala"
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
#line 126 "../lib/HideManager.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_HIDE_MANAGER, PlankHideManager);
#line 128 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_controller;
#line 128 "../lib/HideManager.vala"
	_tmp1_ = plank_dock_controller_get_prefs (_tmp0_);
#line 128 "../lib/HideManager.vala"
	_tmp2_ = _tmp1_;
#line 128 "../lib/HideManager.vala"
	g_signal_connect_object ((GObject*) _tmp2_, "notify", (GCallback) _plank_hide_manager_prefs_changed_g_object_notify, self, 0);
#line 126 "../lib/HideManager.vala"
	return obj;
#line 3190 "HideManager.c"
}

static void
plank_hide_manager_class_init (PlankHideManagerClass * klass,
                               gpointer klass_data)
{
#line 56 "../lib/HideManager.vala"
	plank_hide_manager_parent_class = g_type_class_peek_parent (klass);
#line 56 "../lib/HideManager.vala"
	g_type_class_adjust_private_offset (klass, &PlankHideManager_private_offset);
#line 56 "../lib/HideManager.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_plank_hide_manager_get_property;
#line 56 "../lib/HideManager.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_plank_hide_manager_set_property;
#line 56 "../lib/HideManager.vala"
	G_OBJECT_CLASS (klass)->constructor = plank_hide_manager_constructor;
#line 56 "../lib/HideManager.vala"
	G_OBJECT_CLASS (klass)->finalize = plank_hide_manager_finalize;
#line 56 "../lib/HideManager.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_HIDE_MANAGER_CONTROLLER_PROPERTY, plank_hide_manager_properties[PLANK_HIDE_MANAGER_CONTROLLER_PROPERTY] = g_param_spec_object ("controller", "controller", "controller", PLANK_TYPE_DOCK_CONTROLLER, G_PARAM_STATIC_STRINGS | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
#line 3211 "HideManager.c"
	/**
	 * If the dock is currently hidden.
	 */
#line 56 "../lib/HideManager.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_HIDE_MANAGER_HIDDEN_PROPERTY, plank_hide_manager_properties[PLANK_HIDE_MANAGER_HIDDEN_PROPERTY] = g_param_spec_boolean ("Hidden", "Hidden", "Hidden", TRUE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
#line 3217 "HideManager.c"
	/**
	 * If hiding the dock is currently disabled
	 */
#line 56 "../lib/HideManager.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_HIDE_MANAGER_DISABLED_PROPERTY, plank_hide_manager_properties[PLANK_HIDE_MANAGER_DISABLED_PROPERTY] = g_param_spec_boolean ("Disabled", "Disabled", "Disabled", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
#line 3223 "HideManager.c"
	/**
	 * If the dock is currently hovered by the mouse cursor.
	 */
#line 56 "../lib/HideManager.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_HIDE_MANAGER_HOVERED_PROPERTY, plank_hide_manager_properties[PLANK_HIDE_MANAGER_HOVERED_PROPERTY] = g_param_spec_boolean ("Hovered", "Hovered", "Hovered", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
#line 73 "../lib/HideManager.vala"
	plank_hide_manager_plank_pid = getpid ();
#line 3231 "HideManager.c"
}

static void
plank_hide_manager_instance_init (PlankHideManager * self,
                                  gpointer klass)
{
#line 56 "../lib/HideManager.vala"
	self->priv = plank_hide_manager_get_instance_private (self);
#line 81 "../lib/HideManager.vala"
	self->priv->_Hidden = TRUE;
#line 86 "../lib/HideManager.vala"
	self->priv->_Disabled = FALSE;
#line 91 "../lib/HideManager.vala"
	self->priv->_Hovered = FALSE;
#line 93 "../lib/HideManager.vala"
	self->priv->hide_timer_id = 0U;
#line 94 "../lib/HideManager.vala"
	self->priv->unhide_timer_id = 0U;
#line 95 "../lib/HideManager.vala"
	self->priv->prefs_changed_timer_id = 0U;
#line 96 "../lib/HideManager.vala"
	self->priv->geometry_timer_id = 0U;
#line 97 "../lib/HideManager.vala"
	self->priv->window_changed_timer_id = 0U;
#line 99 "../lib/HideManager.vala"
	self->priv->pointer_update = TRUE;
#line 100 "../lib/HideManager.vala"
	self->priv->window_intersect = FALSE;
#line 101 "../lib/HideManager.vala"
	self->priv->active_window_intersect = FALSE;
#line 102 "../lib/HideManager.vala"
	self->priv->active_application_intersect = FALSE;
#line 103 "../lib/HideManager.vala"
	self->priv->active_maximized_window_intersect = FALSE;
#line 104 "../lib/HideManager.vala"
	self->priv->dialog_windows_intersect = FALSE;
#line 108 "../lib/HideManager.vala"
	self->priv->barrier = (PointerBarrier) 0;
#line 109 "../lib/HideManager.vala"
	self->priv->opcode = 0;
#line 110 "../lib/HideManager.vala"
	self->priv->pressure = 0.0;
#line 111 "../lib/HideManager.vala"
	self->priv->pressure_timer_id = 0U;
#line 112 "../lib/HideManager.vala"
	self->priv->barriers_supported = FALSE;
#line 3278 "HideManager.c"
}

static void
plank_hide_manager_finalize (GObject * obj)
{
	PlankHideManager * self;
	PlankDockWindow* window = NULL;
	PlankDockController* _tmp0_;
	PlankDockWindow* _tmp1_;
	PlankDockWindow* _tmp2_;
	PlankDragManager* drag_manager = NULL;
	PlankDockController* _tmp3_;
	PlankDragManager* _tmp4_;
	PlankDragManager* _tmp5_;
	WnckScreen* wnck_screen = NULL;
	WnckScreen* _tmp6_;
	PlankDockController* _tmp7_;
	PlankDockPreferences* _tmp8_;
	PlankDockPreferences* _tmp9_;
	guint _tmp10_;
	PlankDockWindow* _tmp11_;
	guint _tmp12_;
	PlankDockWindow* _tmp13_;
	guint _tmp14_;
	WnckScreen* _tmp15_;
	guint _tmp16_;
	WnckScreen* _tmp17_;
	guint _tmp18_;
	WnckScreen* _tmp19_;
	guint _tmp20_;
	WnckScreen* _tmp21_;
	guint _tmp22_;
#line 56 "../lib/HideManager.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_HIDE_MANAGER, PlankHideManager);
#line 157 "../lib/HideManager.vala"
	_tmp0_ = self->priv->_controller;
#line 157 "../lib/HideManager.vala"
	_tmp1_ = plank_dock_controller_get_window (_tmp0_);
#line 157 "../lib/HideManager.vala"
	_tmp2_ = _tmp1_;
#line 157 "../lib/HideManager.vala"
	window = _tmp2_;
#line 158 "../lib/HideManager.vala"
	_tmp3_ = self->priv->_controller;
#line 158 "../lib/HideManager.vala"
	_tmp4_ = plank_dock_controller_get_drag_manager (_tmp3_);
#line 158 "../lib/HideManager.vala"
	_tmp5_ = _tmp4_;
#line 158 "../lib/HideManager.vala"
	drag_manager = _tmp5_;
#line 159 "../lib/HideManager.vala"
	_tmp6_ = wnck_screen_get_default ();
#line 159 "../lib/HideManager.vala"
	wnck_screen = _tmp6_;
#line 161 "../lib/HideManager.vala"
	_tmp7_ = self->priv->_controller;
#line 161 "../lib/HideManager.vala"
	_tmp8_ = plank_dock_controller_get_prefs (_tmp7_);
#line 161 "../lib/HideManager.vala"
	_tmp9_ = _tmp8_;
#line 161 "../lib/HideManager.vala"
	g_signal_parse_name ("notify", G_TYPE_OBJECT, &_tmp10_, NULL, FALSE);
#line 161 "../lib/HideManager.vala"
	g_signal_handlers_disconnect_matched ((GObject*) _tmp9_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp10_, 0, NULL, (GCallback) _plank_hide_manager_prefs_changed_g_object_notify, self);
#line 163 "../lib/HideManager.vala"
	_tmp11_ = window;
#line 163 "../lib/HideManager.vala"
	g_signal_parse_name ("enter-notify-event", gtk_widget_get_type (), &_tmp12_, NULL, FALSE);
#line 163 "../lib/HideManager.vala"
	g_signal_handlers_disconnect_matched ((GtkWidget*) _tmp11_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp12_, 0, NULL, (GCallback) _plank_hide_manager_handle_enter_notify_event_gtk_widget_enter_notify_event, self);
#line 164 "../lib/HideManager.vala"
	_tmp13_ = window;
#line 164 "../lib/HideManager.vala"
	g_signal_parse_name ("leave-notify-event", gtk_widget_get_type (), &_tmp14_, NULL, FALSE);
#line 164 "../lib/HideManager.vala"
	g_signal_handlers_disconnect_matched ((GtkWidget*) _tmp13_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp14_, 0, NULL, (GCallback) _plank_hide_manager_handle_leave_notify_event_gtk_widget_leave_notify_event, self);
#line 166 "../lib/HideManager.vala"
	_tmp15_ = wnck_screen;
#line 166 "../lib/HideManager.vala"
	g_signal_parse_name ("window-opened", wnck_screen_get_type (), &_tmp16_, NULL, FALSE);
#line 166 "../lib/HideManager.vala"
	g_signal_handlers_disconnect_matched (_tmp15_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp16_, 0, NULL, (GCallback) _plank_hide_manager_schedule_update_wnck_screen_window_opened, self);
#line 167 "../lib/HideManager.vala"
	_tmp17_ = wnck_screen;
#line 167 "../lib/HideManager.vala"
	g_signal_parse_name ("window-closed", wnck_screen_get_type (), &_tmp18_, NULL, FALSE);
#line 167 "../lib/HideManager.vala"
	g_signal_handlers_disconnect_matched (_tmp17_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp18_, 0, NULL, (GCallback) _plank_hide_manager_schedule_update_wnck_screen_window_closed, self);
#line 168 "../lib/HideManager.vala"
	_tmp19_ = wnck_screen;
#line 168 "../lib/HideManager.vala"
	g_signal_parse_name ("active-window-changed", wnck_screen_get_type (), &_tmp20_, NULL, FALSE);
#line 168 "../lib/HideManager.vala"
	g_signal_handlers_disconnect_matched (_tmp19_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp20_, 0, NULL, (GCallback) _plank_hide_manager_handle_active_window_changed_wnck_screen_active_window_changed, self);
#line 169 "../lib/HideManager.vala"
	_tmp21_ = wnck_screen;
#line 169 "../lib/HideManager.vala"
	g_signal_parse_name ("active-workspace-changed", wnck_screen_get_type (), &_tmp22_, NULL, FALSE);
#line 169 "../lib/HideManager.vala"
	g_signal_handlers_disconnect_matched (_tmp21_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp22_, 0, NULL, (GCallback) _plank_hide_manager_handle_workspace_changed_wnck_screen_active_workspace_changed, self);
#line 171 "../lib/HideManager.vala"
	plank_hide_manager_stop_timers (self);
#line 174 "../lib/HideManager.vala"
	gdk_window_add_filter (NULL, (GdkFilterFunc) plank_hide_manager_xevent_filter, self);
#line 176 "../lib/HideManager.vala"
	if (self->priv->barrier != ((PointerBarrier) 0)) {
#line 3385 "HideManager.c"
		GdkX11Display* gdk_display = NULL;
		PlankDockController* _tmp23_;
		PlankDockWindow* _tmp24_;
		PlankDockWindow* _tmp25_;
		GdkDisplay* _tmp26_;
		Display* display = NULL;
		GdkX11Display* _tmp27_;
		Display* _tmp28_;
		Display* _tmp29_;
#line 177 "../lib/HideManager.vala"
		_tmp23_ = self->priv->_controller;
#line 177 "../lib/HideManager.vala"
		_tmp24_ = plank_dock_controller_get_window (_tmp23_);
#line 177 "../lib/HideManager.vala"
		_tmp25_ = _tmp24_;
#line 177 "../lib/HideManager.vala"
		_tmp26_ = gtk_widget_get_display ((GtkWidget*) _tmp25_);
#line 177 "../lib/HideManager.vala"
		gdk_display = G_TYPE_CHECK_INSTANCE_TYPE (_tmp26_, gdk_x11_display_get_type ()) ? ((GdkX11Display*) _tmp26_) : NULL;
#line 178 "../lib/HideManager.vala"
		_tmp27_ = gdk_display;
#line 178 "../lib/HideManager.vala"
		_tmp28_ = gdk_x11_display_get_xdisplay (_tmp27_);
#line 178 "../lib/HideManager.vala"
		display = _tmp28_;
#line 179 "../lib/HideManager.vala"
		_tmp29_ = display;
#line 179 "../lib/HideManager.vala"
		XFixesDestroyPointerBarrier (_tmp29_, self->priv->barrier);
#line 180 "../lib/HideManager.vala"
		self->priv->barrier = (PointerBarrier) 0;
#line 3417 "HideManager.c"
	}
#line 76 "../lib/HideManager.vala"
	_g_object_unref0 (self->priv->_controller);
#line 56 "../lib/HideManager.vala"
	G_OBJECT_CLASS (plank_hide_manager_parent_class)->finalize (obj);
#line 3423 "HideManager.c"
}

/**
 * Handles checking if a dock should hide or not.
 */
static GType
plank_hide_manager_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankHideManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_hide_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankHideManager), 0, (GInstanceInitFunc) plank_hide_manager_instance_init, NULL };
	GType plank_hide_manager_type_id;
	plank_hide_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "PlankHideManager", &g_define_type_info, 0);
	PlankHideManager_private_offset = g_type_add_instance_private (plank_hide_manager_type_id, sizeof (PlankHideManagerPrivate));
	return plank_hide_manager_type_id;
}

GType
plank_hide_manager_get_type (void)
{
	static volatile gsize plank_hide_manager_type_id__volatile = 0;
	if (g_once_init_enter (&plank_hide_manager_type_id__volatile)) {
		GType plank_hide_manager_type_id;
		plank_hide_manager_type_id = plank_hide_manager_get_type_once ();
		g_once_init_leave (&plank_hide_manager_type_id__volatile, plank_hide_manager_type_id);
	}
	return plank_hide_manager_type_id__volatile;
}

static void
_vala_plank_hide_manager_get_property (GObject * object,
                                       guint property_id,
                                       GValue * value,
                                       GParamSpec * pspec)
{
	PlankHideManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_HIDE_MANAGER, PlankHideManager);
#line 56 "../lib/HideManager.vala"
	switch (property_id) {
#line 56 "../lib/HideManager.vala"
		case PLANK_HIDE_MANAGER_CONTROLLER_PROPERTY:
#line 56 "../lib/HideManager.vala"
		g_value_set_object (value, plank_hide_manager_get_controller (self));
#line 56 "../lib/HideManager.vala"
		break;
#line 56 "../lib/HideManager.vala"
		case PLANK_HIDE_MANAGER_HIDDEN_PROPERTY:
#line 56 "../lib/HideManager.vala"
		g_value_set_boolean (value, plank_hide_manager_get_Hidden (self));
#line 56 "../lib/HideManager.vala"
		break;
#line 56 "../lib/HideManager.vala"
		case PLANK_HIDE_MANAGER_DISABLED_PROPERTY:
#line 56 "../lib/HideManager.vala"
		g_value_set_boolean (value, plank_hide_manager_get_Disabled (self));
#line 56 "../lib/HideManager.vala"
		break;
#line 56 "../lib/HideManager.vala"
		case PLANK_HIDE_MANAGER_HOVERED_PROPERTY:
#line 56 "../lib/HideManager.vala"
		g_value_set_boolean (value, plank_hide_manager_get_Hovered (self));
#line 56 "../lib/HideManager.vala"
		break;
#line 3485 "HideManager.c"
		default:
#line 56 "../lib/HideManager.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 56 "../lib/HideManager.vala"
		break;
#line 3491 "HideManager.c"
	}
}

static void
_vala_plank_hide_manager_set_property (GObject * object,
                                       guint property_id,
                                       const GValue * value,
                                       GParamSpec * pspec)
{
	PlankHideManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_HIDE_MANAGER, PlankHideManager);
#line 56 "../lib/HideManager.vala"
	switch (property_id) {
#line 56 "../lib/HideManager.vala"
		case PLANK_HIDE_MANAGER_CONTROLLER_PROPERTY:
#line 56 "../lib/HideManager.vala"
		plank_hide_manager_set_controller (self, g_value_get_object (value));
#line 56 "../lib/HideManager.vala"
		break;
#line 56 "../lib/HideManager.vala"
		case PLANK_HIDE_MANAGER_HIDDEN_PROPERTY:
#line 56 "../lib/HideManager.vala"
		plank_hide_manager_set_Hidden (self, g_value_get_boolean (value));
#line 56 "../lib/HideManager.vala"
		break;
#line 56 "../lib/HideManager.vala"
		case PLANK_HIDE_MANAGER_DISABLED_PROPERTY:
#line 56 "../lib/HideManager.vala"
		plank_hide_manager_set_Disabled (self, g_value_get_boolean (value));
#line 56 "../lib/HideManager.vala"
		break;
#line 56 "../lib/HideManager.vala"
		case PLANK_HIDE_MANAGER_HOVERED_PROPERTY:
#line 56 "../lib/HideManager.vala"
		plank_hide_manager_set_Hovered (self, g_value_get_boolean (value));
#line 56 "../lib/HideManager.vala"
		break;
#line 3529 "HideManager.c"
		default:
#line 56 "../lib/HideManager.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 56 "../lib/HideManager.vala"
		break;
#line 3535 "HideManager.c"
	}
}

