/* DBusManager.c generated by valac 0.48.17, the Vala compiler
 * generated from DBusManager.vala, do not modify */

/**/
/*  Copyright (C) 2015 Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <gio/gio.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <gtk/gtk.h>
#include <gee.h>

#define PLANK_TYPE_DBUS_ITEMS_IFACE (plank_dbus_items_iface_get_type ())
#define PLANK_DBUS_ITEMS_IFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DBUS_ITEMS_IFACE, PlankDBusItemsIface))
#define PLANK_IS_DBUS_ITEMS_IFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DBUS_ITEMS_IFACE))
#define PLANK_DBUS_ITEMS_IFACE_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), PLANK_TYPE_DBUS_ITEMS_IFACE, PlankDBusItemsIfaceIface))

typedef struct _PlankDBusItemsIface PlankDBusItemsIface;
typedef struct _PlankDBusItemsIfaceIface PlankDBusItemsIfaceIface;

#define PLANK_TYPE_DBUS_ITEMS_IFACE_PROXY (plank_dbus_items_iface_proxy_get_type ())

#define PLANK_TYPE_DBUS_ITEMS (plank_dbus_items_get_type ())
#define PLANK_DBUS_ITEMS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DBUS_ITEMS, PlankDBusItems))
#define PLANK_DBUS_ITEMS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DBUS_ITEMS, PlankDBusItemsClass))
#define PLANK_IS_DBUS_ITEMS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DBUS_ITEMS))
#define PLANK_IS_DBUS_ITEMS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DBUS_ITEMS))
#define PLANK_DBUS_ITEMS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DBUS_ITEMS, PlankDBusItemsClass))

typedef struct _PlankDBusItems PlankDBusItems;
typedef struct _PlankDBusItemsClass PlankDBusItemsClass;
typedef struct _PlankDBusItemsPrivate PlankDBusItemsPrivate;

#define PLANK_TYPE_DOCK_ELEMENT (plank_dock_element_get_type ())
#define PLANK_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElement))
#define PLANK_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))
#define PLANK_IS_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_IS_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_DOCK_ELEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))

typedef struct _PlankDockElement PlankDockElement;
typedef struct _PlankDockElementClass PlankDockElementClass;

#define PLANK_TYPE_DOCK_CONTAINER (plank_dock_container_get_type ())
#define PLANK_DOCK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainer))
#define PLANK_DOCK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainerClass))
#define PLANK_IS_DOCK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_CONTAINER))
#define PLANK_IS_DOCK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_CONTAINER))
#define PLANK_DOCK_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainerClass))

typedef struct _PlankDockContainer PlankDockContainer;
typedef struct _PlankDockContainerClass PlankDockContainerClass;

#define PLANK_TYPE_DOCK_CONTROLLER (plank_dock_controller_get_type ())
#define PLANK_DOCK_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_CONTROLLER, PlankDockController))
#define PLANK_DOCK_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_CONTROLLER, PlankDockControllerClass))
#define PLANK_IS_DOCK_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_CONTROLLER))
#define PLANK_IS_DOCK_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_CONTROLLER))
#define PLANK_DOCK_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_CONTROLLER, PlankDockControllerClass))

typedef struct _PlankDockController PlankDockController;
typedef struct _PlankDockControllerClass PlankDockControllerClass;
enum  {
	PLANK_DBUS_ITEMS_0_PROPERTY,
	PLANK_DBUS_ITEMS_NUM_PROPERTIES
};
static GParamSpec* plank_dbus_items_properties[PLANK_DBUS_ITEMS_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define PLANK_TYPE_DOCK_ITEM_PROVIDER (plank_dock_item_provider_get_type ())
#define PLANK_DOCK_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ITEM_PROVIDER, PlankDockItemProvider))
#define PLANK_DOCK_ITEM_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ITEM_PROVIDER, PlankDockItemProviderClass))
#define PLANK_IS_DOCK_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ITEM_PROVIDER))
#define PLANK_IS_DOCK_ITEM_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ITEM_PROVIDER))
#define PLANK_DOCK_ITEM_PROVIDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ITEM_PROVIDER, PlankDockItemProviderClass))

typedef struct _PlankDockItemProvider PlankDockItemProvider;
typedef struct _PlankDockItemProviderClass PlankDockItemProviderClass;

#define PLANK_TYPE_APPLICATION_DOCK_ITEM_PROVIDER (plank_application_dock_item_provider_get_type ())
#define PLANK_APPLICATION_DOCK_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_APPLICATION_DOCK_ITEM_PROVIDER, PlankApplicationDockItemProvider))
#define PLANK_APPLICATION_DOCK_ITEM_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_APPLICATION_DOCK_ITEM_PROVIDER, PlankApplicationDockItemProviderClass))
#define PLANK_IS_APPLICATION_DOCK_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_APPLICATION_DOCK_ITEM_PROVIDER))
#define PLANK_IS_APPLICATION_DOCK_ITEM_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_APPLICATION_DOCK_ITEM_PROVIDER))
#define PLANK_APPLICATION_DOCK_ITEM_PROVIDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_APPLICATION_DOCK_ITEM_PROVIDER, PlankApplicationDockItemProviderClass))

typedef struct _PlankApplicationDockItemProvider PlankApplicationDockItemProvider;
typedef struct _PlankApplicationDockItemProviderClass PlankApplicationDockItemProviderClass;

#define PLANK_TYPE_DOCK_ITEM (plank_dock_item_get_type ())
#define PLANK_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ITEM, PlankDockItem))
#define PLANK_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ITEM, PlankDockItemClass))
#define PLANK_IS_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ITEM))
#define PLANK_IS_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ITEM))
#define PLANK_DOCK_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ITEM, PlankDockItemClass))

typedef struct _PlankDockItem PlankDockItem;
typedef struct _PlankDockItemClass PlankDockItemClass;

#define PLANK_TYPE_APPLICATION_DOCK_ITEM (plank_application_dock_item_get_type ())
#define PLANK_APPLICATION_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_APPLICATION_DOCK_ITEM, PlankApplicationDockItem))
#define PLANK_APPLICATION_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_APPLICATION_DOCK_ITEM, PlankApplicationDockItemClass))
#define PLANK_IS_APPLICATION_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_APPLICATION_DOCK_ITEM))
#define PLANK_IS_APPLICATION_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_APPLICATION_DOCK_ITEM))
#define PLANK_APPLICATION_DOCK_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_APPLICATION_DOCK_ITEM, PlankApplicationDockItemClass))

typedef struct _PlankApplicationDockItem PlankApplicationDockItem;
typedef struct _PlankApplicationDockItemClass PlankApplicationDockItemClass;

#define PLANK_TYPE_TRANSIENT_DOCK_ITEM (plank_transient_dock_item_get_type ())
#define PLANK_TRANSIENT_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_TRANSIENT_DOCK_ITEM, PlankTransientDockItem))
#define PLANK_TRANSIENT_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_TRANSIENT_DOCK_ITEM, PlankTransientDockItemClass))
#define PLANK_IS_TRANSIENT_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_TRANSIENT_DOCK_ITEM))
#define PLANK_IS_TRANSIENT_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_TRANSIENT_DOCK_ITEM))
#define PLANK_TRANSIENT_DOCK_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_TRANSIENT_DOCK_ITEM, PlankTransientDockItemClass))

typedef struct _PlankTransientDockItem PlankTransientDockItem;
typedef struct _PlankTransientDockItemClass PlankTransientDockItemClass;

#define PLANK_TYPE_POSITION_MANAGER (plank_position_manager_get_type ())
#define PLANK_POSITION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_POSITION_MANAGER, PlankPositionManager))
#define PLANK_POSITION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_POSITION_MANAGER, PlankPositionManagerClass))
#define PLANK_IS_POSITION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_POSITION_MANAGER))
#define PLANK_IS_POSITION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_POSITION_MANAGER))
#define PLANK_POSITION_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_POSITION_MANAGER, PlankPositionManagerClass))

typedef struct _PlankPositionManager PlankPositionManager;
typedef struct _PlankPositionManagerClass PlankPositionManagerClass;

#define PLANK_TYPE_DBUS_MANAGER (plank_dbus_manager_get_type ())
#define PLANK_DBUS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DBUS_MANAGER, PlankDBusManager))
#define PLANK_DBUS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DBUS_MANAGER, PlankDBusManagerClass))
#define PLANK_IS_DBUS_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DBUS_MANAGER))
#define PLANK_IS_DBUS_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DBUS_MANAGER))
#define PLANK_DBUS_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DBUS_MANAGER, PlankDBusManagerClass))

typedef struct _PlankDBusManager PlankDBusManager;
typedef struct _PlankDBusManagerClass PlankDBusManagerClass;
typedef struct _PlankDBusManagerPrivate PlankDBusManagerPrivate;
enum  {
	PLANK_DBUS_MANAGER_0_PROPERTY,
	PLANK_DBUS_MANAGER_CONTROLLER_PROPERTY,
	PLANK_DBUS_MANAGER_NUM_PROPERTIES
};
static GParamSpec* plank_dbus_manager_properties[PLANK_DBUS_MANAGER_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _PlankDBusItemsIfaceIface {
	GTypeInterface parent_iface;
	gboolean (*add) (PlankDBusItemsIface* self, const gchar* uri, GError** error);
	gboolean (*remove) (PlankDBusItemsIface* self, const gchar* uri, GError** error);
	gint (*get_count) (PlankDBusItemsIface* self, GError** error);
	gchar** (*get_persistent_applications) (PlankDBusItemsIface* self, gint* result_length1, GError** error);
	gchar** (*get_transient_applications) (PlankDBusItemsIface* self, gint* result_length1, GError** error);
	gboolean (*get_hover_position) (PlankDBusItemsIface* self, const gchar* uri, gint* x, gint* y, GtkPositionType* dock_position, GError** error);
};

struct _PlankDBusItems {
	GObject parent_instance;
	PlankDBusItemsPrivate * priv;
};

struct _PlankDBusItemsClass {
	GObjectClass parent_class;
};

struct _PlankDBusItemsPrivate {
	PlankDockController* controller;
	guint changed_timer_id;
};

struct _PlankDBusManager {
	GObject parent_instance;
	PlankDBusManagerPrivate * priv;
};

struct _PlankDBusManagerClass {
	GObjectClass parent_class;
};

struct _PlankDBusManagerPrivate {
	PlankDockController* _controller;
	GDBusConnection* connection;
	gchar* dock_object_path;
	guint dbus_items_signal_id;
	guint dbus_client_ping_signal_id;
};

static gint PlankDBusItems_private_offset;
static gpointer plank_dbus_items_parent_class = NULL;
static PlankDBusItemsIfaceIface * plank_dbus_items_plank_dbus_items_iface_parent_iface = NULL;
static gint PlankDBusManager_private_offset;
static gpointer plank_dbus_manager_parent_class = NULL;

GType plank_dbus_items_iface_proxy_get_type (void) G_GNUC_CONST;
G_GNUC_INTERNAL guint plank_dbus_items_iface_register_object (void* object,
                                              GDBusConnection* connection,
                                              const gchar* path,
                                              GError** error);
G_GNUC_INTERNAL GType plank_dbus_items_iface_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
G_GNUC_INTERNAL GType plank_dbus_items_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDBusItems, g_object_unref)
GType plank_dock_element_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockElement, g_object_unref)
GType plank_dock_container_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockContainer, g_object_unref)
GType plank_dock_controller_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockController, g_object_unref)
static void plank_dbus_items_handle_elements_changed (PlankDBusItems* self);
static void _plank_dbus_items_handle_elements_changed_plank_dock_container_elements_changed (PlankDockContainer* _sender,
                                                                                      GeeList* added,
                                                                                      GeeList* removed,
                                                                                      gpointer self);
G_GNUC_INTERNAL PlankDBusItems* plank_dbus_items_new (PlankDockController* _controller);
G_GNUC_INTERNAL PlankDBusItems* plank_dbus_items_construct (GType object_type,
                                            PlankDockController* _controller);
static gboolean __lambda64_ (PlankDBusItems* self);
static gboolean ___lambda64__gsource_func (gpointer self);
static gboolean plank_dbus_items_real_add (PlankDBusItemsIface* base,
                                    const gchar* uri,
                                    GError** error);
GType plank_dock_item_provider_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockItemProvider, g_object_unref)
GType plank_application_dock_item_provider_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankApplicationDockItemProvider, g_object_unref)
PlankDockItemProvider* plank_dock_controller_get_default_provider (PlankDockController* self);
GType plank_dock_item_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockItem, g_object_unref)
PlankDockItem* plank_dock_item_provider_item_for_uri (PlankDockItemProvider* self,
                                                      const gchar* uri);
GType plank_application_dock_item_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankApplicationDockItem, g_object_unref)
GType plank_transient_dock_item_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankTransientDockItem, g_object_unref)
gboolean plank_dock_item_provider_add_item_with_uri (PlankDockItemProvider* self,
                                                     const gchar* uri,
                                                     PlankDockItem* target);
static gboolean plank_dbus_items_real_remove (PlankDBusItemsIface* base,
                                       const gchar* uri,
                                       GError** error);
gboolean plank_dock_container_remove (PlankDockContainer* self,
                                      PlankDockElement* element);
static gint plank_dbus_items_real_get_count (PlankDBusItemsIface* base,
                                      GError** error);
GeeArrayList* plank_dock_controller_get_VisibleItems (PlankDockController* self);
static gchar** plank_dbus_items_real_get_persistent_applications (PlankDBusItemsIface* base,
                                                           gint* result_length1,
                                                           GError** error);
void plank_logger_verbose (const gchar* msg,
                           ...);
GeeArrayList* plank_dock_controller_get_Items (PlankDockController* self);
const gchar* plank_dock_item_get_Launcher (PlankDockItem* self);
static void _vala_array_add1 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
static gchar** plank_dbus_items_real_get_transient_applications (PlankDBusItemsIface* base,
                                                          gint* result_length1,
                                                          GError** error);
static void _vala_array_add2 (gchar** * array,
                       gint* length,
                       gint* size,
                       gchar* value);
static gboolean plank_dbus_items_real_get_hover_position (PlankDBusItemsIface* base,
                                                   const gchar* uri,
                                                   gint* x,
                                                   gint* y,
                                                   GtkPositionType* dock_position,
                                                   GError** error);
GType plank_position_manager_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankPositionManager, g_object_unref)
PlankPositionManager* plank_dock_controller_get_position_manager (PlankDockController* self);
void plank_position_manager_get_hover_position (PlankPositionManager* self,
                                                PlankDockItem* hovered,
                                                gint* x,
                                                gint* y);
GtkPositionType plank_position_manager_get_Position (PlankPositionManager* self);
G_GNUC_INTERNAL gboolean plank_dbus_items_iface_add (PlankDBusItemsIface* self,
                                     const gchar* uri,
                                     GError** error);
G_GNUC_INTERNAL gboolean plank_dbus_items_iface_remove (PlankDBusItemsIface* self,
                                        const gchar* uri,
                                        GError** error);
G_GNUC_INTERNAL gint plank_dbus_items_iface_get_count (PlankDBusItemsIface* self,
                                       GError** error);
G_GNUC_INTERNAL gchar** plank_dbus_items_iface_get_persistent_applications (PlankDBusItemsIface* self,
                                                            gint* result_length1,
                                                            GError** error);
G_GNUC_INTERNAL gchar** plank_dbus_items_iface_get_transient_applications (PlankDBusItemsIface* self,
                                                           gint* result_length1,
                                                           GError** error);
G_GNUC_INTERNAL gboolean plank_dbus_items_iface_get_hover_position (PlankDBusItemsIface* self,
                                                    const gchar* uri,
                                                    gint* x,
                                                    gint* y,
                                                    GtkPositionType* dock_position,
                                                    GError** error);
static void plank_dbus_items_finalize (GObject * obj);
static GType plank_dbus_items_get_type_once (void);
GType plank_dbus_manager_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDBusManager, g_object_unref)
PlankDBusManager* plank_dbus_manager_new (PlankDockController* controller);
PlankDBusManager* plank_dbus_manager_construct (GType object_type,
                                                PlankDockController* controller);
static void plank_dbus_manager_handle_client_ping (GDBusConnection* connection,
                                            const gchar* sender_name,
                                            const gchar* object_path,
                                            const gchar* interface_name,
                                            const gchar* signal_name,
                                            GVariant* parameters,
                                            PlankDBusManager* self);
#define PLANK_DBUS_DOCK_INTERFACE_NAME "net.launchpad.plank"
#define PLANK_DBUS_PING_NAME "Ping"
static PlankDockController* plank_dbus_manager_get_controller (PlankDBusManager* self);
static void plank_dbus_manager_set_controller (PlankDBusManager* self,
                                        PlankDockController* value);
static GObject * plank_dbus_manager_constructor (GType type,
                                          guint n_construct_properties,
                                          GObjectConstructParam * construct_properties);
const gchar* plank_dock_controller_get_name (PlankDockController* self);
#define PLANK_DBUS_CLIENT_INTERFACE_NAME "net.launchpad.plank.Client"
static void plank_dbus_manager_finalize (GObject * obj);
static GType plank_dbus_manager_get_type_once (void);
static void _vala_plank_dbus_manager_get_property (GObject * object,
                                            guint property_id,
                                            GValue * value,
                                            GParamSpec * pspec);
static void _vala_plank_dbus_manager_set_property (GObject * object,
                                            guint property_id,
                                            const GValue * value,
                                            GParamSpec * pspec);

static inline gpointer
plank_dbus_items_get_instance_private (PlankDBusItems* self)
{
	return G_STRUCT_MEMBER_P (self, PlankDBusItems_private_offset);
}

static void
_plank_dbus_items_handle_elements_changed_plank_dock_container_elements_changed (PlankDockContainer* _sender,
                                                                                 GeeList* added,
                                                                                 GeeList* removed,
                                                                                 gpointer self)
{
#line 38 "../lib/DBusManager.vala"
	plank_dbus_items_handle_elements_changed ((PlankDBusItems*) self);
#line 367 "DBusManager.c"
}

static gpointer
_g_object_ref0 (gpointer self)
{
#line 32 "../lib/DBusManager.vala"
	return self ? g_object_ref (self) : NULL;
#line 375 "DBusManager.c"
}

G_GNUC_INTERNAL PlankDBusItems*
plank_dbus_items_construct (GType object_type,
                            PlankDockController* _controller)
{
	PlankDBusItems * self = NULL;
	PlankDockController* _tmp0_;
	PlankDockController* _tmp1_;
#line 30 "../lib/DBusManager.vala"
	g_return_val_if_fail (_controller != NULL, NULL);
#line 30 "../lib/DBusManager.vala"
	self = (PlankDBusItems*) g_object_new (object_type, NULL);
#line 32 "../lib/DBusManager.vala"
	_tmp0_ = _g_object_ref0 (_controller);
#line 32 "../lib/DBusManager.vala"
	_g_object_unref0 (self->priv->controller);
#line 32 "../lib/DBusManager.vala"
	self->priv->controller = _tmp0_;
#line 33 "../lib/DBusManager.vala"
	_tmp1_ = self->priv->controller;
#line 33 "../lib/DBusManager.vala"
	g_signal_connect_object ((PlankDockContainer*) _tmp1_, "elements-changed", (GCallback) _plank_dbus_items_handle_elements_changed_plank_dock_container_elements_changed, self, 0);
#line 30 "../lib/DBusManager.vala"
	return self;
#line 401 "DBusManager.c"
}

G_GNUC_INTERNAL PlankDBusItems*
plank_dbus_items_new (PlankDockController* _controller)
{
#line 30 "../lib/DBusManager.vala"
	return plank_dbus_items_construct (PLANK_TYPE_DBUS_ITEMS, _controller);
#line 409 "DBusManager.c"
}

static gboolean
__lambda64_ (PlankDBusItems* self)
{
	gboolean result = FALSE;
#line 53 "../lib/DBusManager.vala"
	self->priv->changed_timer_id = 0U;
#line 54 "../lib/DBusManager.vala"
	g_signal_emit_by_name ((PlankDBusItemsIface*) self, "changed");
#line 55 "../lib/DBusManager.vala"
	result = FALSE;
#line 55 "../lib/DBusManager.vala"
	return result;
#line 424 "DBusManager.c"
}

static gboolean
___lambda64__gsource_func (gpointer self)
{
	gboolean result;
	result = __lambda64_ ((PlankDBusItems*) self);
#line 52 "../lib/DBusManager.vala"
	return result;
#line 434 "DBusManager.c"
}

static void
plank_dbus_items_handle_elements_changed (PlankDBusItems* self)
{
#line 46 "../lib/DBusManager.vala"
	g_return_if_fail (self != NULL);
#line 48 "../lib/DBusManager.vala"
	if (self->priv->changed_timer_id > 0U) {
#line 49 "../lib/DBusManager.vala"
		return;
#line 446 "DBusManager.c"
	}
#line 52 "../lib/DBusManager.vala"
	self->priv->changed_timer_id = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) 500, ___lambda64__gsource_func, g_object_ref (self), g_object_unref);
#line 450 "DBusManager.c"
}

static gboolean
plank_dbus_items_real_add (PlankDBusItemsIface* base,
                           const gchar* uri,
                           GError** error)
{
	PlankDBusItems * self;
	PlankApplicationDockItemProvider* provider = NULL;
	PlankDockController* _tmp0_;
	PlankDockItemProvider* _tmp1_;
	PlankDockItemProvider* _tmp2_;
	PlankApplicationDockItemProvider* _tmp3_;
	PlankDockItem* item = NULL;
	PlankApplicationDockItemProvider* _tmp4_;
	PlankDockItem* _tmp5_;
	gboolean _tmp6_ = FALSE;
	PlankDockItem* _tmp7_;
	PlankApplicationDockItemProvider* _tmp10_;
	gboolean result = FALSE;
#line 59 "../lib/DBusManager.vala"
	self = (PlankDBusItems*) base;
#line 59 "../lib/DBusManager.vala"
	g_return_val_if_fail (uri != NULL, FALSE);
#line 61 "../lib/DBusManager.vala"
	g_debug ("DBusManager.vala:61: Try to remotely add '%s'", uri);
#line 63 "../lib/DBusManager.vala"
	_tmp0_ = self->priv->controller;
#line 63 "../lib/DBusManager.vala"
	_tmp1_ = plank_dock_controller_get_default_provider (_tmp0_);
#line 63 "../lib/DBusManager.vala"
	_tmp2_ = _tmp1_;
#line 63 "../lib/DBusManager.vala"
	provider = PLANK_IS_APPLICATION_DOCK_ITEM_PROVIDER (_tmp2_) ? ((PlankApplicationDockItemProvider*) _tmp2_) : NULL;
#line 64 "../lib/DBusManager.vala"
	_tmp3_ = provider;
#line 64 "../lib/DBusManager.vala"
	if (_tmp3_ == NULL) {
#line 65 "../lib/DBusManager.vala"
		result = FALSE;
#line 65 "../lib/DBusManager.vala"
		return result;
#line 493 "DBusManager.c"
	}
#line 67 "../lib/DBusManager.vala"
	_tmp4_ = provider;
#line 67 "../lib/DBusManager.vala"
	_tmp5_ = plank_dock_item_provider_item_for_uri ((PlankDockItemProvider*) _tmp4_, uri);
#line 67 "../lib/DBusManager.vala"
	item = _tmp5_;
#line 68 "../lib/DBusManager.vala"
	_tmp7_ = item;
#line 68 "../lib/DBusManager.vala"
	if (_tmp7_ != NULL) {
#line 505 "DBusManager.c"
		PlankDockItem* _tmp8_;
#line 68 "../lib/DBusManager.vala"
		_tmp8_ = item;
#line 68 "../lib/DBusManager.vala"
		_tmp6_ = PLANK_IS_TRANSIENT_DOCK_ITEM (_tmp8_);
#line 511 "DBusManager.c"
	} else {
#line 68 "../lib/DBusManager.vala"
		_tmp6_ = FALSE;
#line 515 "DBusManager.c"
	}
#line 68 "../lib/DBusManager.vala"
	if (_tmp6_) {
#line 519 "DBusManager.c"
		PlankDockItem* _tmp9_;
#line 69 "../lib/DBusManager.vala"
		_tmp9_ = item;
#line 69 "../lib/DBusManager.vala"
		g_signal_emit_by_name ((PlankApplicationDockItem*) G_TYPE_CHECK_INSTANCE_CAST (_tmp9_, PLANK_TYPE_TRANSIENT_DOCK_ITEM, PlankTransientDockItem), "pin-launcher");
#line 70 "../lib/DBusManager.vala"
		result = TRUE;
#line 70 "../lib/DBusManager.vala"
		return result;
#line 529 "DBusManager.c"
	}
#line 73 "../lib/DBusManager.vala"
	_tmp10_ = provider;
#line 73 "../lib/DBusManager.vala"
	result = plank_dock_item_provider_add_item_with_uri ((PlankDockItemProvider*) _tmp10_, uri, NULL);
#line 73 "../lib/DBusManager.vala"
	return result;
#line 537 "DBusManager.c"
}

static gboolean
plank_dbus_items_real_remove (PlankDBusItemsIface* base,
                              const gchar* uri,
                              GError** error)
{
	PlankDBusItems * self;
	PlankApplicationDockItemProvider* provider = NULL;
	PlankDockController* _tmp0_;
	PlankDockItemProvider* _tmp1_;
	PlankDockItemProvider* _tmp2_;
	PlankApplicationDockItemProvider* _tmp3_;
	PlankDockItem* item = NULL;
	PlankApplicationDockItemProvider* _tmp4_;
	PlankDockItem* _tmp5_;
	PlankDockItem* _tmp6_;
	PlankDockItem* _tmp7_;
	PlankApplicationDockItemProvider* _tmp10_;
	PlankDockItem* _tmp11_;
	gboolean result = FALSE;
#line 76 "../lib/DBusManager.vala"
	self = (PlankDBusItems*) base;
#line 76 "../lib/DBusManager.vala"
	g_return_val_if_fail (uri != NULL, FALSE);
#line 78 "../lib/DBusManager.vala"
	g_debug ("DBusManager.vala:78: Try to remotely remove '%s'", uri);
#line 80 "../lib/DBusManager.vala"
	_tmp0_ = self->priv->controller;
#line 80 "../lib/DBusManager.vala"
	_tmp1_ = plank_dock_controller_get_default_provider (_tmp0_);
#line 80 "../lib/DBusManager.vala"
	_tmp2_ = _tmp1_;
#line 80 "../lib/DBusManager.vala"
	provider = PLANK_IS_APPLICATION_DOCK_ITEM_PROVIDER (_tmp2_) ? ((PlankApplicationDockItemProvider*) _tmp2_) : NULL;
#line 81 "../lib/DBusManager.vala"
	_tmp3_ = provider;
#line 81 "../lib/DBusManager.vala"
	if (_tmp3_ == NULL) {
#line 82 "../lib/DBusManager.vala"
		result = FALSE;
#line 82 "../lib/DBusManager.vala"
		return result;
#line 581 "DBusManager.c"
	}
#line 84 "../lib/DBusManager.vala"
	_tmp4_ = provider;
#line 84 "../lib/DBusManager.vala"
	_tmp5_ = plank_dock_item_provider_item_for_uri ((PlankDockItemProvider*) _tmp4_, uri);
#line 84 "../lib/DBusManager.vala"
	item = _tmp5_;
#line 85 "../lib/DBusManager.vala"
	_tmp6_ = item;
#line 85 "../lib/DBusManager.vala"
	if (_tmp6_ == NULL) {
#line 86 "../lib/DBusManager.vala"
		result = FALSE;
#line 86 "../lib/DBusManager.vala"
		return result;
#line 597 "DBusManager.c"
	}
#line 88 "../lib/DBusManager.vala"
	_tmp7_ = item;
#line 88 "../lib/DBusManager.vala"
	if (PLANK_IS_APPLICATION_DOCK_ITEM (_tmp7_)) {
#line 603 "DBusManager.c"
		PlankDockItem* _tmp8_;
#line 89 "../lib/DBusManager.vala"
		_tmp8_ = item;
#line 89 "../lib/DBusManager.vala"
		if (!PLANK_IS_TRANSIENT_DOCK_ITEM (_tmp8_)) {
#line 609 "DBusManager.c"
			PlankDockItem* _tmp9_;
#line 90 "../lib/DBusManager.vala"
			_tmp9_ = item;
#line 90 "../lib/DBusManager.vala"
			g_signal_emit_by_name (G_TYPE_CHECK_INSTANCE_CAST (_tmp9_, PLANK_TYPE_APPLICATION_DOCK_ITEM, PlankApplicationDockItem), "pin-launcher");
#line 615 "DBusManager.c"
		}
#line 91 "../lib/DBusManager.vala"
		result = TRUE;
#line 91 "../lib/DBusManager.vala"
		return result;
#line 621 "DBusManager.c"
	}
#line 94 "../lib/DBusManager.vala"
	_tmp10_ = provider;
#line 94 "../lib/DBusManager.vala"
	_tmp11_ = item;
#line 94 "../lib/DBusManager.vala"
	result = plank_dock_container_remove ((PlankDockContainer*) _tmp10_, (PlankDockElement*) _tmp11_);
#line 94 "../lib/DBusManager.vala"
	return result;
#line 631 "DBusManager.c"
}

static gint
plank_dbus_items_real_get_count (PlankDBusItemsIface* base,
                                 GError** error)
{
	PlankDBusItems * self;
	PlankDockController* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gint result = 0;
#line 97 "../lib/DBusManager.vala"
	self = (PlankDBusItems*) base;
#line 99 "../lib/DBusManager.vala"
	_tmp0_ = self->priv->controller;
#line 99 "../lib/DBusManager.vala"
	_tmp1_ = plank_dock_controller_get_VisibleItems (_tmp0_);
#line 99 "../lib/DBusManager.vala"
	_tmp2_ = _tmp1_;
#line 99 "../lib/DBusManager.vala"
	_tmp3_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp2_);
#line 99 "../lib/DBusManager.vala"
	_tmp4_ = _tmp3_;
#line 99 "../lib/DBusManager.vala"
	result = _tmp4_;
#line 99 "../lib/DBusManager.vala"
	return result;
#line 661 "DBusManager.c"
}

static void
_vala_array_add1 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
#line 114 "../lib/DBusManager.vala"
	if ((*length) == (*size)) {
#line 114 "../lib/DBusManager.vala"
		*size = (*size) ? (2 * (*size)) : 4;
#line 114 "../lib/DBusManager.vala"
		*array = g_renew (gchar*, *array, (*size) + 1);
#line 676 "DBusManager.c"
	}
#line 114 "../lib/DBusManager.vala"
	(*array)[(*length)++] = value;
#line 114 "../lib/DBusManager.vala"
	(*array)[*length] = NULL;
#line 682 "DBusManager.c"
}

static gchar**
plank_dbus_items_real_get_persistent_applications (PlankDBusItemsIface* base,
                                                   gint* result_length1,
                                                   GError** error)
{
	PlankDBusItems * self;
	GeeArrayList* items = NULL;
	PlankDockController* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	GeeArrayList* _tmp3_;
	gchar** _result_ = NULL;
	gchar** _tmp4_;
	gint _result__length1;
	gint __result__size_;
	const gchar* launcher = NULL;
	gchar** _tmp25_;
	gint _tmp25__length1;
	gchar** result = NULL;
#line 102 "../lib/DBusManager.vala"
	self = (PlankDBusItems*) base;
#line 104 "../lib/DBusManager.vala"
	plank_logger_verbose ("Remotely list persistent items", NULL);
#line 106 "../lib/DBusManager.vala"
	_tmp0_ = self->priv->controller;
#line 106 "../lib/DBusManager.vala"
	_tmp1_ = plank_dock_controller_get_Items (_tmp0_);
#line 106 "../lib/DBusManager.vala"
	_tmp2_ = _tmp1_;
#line 106 "../lib/DBusManager.vala"
	_tmp3_ = _g_object_ref0 (_tmp2_);
#line 106 "../lib/DBusManager.vala"
	items = _tmp3_;
#line 108 "../lib/DBusManager.vala"
	_tmp4_ = g_new0 (gchar*, 0 + 1);
#line 108 "../lib/DBusManager.vala"
	_result_ = _tmp4_;
#line 108 "../lib/DBusManager.vala"
	_result__length1 = 0;
#line 108 "../lib/DBusManager.vala"
	__result__size_ = _result__length1;
#line 726 "DBusManager.c"
	{
		GeeArrayList* _item_list = NULL;
		GeeArrayList* _tmp5_;
		GeeArrayList* _tmp6_;
		gint _item_size = 0;
		GeeArrayList* _tmp7_;
		gint _tmp8_;
		gint _tmp9_;
		gint _item_index = 0;
#line 110 "../lib/DBusManager.vala"
		_tmp5_ = items;
#line 110 "../lib/DBusManager.vala"
		_tmp6_ = _g_object_ref0 (_tmp5_);
#line 110 "../lib/DBusManager.vala"
		_item_list = _tmp6_;
#line 110 "../lib/DBusManager.vala"
		_tmp7_ = _item_list;
#line 110 "../lib/DBusManager.vala"
		_tmp8_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp7_);
#line 110 "../lib/DBusManager.vala"
		_tmp9_ = _tmp8_;
#line 110 "../lib/DBusManager.vala"
		_item_size = _tmp9_;
#line 110 "../lib/DBusManager.vala"
		_item_index = -1;
#line 110 "../lib/DBusManager.vala"
		while (TRUE) {
#line 754 "DBusManager.c"
			gint _tmp10_;
			gint _tmp11_;
			PlankDockItem* item = NULL;
			GeeArrayList* _tmp12_;
			gpointer _tmp13_;
			gboolean _tmp14_ = FALSE;
			PlankDockItem* _tmp15_;
#line 110 "../lib/DBusManager.vala"
			_item_index = _item_index + 1;
#line 110 "../lib/DBusManager.vala"
			_tmp10_ = _item_index;
#line 110 "../lib/DBusManager.vala"
			_tmp11_ = _item_size;
#line 110 "../lib/DBusManager.vala"
			if (!(_tmp10_ < _tmp11_)) {
#line 110 "../lib/DBusManager.vala"
				break;
#line 772 "DBusManager.c"
			}
#line 110 "../lib/DBusManager.vala"
			_tmp12_ = _item_list;
#line 110 "../lib/DBusManager.vala"
			_tmp13_ = gee_abstract_list_get ((GeeAbstractList*) _tmp12_, _item_index);
#line 110 "../lib/DBusManager.vala"
			item = (PlankDockItem*) _tmp13_;
#line 111 "../lib/DBusManager.vala"
			_tmp15_ = item;
#line 111 "../lib/DBusManager.vala"
			if (PLANK_IS_APPLICATION_DOCK_ITEM (_tmp15_)) {
#line 784 "DBusManager.c"
				PlankDockItem* _tmp16_;
#line 111 "../lib/DBusManager.vala"
				_tmp16_ = item;
#line 111 "../lib/DBusManager.vala"
				_tmp14_ = !PLANK_IS_TRANSIENT_DOCK_ITEM (_tmp16_);
#line 790 "DBusManager.c"
			} else {
#line 111 "../lib/DBusManager.vala"
				_tmp14_ = FALSE;
#line 794 "DBusManager.c"
			}
#line 111 "../lib/DBusManager.vala"
			if (_tmp14_) {
#line 798 "DBusManager.c"
				PlankDockItem* _tmp17_;
				const gchar* _tmp18_;
				const gchar* _tmp19_;
				gboolean _tmp20_ = FALSE;
				const gchar* _tmp21_;
#line 112 "../lib/DBusManager.vala"
				_tmp17_ = item;
#line 112 "../lib/DBusManager.vala"
				_tmp18_ = plank_dock_item_get_Launcher (_tmp17_);
#line 112 "../lib/DBusManager.vala"
				_tmp19_ = _tmp18_;
#line 112 "../lib/DBusManager.vala"
				launcher = _tmp19_;
#line 113 "../lib/DBusManager.vala"
				_tmp21_ = launcher;
#line 113 "../lib/DBusManager.vala"
				if (_tmp21_ != NULL) {
#line 816 "DBusManager.c"
					const gchar* _tmp22_;
#line 113 "../lib/DBusManager.vala"
					_tmp22_ = launcher;
#line 113 "../lib/DBusManager.vala"
					_tmp20_ = g_strcmp0 (_tmp22_, "") != 0;
#line 822 "DBusManager.c"
				} else {
#line 113 "../lib/DBusManager.vala"
					_tmp20_ = FALSE;
#line 826 "DBusManager.c"
				}
#line 113 "../lib/DBusManager.vala"
				if (_tmp20_) {
#line 830 "DBusManager.c"
					const gchar* _tmp23_;
					gchar* _tmp24_;
#line 114 "../lib/DBusManager.vala"
					_tmp23_ = launcher;
#line 114 "../lib/DBusManager.vala"
					_tmp24_ = g_strdup (_tmp23_);
#line 114 "../lib/DBusManager.vala"
					_vala_array_add1 (&_result_, &_result__length1, &__result__size_, _tmp24_);
#line 839 "DBusManager.c"
				}
			}
		}
#line 110 "../lib/DBusManager.vala"
		_g_object_unref0 (_item_list);
#line 845 "DBusManager.c"
	}
#line 118 "../lib/DBusManager.vala"
	_tmp25_ = _result_;
#line 118 "../lib/DBusManager.vala"
	_tmp25__length1 = _result__length1;
#line 118 "../lib/DBusManager.vala"
	if (result_length1) {
#line 118 "../lib/DBusManager.vala"
		*result_length1 = _tmp25__length1;
#line 855 "DBusManager.c"
	}
#line 118 "../lib/DBusManager.vala"
	result = _tmp25_;
#line 118 "../lib/DBusManager.vala"
	_g_object_unref0 (items);
#line 118 "../lib/DBusManager.vala"
	return result;
#line 863 "DBusManager.c"
}

static void
_vala_array_add2 (gchar** * array,
                  gint* length,
                  gint* size,
                  gchar* value)
{
#line 133 "../lib/DBusManager.vala"
	if ((*length) == (*size)) {
#line 133 "../lib/DBusManager.vala"
		*size = (*size) ? (2 * (*size)) : 4;
#line 133 "../lib/DBusManager.vala"
		*array = g_renew (gchar*, *array, (*size) + 1);
#line 878 "DBusManager.c"
	}
#line 133 "../lib/DBusManager.vala"
	(*array)[(*length)++] = value;
#line 133 "../lib/DBusManager.vala"
	(*array)[*length] = NULL;
#line 884 "DBusManager.c"
}

static gchar**
plank_dbus_items_real_get_transient_applications (PlankDBusItemsIface* base,
                                                  gint* result_length1,
                                                  GError** error)
{
	PlankDBusItems * self;
	GeeArrayList* items = NULL;
	PlankDockController* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	GeeArrayList* _tmp3_;
	gchar** _result_ = NULL;
	gchar** _tmp4_;
	gint _result__length1;
	gint __result__size_;
	const gchar* launcher = NULL;
	gchar** _tmp23_;
	gint _tmp23__length1;
	gchar** result = NULL;
#line 121 "../lib/DBusManager.vala"
	self = (PlankDBusItems*) base;
#line 123 "../lib/DBusManager.vala"
	plank_logger_verbose ("Remotely list transient items", NULL);
#line 125 "../lib/DBusManager.vala"
	_tmp0_ = self->priv->controller;
#line 125 "../lib/DBusManager.vala"
	_tmp1_ = plank_dock_controller_get_Items (_tmp0_);
#line 125 "../lib/DBusManager.vala"
	_tmp2_ = _tmp1_;
#line 125 "../lib/DBusManager.vala"
	_tmp3_ = _g_object_ref0 (_tmp2_);
#line 125 "../lib/DBusManager.vala"
	items = _tmp3_;
#line 127 "../lib/DBusManager.vala"
	_tmp4_ = g_new0 (gchar*, 0 + 1);
#line 127 "../lib/DBusManager.vala"
	_result_ = _tmp4_;
#line 127 "../lib/DBusManager.vala"
	_result__length1 = 0;
#line 127 "../lib/DBusManager.vala"
	__result__size_ = _result__length1;
#line 928 "DBusManager.c"
	{
		GeeArrayList* _item_list = NULL;
		GeeArrayList* _tmp5_;
		GeeArrayList* _tmp6_;
		gint _item_size = 0;
		GeeArrayList* _tmp7_;
		gint _tmp8_;
		gint _tmp9_;
		gint _item_index = 0;
#line 129 "../lib/DBusManager.vala"
		_tmp5_ = items;
#line 129 "../lib/DBusManager.vala"
		_tmp6_ = _g_object_ref0 (_tmp5_);
#line 129 "../lib/DBusManager.vala"
		_item_list = _tmp6_;
#line 129 "../lib/DBusManager.vala"
		_tmp7_ = _item_list;
#line 129 "../lib/DBusManager.vala"
		_tmp8_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp7_);
#line 129 "../lib/DBusManager.vala"
		_tmp9_ = _tmp8_;
#line 129 "../lib/DBusManager.vala"
		_item_size = _tmp9_;
#line 129 "../lib/DBusManager.vala"
		_item_index = -1;
#line 129 "../lib/DBusManager.vala"
		while (TRUE) {
#line 956 "DBusManager.c"
			gint _tmp10_;
			gint _tmp11_;
			PlankDockItem* item = NULL;
			GeeArrayList* _tmp12_;
			gpointer _tmp13_;
			PlankDockItem* _tmp14_;
#line 129 "../lib/DBusManager.vala"
			_item_index = _item_index + 1;
#line 129 "../lib/DBusManager.vala"
			_tmp10_ = _item_index;
#line 129 "../lib/DBusManager.vala"
			_tmp11_ = _item_size;
#line 129 "../lib/DBusManager.vala"
			if (!(_tmp10_ < _tmp11_)) {
#line 129 "../lib/DBusManager.vala"
				break;
#line 973 "DBusManager.c"
			}
#line 129 "../lib/DBusManager.vala"
			_tmp12_ = _item_list;
#line 129 "../lib/DBusManager.vala"
			_tmp13_ = gee_abstract_list_get ((GeeAbstractList*) _tmp12_, _item_index);
#line 129 "../lib/DBusManager.vala"
			item = (PlankDockItem*) _tmp13_;
#line 130 "../lib/DBusManager.vala"
			_tmp14_ = item;
#line 130 "../lib/DBusManager.vala"
			if (PLANK_IS_TRANSIENT_DOCK_ITEM (_tmp14_)) {
#line 985 "DBusManager.c"
				PlankDockItem* _tmp15_;
				const gchar* _tmp16_;
				const gchar* _tmp17_;
				gboolean _tmp18_ = FALSE;
				const gchar* _tmp19_;
#line 131 "../lib/DBusManager.vala"
				_tmp15_ = item;
#line 131 "../lib/DBusManager.vala"
				_tmp16_ = plank_dock_item_get_Launcher (_tmp15_);
#line 131 "../lib/DBusManager.vala"
				_tmp17_ = _tmp16_;
#line 131 "../lib/DBusManager.vala"
				launcher = _tmp17_;
#line 132 "../lib/DBusManager.vala"
				_tmp19_ = launcher;
#line 132 "../lib/DBusManager.vala"
				if (_tmp19_ != NULL) {
#line 1003 "DBusManager.c"
					const gchar* _tmp20_;
#line 132 "../lib/DBusManager.vala"
					_tmp20_ = launcher;
#line 132 "../lib/DBusManager.vala"
					_tmp18_ = g_strcmp0 (_tmp20_, "") != 0;
#line 1009 "DBusManager.c"
				} else {
#line 132 "../lib/DBusManager.vala"
					_tmp18_ = FALSE;
#line 1013 "DBusManager.c"
				}
#line 132 "../lib/DBusManager.vala"
				if (_tmp18_) {
#line 1017 "DBusManager.c"
					const gchar* _tmp21_;
					gchar* _tmp22_;
#line 133 "../lib/DBusManager.vala"
					_tmp21_ = launcher;
#line 133 "../lib/DBusManager.vala"
					_tmp22_ = g_strdup (_tmp21_);
#line 133 "../lib/DBusManager.vala"
					_vala_array_add2 (&_result_, &_result__length1, &__result__size_, _tmp22_);
#line 1026 "DBusManager.c"
				}
			}
		}
#line 129 "../lib/DBusManager.vala"
		_g_object_unref0 (_item_list);
#line 1032 "DBusManager.c"
	}
#line 137 "../lib/DBusManager.vala"
	_tmp23_ = _result_;
#line 137 "../lib/DBusManager.vala"
	_tmp23__length1 = _result__length1;
#line 137 "../lib/DBusManager.vala"
	if (result_length1) {
#line 137 "../lib/DBusManager.vala"
		*result_length1 = _tmp23__length1;
#line 1042 "DBusManager.c"
	}
#line 137 "../lib/DBusManager.vala"
	result = _tmp23_;
#line 137 "../lib/DBusManager.vala"
	_g_object_unref0 (items);
#line 137 "../lib/DBusManager.vala"
	return result;
#line 1050 "DBusManager.c"
}

static gboolean
plank_dbus_items_real_get_hover_position (PlankDBusItemsIface* base,
                                          const gchar* uri,
                                          gint* x,
                                          gint* y,
                                          GtkPositionType* dock_position,
                                          GError** error)
{
	PlankDBusItems * self;
	gint _vala_x = 0;
	gint _vala_y = 0;
	GtkPositionType _vala_dock_position = 0;
	GeeArrayList* items = NULL;
	PlankDockController* _tmp0_;
	GeeArrayList* _tmp1_;
	GeeArrayList* _tmp2_;
	GeeArrayList* _tmp3_;
	PlankDockItem* found = NULL;
	PlankDockItem* _tmp17_;
	PlankPositionManager* position_manager = NULL;
	PlankDockController* _tmp18_;
	PlankPositionManager* _tmp19_;
	PlankPositionManager* _tmp20_;
	PlankPositionManager* _tmp21_;
	PlankDockItem* _tmp22_;
	gint _tmp23_ = 0;
	gint _tmp24_ = 0;
	PlankPositionManager* _tmp25_;
	GtkPositionType _tmp26_;
	GtkPositionType _tmp27_;
	gboolean result = FALSE;
#line 140 "../lib/DBusManager.vala"
	self = (PlankDBusItems*) base;
#line 140 "../lib/DBusManager.vala"
	g_return_val_if_fail (uri != NULL, FALSE);
#line 142 "../lib/DBusManager.vala"
	_tmp0_ = self->priv->controller;
#line 142 "../lib/DBusManager.vala"
	_tmp1_ = plank_dock_controller_get_Items (_tmp0_);
#line 142 "../lib/DBusManager.vala"
	_tmp2_ = _tmp1_;
#line 142 "../lib/DBusManager.vala"
	_tmp3_ = _g_object_ref0 (_tmp2_);
#line 142 "../lib/DBusManager.vala"
	items = _tmp3_;
#line 144 "../lib/DBusManager.vala"
	found = NULL;
#line 1100 "DBusManager.c"
	{
		GeeArrayList* _item_list = NULL;
		GeeArrayList* _tmp4_;
		GeeArrayList* _tmp5_;
		gint _item_size = 0;
		GeeArrayList* _tmp6_;
		gint _tmp7_;
		gint _tmp8_;
		gint _item_index = 0;
#line 145 "../lib/DBusManager.vala"
		_tmp4_ = items;
#line 145 "../lib/DBusManager.vala"
		_tmp5_ = _g_object_ref0 (_tmp4_);
#line 145 "../lib/DBusManager.vala"
		_item_list = _tmp5_;
#line 145 "../lib/DBusManager.vala"
		_tmp6_ = _item_list;
#line 145 "../lib/DBusManager.vala"
		_tmp7_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp6_);
#line 145 "../lib/DBusManager.vala"
		_tmp8_ = _tmp7_;
#line 145 "../lib/DBusManager.vala"
		_item_size = _tmp8_;
#line 145 "../lib/DBusManager.vala"
		_item_index = -1;
#line 145 "../lib/DBusManager.vala"
		while (TRUE) {
#line 1128 "DBusManager.c"
			gint _tmp9_;
			gint _tmp10_;
			PlankDockItem* item = NULL;
			GeeArrayList* _tmp11_;
			gpointer _tmp12_;
			PlankDockItem* _tmp13_;
			const gchar* _tmp14_;
			const gchar* _tmp15_;
#line 145 "../lib/DBusManager.vala"
			_item_index = _item_index + 1;
#line 145 "../lib/DBusManager.vala"
			_tmp9_ = _item_index;
#line 145 "../lib/DBusManager.vala"
			_tmp10_ = _item_size;
#line 145 "../lib/DBusManager.vala"
			if (!(_tmp9_ < _tmp10_)) {
#line 145 "../lib/DBusManager.vala"
				break;
#line 1147 "DBusManager.c"
			}
#line 145 "../lib/DBusManager.vala"
			_tmp11_ = _item_list;
#line 145 "../lib/DBusManager.vala"
			_tmp12_ = gee_abstract_list_get ((GeeAbstractList*) _tmp11_, _item_index);
#line 145 "../lib/DBusManager.vala"
			item = (PlankDockItem*) _tmp12_;
#line 146 "../lib/DBusManager.vala"
			_tmp13_ = item;
#line 146 "../lib/DBusManager.vala"
			_tmp14_ = plank_dock_item_get_Launcher (_tmp13_);
#line 146 "../lib/DBusManager.vala"
			_tmp15_ = _tmp14_;
#line 146 "../lib/DBusManager.vala"
			if (g_strcmp0 (uri, _tmp15_) == 0) {
#line 1163 "DBusManager.c"
				PlankDockItem* _tmp16_;
#line 147 "../lib/DBusManager.vala"
				_tmp16_ = item;
#line 147 "../lib/DBusManager.vala"
				found = _tmp16_;
#line 148 "../lib/DBusManager.vala"
				break;
#line 1171 "DBusManager.c"
			}
		}
#line 145 "../lib/DBusManager.vala"
		_g_object_unref0 (_item_list);
#line 1176 "DBusManager.c"
	}
#line 152 "../lib/DBusManager.vala"
	_tmp17_ = found;
#line 152 "../lib/DBusManager.vala"
	if (_tmp17_ == NULL) {
#line 153 "../lib/DBusManager.vala"
		_vala_y = -1;
#line 153 "../lib/DBusManager.vala"
		_vala_x = _vala_y;
#line 154 "../lib/DBusManager.vala"
		_vala_dock_position = 0;
#line 155 "../lib/DBusManager.vala"
		result = FALSE;
#line 155 "../lib/DBusManager.vala"
		_g_object_unref0 (items);
#line 155 "../lib/DBusManager.vala"
		if (x) {
#line 155 "../lib/DBusManager.vala"
			*x = _vala_x;
#line 1196 "DBusManager.c"
		}
#line 155 "../lib/DBusManager.vala"
		if (y) {
#line 155 "../lib/DBusManager.vala"
			*y = _vala_y;
#line 1202 "DBusManager.c"
		}
#line 155 "../lib/DBusManager.vala"
		if (dock_position) {
#line 155 "../lib/DBusManager.vala"
			*dock_position = _vala_dock_position;
#line 1208 "DBusManager.c"
		}
#line 155 "../lib/DBusManager.vala"
		return result;
#line 1212 "DBusManager.c"
	}
#line 158 "../lib/DBusManager.vala"
	_tmp18_ = self->priv->controller;
#line 158 "../lib/DBusManager.vala"
	_tmp19_ = plank_dock_controller_get_position_manager (_tmp18_);
#line 158 "../lib/DBusManager.vala"
	_tmp20_ = _tmp19_;
#line 158 "../lib/DBusManager.vala"
	position_manager = _tmp20_;
#line 159 "../lib/DBusManager.vala"
	_tmp21_ = position_manager;
#line 159 "../lib/DBusManager.vala"
	_tmp22_ = found;
#line 159 "../lib/DBusManager.vala"
	plank_position_manager_get_hover_position (_tmp21_, _tmp22_, &_tmp23_, &_tmp24_);
#line 159 "../lib/DBusManager.vala"
	_vala_x = _tmp23_;
#line 159 "../lib/DBusManager.vala"
	_vala_y = _tmp24_;
#line 160 "../lib/DBusManager.vala"
	_tmp25_ = position_manager;
#line 160 "../lib/DBusManager.vala"
	_tmp26_ = plank_position_manager_get_Position (_tmp25_);
#line 160 "../lib/DBusManager.vala"
	_tmp27_ = _tmp26_;
#line 160 "../lib/DBusManager.vala"
	_vala_dock_position = _tmp27_;
#line 161 "../lib/DBusManager.vala"
	result = TRUE;
#line 161 "../lib/DBusManager.vala"
	_g_object_unref0 (items);
#line 161 "../lib/DBusManager.vala"
	if (x) {
#line 161 "../lib/DBusManager.vala"
		*x = _vala_x;
#line 1248 "DBusManager.c"
	}
#line 161 "../lib/DBusManager.vala"
	if (y) {
#line 161 "../lib/DBusManager.vala"
		*y = _vala_y;
#line 1254 "DBusManager.c"
	}
#line 161 "../lib/DBusManager.vala"
	if (dock_position) {
#line 161 "../lib/DBusManager.vala"
		*dock_position = _vala_dock_position;
#line 1260 "DBusManager.c"
	}
#line 161 "../lib/DBusManager.vala"
	return result;
#line 1264 "DBusManager.c"
}

static void
plank_dbus_items_class_init (PlankDBusItemsClass * klass,
                             gpointer klass_data)
{
#line 25 "../lib/DBusManager.vala"
	plank_dbus_items_parent_class = g_type_class_peek_parent (klass);
#line 25 "../lib/DBusManager.vala"
	g_type_class_adjust_private_offset (klass, &PlankDBusItems_private_offset);
#line 25 "../lib/DBusManager.vala"
	G_OBJECT_CLASS (klass)->finalize = plank_dbus_items_finalize;
#line 1277 "DBusManager.c"
}

static void
plank_dbus_items_plank_dbus_items_iface_interface_init (PlankDBusItemsIfaceIface * iface,
                                                        gpointer iface_data)
{
#line 25 "../lib/DBusManager.vala"
	plank_dbus_items_plank_dbus_items_iface_parent_iface = g_type_interface_peek_parent (iface);
#line 25 "../lib/DBusManager.vala"
	iface->add = (gboolean (*) (PlankDBusItemsIface*, const gchar*, GError**)) plank_dbus_items_real_add;
#line 25 "../lib/DBusManager.vala"
	iface->remove = (gboolean (*) (PlankDBusItemsIface*, const gchar*, GError**)) plank_dbus_items_real_remove;
#line 25 "../lib/DBusManager.vala"
	iface->get_count = (gint (*) (PlankDBusItemsIface*, GError**)) plank_dbus_items_real_get_count;
#line 25 "../lib/DBusManager.vala"
	iface->get_persistent_applications = (gchar** (*) (PlankDBusItemsIface*, gint*, GError**)) plank_dbus_items_real_get_persistent_applications;
#line 25 "../lib/DBusManager.vala"
	iface->get_transient_applications = (gchar** (*) (PlankDBusItemsIface*, gint*, GError**)) plank_dbus_items_real_get_transient_applications;
#line 25 "../lib/DBusManager.vala"
	iface->get_hover_position = (gboolean (*) (PlankDBusItemsIface*, const gchar*, gint*, gint*, GtkPositionType*, GError**)) plank_dbus_items_real_get_hover_position;
#line 1298 "DBusManager.c"
}

static void
plank_dbus_items_instance_init (PlankDBusItems * self,
                                gpointer klass)
{
#line 25 "../lib/DBusManager.vala"
	self->priv = plank_dbus_items_get_instance_private (self);
#line 28 "../lib/DBusManager.vala"
	self->priv->changed_timer_id = 0U;
#line 1309 "DBusManager.c"
}

static void
plank_dbus_items_finalize (GObject * obj)
{
	PlankDBusItems * self;
	PlankDockController* _tmp0_;
	guint _tmp1_;
#line 25 "../lib/DBusManager.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_DBUS_ITEMS, PlankDBusItems);
#line 38 "../lib/DBusManager.vala"
	_tmp0_ = self->priv->controller;
#line 38 "../lib/DBusManager.vala"
	g_signal_parse_name ("elements-changed", PLANK_TYPE_DOCK_CONTAINER, &_tmp1_, NULL, FALSE);
#line 38 "../lib/DBusManager.vala"
	g_signal_handlers_disconnect_matched ((PlankDockContainer*) _tmp0_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp1_, 0, NULL, (GCallback) _plank_dbus_items_handle_elements_changed_plank_dock_container_elements_changed, self);
#line 40 "../lib/DBusManager.vala"
	if (self->priv->changed_timer_id > 0U) {
#line 41 "../lib/DBusManager.vala"
		g_source_remove (self->priv->changed_timer_id);
#line 42 "../lib/DBusManager.vala"
		self->priv->changed_timer_id = 0U;
#line 1332 "DBusManager.c"
	}
#line 27 "../lib/DBusManager.vala"
	_g_object_unref0 (self->priv->controller);
#line 25 "../lib/DBusManager.vala"
	G_OBJECT_CLASS (plank_dbus_items_parent_class)->finalize (obj);
#line 1338 "DBusManager.c"
}

/**
 * Provide an interface to manage items of the dock
 */
static GType
plank_dbus_items_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankDBusItemsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_dbus_items_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankDBusItems), 0, (GInstanceInitFunc) plank_dbus_items_instance_init, NULL };
	static const GInterfaceInfo plank_dbus_items_iface_info = { (GInterfaceInitFunc) plank_dbus_items_plank_dbus_items_iface_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType plank_dbus_items_type_id;
	plank_dbus_items_type_id = g_type_register_static (G_TYPE_OBJECT, "PlankDBusItems", &g_define_type_info, 0);
	g_type_add_interface_static (plank_dbus_items_type_id, PLANK_TYPE_DBUS_ITEMS_IFACE, &plank_dbus_items_iface_info);
	PlankDBusItems_private_offset = g_type_add_instance_private (plank_dbus_items_type_id, sizeof (PlankDBusItemsPrivate));
	return plank_dbus_items_type_id;
}

G_GNUC_INTERNAL GType
plank_dbus_items_get_type (void)
{
	static volatile gsize plank_dbus_items_type_id__volatile = 0;
	if (g_once_init_enter (&plank_dbus_items_type_id__volatile)) {
		GType plank_dbus_items_type_id;
		plank_dbus_items_type_id = plank_dbus_items_get_type_once ();
		g_once_init_leave (&plank_dbus_items_type_id__volatile, plank_dbus_items_type_id);
	}
	return plank_dbus_items_type_id__volatile;
}

static inline gpointer
plank_dbus_manager_get_instance_private (PlankDBusManager* self)
{
	return G_STRUCT_MEMBER_P (self, PlankDBusManager_private_offset);
}

PlankDBusManager*
plank_dbus_manager_construct (GType object_type,
                              PlankDockController* controller)
{
	PlankDBusManager * self = NULL;
#line 178 "../lib/DBusManager.vala"
	g_return_val_if_fail (controller != NULL, NULL);
#line 180 "../lib/DBusManager.vala"
	self = (PlankDBusManager*) g_object_new (object_type, "controller", controller, NULL);
#line 178 "../lib/DBusManager.vala"
	return self;
#line 1385 "DBusManager.c"
}

PlankDBusManager*
plank_dbus_manager_new (PlankDockController* controller)
{
#line 178 "../lib/DBusManager.vala"
	return plank_dbus_manager_construct (PLANK_TYPE_DBUS_MANAGER, controller);
#line 1393 "DBusManager.c"
}

static void
plank_dbus_manager_handle_client_ping (GDBusConnection* connection,
                                       const gchar* sender_name,
                                       const gchar* object_path,
                                       const gchar* interface_name,
                                       const gchar* signal_name,
                                       GVariant* parameters,
                                       PlankDBusManager* self)
{
	GError* _inner_error0_ = NULL;
#line 235 "../lib/DBusManager.vala"
	g_return_if_fail (self != NULL);
#line 235 "../lib/DBusManager.vala"
	g_return_if_fail (connection != NULL);
#line 235 "../lib/DBusManager.vala"
	g_return_if_fail (sender_name != NULL);
#line 235 "../lib/DBusManager.vala"
	g_return_if_fail (object_path != NULL);
#line 235 "../lib/DBusManager.vala"
	g_return_if_fail (interface_name != NULL);
#line 235 "../lib/DBusManager.vala"
	g_return_if_fail (signal_name != NULL);
#line 235 "../lib/DBusManager.vala"
	g_return_if_fail (parameters != NULL);
#line 1420 "DBusManager.c"
	{
		const gchar* _tmp0_;
#line 240 "../lib/DBusManager.vala"
		_tmp0_ = self->priv->dock_object_path;
#line 240 "../lib/DBusManager.vala"
		g_dbus_connection_emit_signal (connection, NULL, _tmp0_, PLANK_DBUS_DOCK_INTERFACE_NAME, PLANK_DBUS_PING_NAME, NULL, &_inner_error0_);
#line 240 "../lib/DBusManager.vala"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 1429 "DBusManager.c"
			goto __catch0_g_error;
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp1_;
		const gchar* _tmp2_;
#line 238 "../lib/DBusManager.vala"
		e = _inner_error0_;
#line 238 "../lib/DBusManager.vala"
		_inner_error0_ = NULL;
#line 242 "../lib/DBusManager.vala"
		_tmp1_ = e;
#line 242 "../lib/DBusManager.vala"
		_tmp2_ = _tmp1_->message;
#line 242 "../lib/DBusManager.vala"
		g_warning ("DBusManager.vala:242: Could not ping running clients (%s)", _tmp2_);
#line 238 "../lib/DBusManager.vala"
		_g_error_free0 (e);
#line 1451 "DBusManager.c"
	}
	__finally0:
#line 238 "../lib/DBusManager.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 238 "../lib/DBusManager.vala"
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 238 "../lib/DBusManager.vala"
		g_clear_error (&_inner_error0_);
#line 238 "../lib/DBusManager.vala"
		return;
#line 1462 "DBusManager.c"
	}
}

static PlankDockController*
plank_dbus_manager_get_controller (PlankDBusManager* self)
{
	PlankDockController* result;
	PlankDockController* _tmp0_;
#line 170 "../lib/DBusManager.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 170 "../lib/DBusManager.vala"
	_tmp0_ = self->priv->_controller;
#line 170 "../lib/DBusManager.vala"
	result = _tmp0_;
#line 170 "../lib/DBusManager.vala"
	return result;
#line 1479 "DBusManager.c"
}

static void
plank_dbus_manager_set_controller (PlankDBusManager* self,
                                   PlankDockController* value)
{
	PlankDockController* old_value;
#line 170 "../lib/DBusManager.vala"
	g_return_if_fail (self != NULL);
#line 170 "../lib/DBusManager.vala"
	old_value = plank_dbus_manager_get_controller (self);
#line 170 "../lib/DBusManager.vala"
	if (old_value != value) {
#line 1493 "DBusManager.c"
		PlankDockController* _tmp0_;
#line 170 "../lib/DBusManager.vala"
		_tmp0_ = _g_object_ref0 (value);
#line 170 "../lib/DBusManager.vala"
		_g_object_unref0 (self->priv->_controller);
#line 170 "../lib/DBusManager.vala"
		self->priv->_controller = _tmp0_;
#line 170 "../lib/DBusManager.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_dbus_manager_properties[PLANK_DBUS_MANAGER_CONTROLLER_PROPERTY]);
#line 1503 "DBusManager.c"
	}
}

static GObject *
plank_dbus_manager_constructor (GType type,
                                guint n_construct_properties,
                                GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	PlankDBusManager * self;
	GApplication* application = NULL;
	GApplication* _tmp0_;
	gchar* object_path = NULL;
	GApplication* _tmp1_;
	GDBusConnection* _tmp2_;
	GDBusConnection* _tmp3_;
	GApplication* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gboolean _tmp7_ = FALSE;
	GDBusConnection* _tmp8_;
	const gchar* _tmp10_;
	PlankDockController* _tmp11_;
	const gchar* _tmp12_;
	const gchar* _tmp13_;
	gchar* _tmp31_;
	GError* _inner_error0_ = NULL;
#line 183 "../lib/DBusManager.vala"
	parent_class = G_OBJECT_CLASS (plank_dbus_manager_parent_class);
#line 183 "../lib/DBusManager.vala"
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
#line 183 "../lib/DBusManager.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_DBUS_MANAGER, PlankDBusManager);
#line 185 "../lib/DBusManager.vala"
	_tmp0_ = g_application_get_default ();
#line 185 "../lib/DBusManager.vala"
	application = _tmp0_;
#line 188 "../lib/DBusManager.vala"
	_tmp1_ = application;
#line 188 "../lib/DBusManager.vala"
	_tmp2_ = g_application_get_dbus_connection (_tmp1_);
#line 188 "../lib/DBusManager.vala"
	_tmp3_ = _g_object_ref0 (_tmp2_);
#line 188 "../lib/DBusManager.vala"
	_g_object_unref0 (self->priv->connection);
#line 188 "../lib/DBusManager.vala"
	self->priv->connection = _tmp3_;
#line 189 "../lib/DBusManager.vala"
	_tmp4_ = application;
#line 189 "../lib/DBusManager.vala"
	_tmp5_ = g_application_get_dbus_object_path (_tmp4_);
#line 189 "../lib/DBusManager.vala"
	_tmp6_ = g_strdup (_tmp5_);
#line 189 "../lib/DBusManager.vala"
	_g_free0 (object_path);
#line 189 "../lib/DBusManager.vala"
	object_path = _tmp6_;
#line 191 "../lib/DBusManager.vala"
	_tmp8_ = self->priv->connection;
#line 191 "../lib/DBusManager.vala"
	if (_tmp8_ == NULL) {
#line 191 "../lib/DBusManager.vala"
		_tmp7_ = TRUE;
#line 1568 "DBusManager.c"
	} else {
		const gchar* _tmp9_;
#line 191 "../lib/DBusManager.vala"
		_tmp9_ = object_path;
#line 191 "../lib/DBusManager.vala"
		_tmp7_ = _tmp9_ == NULL;
#line 1575 "DBusManager.c"
	}
#line 191 "../lib/DBusManager.vala"
	if (_tmp7_) {
#line 192 "../lib/DBusManager.vala"
		g_critical ("DBusManager.vala:192: Not able to register our interfaces");
#line 193 "../lib/DBusManager.vala"
		_g_free0 (object_path);
#line 193 "../lib/DBusManager.vala"
		return obj;
#line 1585 "DBusManager.c"
	}
#line 196 "../lib/DBusManager.vala"
	_tmp10_ = object_path;
#line 196 "../lib/DBusManager.vala"
	_tmp11_ = self->priv->_controller;
#line 196 "../lib/DBusManager.vala"
	_tmp12_ = plank_dock_controller_get_name (_tmp11_);
#line 196 "../lib/DBusManager.vala"
	_tmp13_ = _tmp12_;
#line 196 "../lib/DBusManager.vala"
	if (!g_str_has_suffix (_tmp10_, _tmp13_)) {
#line 1597 "DBusManager.c"
		const gchar* _tmp14_;
		PlankDockController* _tmp15_;
		const gchar* _tmp16_;
		const gchar* _tmp17_;
		gchar* _tmp18_;
#line 197 "../lib/DBusManager.vala"
		_tmp14_ = object_path;
#line 197 "../lib/DBusManager.vala"
		_tmp15_ = self->priv->_controller;
#line 197 "../lib/DBusManager.vala"
		_tmp16_ = plank_dock_controller_get_name (_tmp15_);
#line 197 "../lib/DBusManager.vala"
		_tmp17_ = _tmp16_;
#line 197 "../lib/DBusManager.vala"
		_tmp18_ = g_strdup_printf ("%s/%s", _tmp14_, _tmp17_);
#line 197 "../lib/DBusManager.vala"
		_g_free0 (object_path);
#line 197 "../lib/DBusManager.vala"
		object_path = _tmp18_;
#line 1617 "DBusManager.c"
	}
	{
		GDBusConnection* _tmp19_;
#line 201 "../lib/DBusManager.vala"
		_tmp19_ = self->priv->connection;
#line 201 "../lib/DBusManager.vala"
		self->priv->dbus_client_ping_signal_id = g_dbus_connection_signal_subscribe (_tmp19_, NULL, PLANK_DBUS_CLIENT_INTERFACE_NAME, PLANK_DBUS_PING_NAME, NULL, NULL, G_DBUS_SIGNAL_FLAGS_NONE, (GDBusSignalCallback) plank_dbus_manager_handle_client_ping, g_object_ref (self), g_object_unref);
#line 1625 "DBusManager.c"
	}
	goto __finally0;
	__catch0_g_io_error:
	{
		GError* e = NULL;
		GError* _tmp20_;
		const gchar* _tmp21_;
#line 200 "../lib/DBusManager.vala"
		e = _inner_error0_;
#line 200 "../lib/DBusManager.vala"
		_inner_error0_ = NULL;
#line 204 "../lib/DBusManager.vala"
		_tmp20_ = e;
#line 204 "../lib/DBusManager.vala"
		_tmp21_ = _tmp20_->message;
#line 204 "../lib/DBusManager.vala"
		g_warning ("DBusManager.vala:204: Could not subscribe for client signal (%s)", _tmp21_);
#line 200 "../lib/DBusManager.vala"
		_g_error_free0 (e);
#line 1645 "DBusManager.c"
	}
	__finally0:
#line 200 "../lib/DBusManager.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 200 "../lib/DBusManager.vala"
		_g_free0 (object_path);
#line 200 "../lib/DBusManager.vala"
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 200 "../lib/DBusManager.vala"
		g_clear_error (&_inner_error0_);
#line 1656 "DBusManager.c"
	}
	{
		PlankDBusItems* dbus_items = NULL;
		PlankDockController* _tmp22_;
		PlankDBusItems* _tmp23_;
		guint _tmp24_ = 0U;
		GDBusConnection* _tmp25_;
		const gchar* _tmp26_;
		PlankDBusItems* _tmp27_;
		guint _tmp28_;
#line 208 "../lib/DBusManager.vala"
		_tmp22_ = self->priv->_controller;
#line 208 "../lib/DBusManager.vala"
		_tmp23_ = plank_dbus_items_new (_tmp22_);
#line 208 "../lib/DBusManager.vala"
		dbus_items = _tmp23_;
#line 209 "../lib/DBusManager.vala"
		_tmp25_ = self->priv->connection;
#line 209 "../lib/DBusManager.vala"
		_tmp26_ = object_path;
#line 209 "../lib/DBusManager.vala"
		_tmp27_ = dbus_items;
#line 209 "../lib/DBusManager.vala"
		_tmp28_ = plank_dbus_items_iface_register_object ((PlankDBusItemsIface*) _tmp27_, _tmp25_, _tmp26_, &_inner_error0_);
#line 209 "../lib/DBusManager.vala"
		_tmp24_ = _tmp28_;
#line 209 "../lib/DBusManager.vala"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 209 "../lib/DBusManager.vala"
			_g_object_unref0 (dbus_items);
#line 209 "../lib/DBusManager.vala"
			if (_inner_error0_->domain == G_IO_ERROR) {
#line 1689 "DBusManager.c"
				goto __catch1_g_io_error;
			}
#line 209 "../lib/DBusManager.vala"
			_g_free0 (object_path);
#line 209 "../lib/DBusManager.vala"
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 209 "../lib/DBusManager.vala"
			g_clear_error (&_inner_error0_);
#line 1698 "DBusManager.c"
		}
#line 209 "../lib/DBusManager.vala"
		self->priv->dbus_items_signal_id = _tmp24_;
#line 207 "../lib/DBusManager.vala"
		_g_object_unref0 (dbus_items);
#line 1704 "DBusManager.c"
	}
	goto __finally1;
	__catch1_g_io_error:
	{
		GError* e = NULL;
		GError* _tmp29_;
		const gchar* _tmp30_;
#line 207 "../lib/DBusManager.vala"
		e = _inner_error0_;
#line 207 "../lib/DBusManager.vala"
		_inner_error0_ = NULL;
#line 211 "../lib/DBusManager.vala"
		_tmp29_ = e;
#line 211 "../lib/DBusManager.vala"
		_tmp30_ = _tmp29_->message;
#line 211 "../lib/DBusManager.vala"
		g_warning ("DBusManager.vala:211: Could not register service (%s)", _tmp30_);
#line 207 "../lib/DBusManager.vala"
		_g_error_free0 (e);
#line 1724 "DBusManager.c"
	}
	__finally1:
#line 207 "../lib/DBusManager.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 207 "../lib/DBusManager.vala"
		_g_free0 (object_path);
#line 207 "../lib/DBusManager.vala"
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 207 "../lib/DBusManager.vala"
		g_clear_error (&_inner_error0_);
#line 1735 "DBusManager.c"
	}
#line 214 "../lib/DBusManager.vala"
	_tmp31_ = object_path;
#line 214 "../lib/DBusManager.vala"
	object_path = NULL;
#line 214 "../lib/DBusManager.vala"
	_g_free0 (self->priv->dock_object_path);
#line 214 "../lib/DBusManager.vala"
	self->priv->dock_object_path = _tmp31_;
#line 1745 "DBusManager.c"
	{
		GDBusConnection* _tmp32_;
		const gchar* _tmp33_;
#line 218 "../lib/DBusManager.vala"
		_tmp32_ = self->priv->connection;
#line 218 "../lib/DBusManager.vala"
		_tmp33_ = self->priv->dock_object_path;
#line 218 "../lib/DBusManager.vala"
		g_dbus_connection_emit_signal (_tmp32_, NULL, _tmp33_, PLANK_DBUS_DOCK_INTERFACE_NAME, PLANK_DBUS_PING_NAME, NULL, &_inner_error0_);
#line 218 "../lib/DBusManager.vala"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 1757 "DBusManager.c"
			goto __catch2_g_error;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		GError* _tmp34_;
		const gchar* _tmp35_;
#line 216 "../lib/DBusManager.vala"
		e = _inner_error0_;
#line 216 "../lib/DBusManager.vala"
		_inner_error0_ = NULL;
#line 220 "../lib/DBusManager.vala"
		_tmp34_ = e;
#line 220 "../lib/DBusManager.vala"
		_tmp35_ = _tmp34_->message;
#line 220 "../lib/DBusManager.vala"
		g_warning ("DBusManager.vala:220: Could not ping running clients (%s)", _tmp35_);
#line 216 "../lib/DBusManager.vala"
		_g_error_free0 (e);
#line 1779 "DBusManager.c"
	}
	__finally2:
#line 216 "../lib/DBusManager.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 216 "../lib/DBusManager.vala"
		_g_free0 (object_path);
#line 216 "../lib/DBusManager.vala"
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 216 "../lib/DBusManager.vala"
		g_clear_error (&_inner_error0_);
#line 1790 "DBusManager.c"
	}
#line 183 "../lib/DBusManager.vala"
	_g_free0 (object_path);
#line 183 "../lib/DBusManager.vala"
	return obj;
#line 1796 "DBusManager.c"
}

static void
plank_dbus_manager_class_init (PlankDBusManagerClass * klass,
                               gpointer klass_data)
{
#line 168 "../lib/DBusManager.vala"
	plank_dbus_manager_parent_class = g_type_class_peek_parent (klass);
#line 168 "../lib/DBusManager.vala"
	g_type_class_adjust_private_offset (klass, &PlankDBusManager_private_offset);
#line 168 "../lib/DBusManager.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_plank_dbus_manager_get_property;
#line 168 "../lib/DBusManager.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_plank_dbus_manager_set_property;
#line 168 "../lib/DBusManager.vala"
	G_OBJECT_CLASS (klass)->constructor = plank_dbus_manager_constructor;
#line 168 "../lib/DBusManager.vala"
	G_OBJECT_CLASS (klass)->finalize = plank_dbus_manager_finalize;
#line 168 "../lib/DBusManager.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DBUS_MANAGER_CONTROLLER_PROPERTY, plank_dbus_manager_properties[PLANK_DBUS_MANAGER_CONTROLLER_PROPERTY] = g_param_spec_object ("controller", "controller", "controller", PLANK_TYPE_DOCK_CONTROLLER, G_PARAM_STATIC_STRINGS | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
#line 1817 "DBusManager.c"
}

static void
plank_dbus_manager_instance_init (PlankDBusManager * self,
                                  gpointer klass)
{
#line 168 "../lib/DBusManager.vala"
	self->priv = plank_dbus_manager_get_instance_private (self);
#line 172 "../lib/DBusManager.vala"
	self->priv->connection = NULL;
#line 175 "../lib/DBusManager.vala"
	self->priv->dbus_items_signal_id = 0U;
#line 176 "../lib/DBusManager.vala"
	self->priv->dbus_client_ping_signal_id = 0U;
#line 1832 "DBusManager.c"
}

static void
plank_dbus_manager_finalize (GObject * obj)
{
	PlankDBusManager * self;
	GDBusConnection* _tmp0_;
#line 168 "../lib/DBusManager.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_DBUS_MANAGER, PlankDBusManager);
#line 226 "../lib/DBusManager.vala"
	_tmp0_ = self->priv->connection;
#line 226 "../lib/DBusManager.vala"
	if (_tmp0_ != NULL) {
#line 227 "../lib/DBusManager.vala"
		if (self->priv->dbus_items_signal_id > 0U) {
#line 1848 "DBusManager.c"
			GDBusConnection* _tmp1_;
#line 228 "../lib/DBusManager.vala"
			_tmp1_ = self->priv->connection;
#line 228 "../lib/DBusManager.vala"
			g_dbus_connection_unregister_object (_tmp1_, self->priv->dbus_items_signal_id);
#line 1854 "DBusManager.c"
		}
#line 229 "../lib/DBusManager.vala"
		if (self->priv->dbus_client_ping_signal_id > 0U) {
#line 1858 "DBusManager.c"
			GDBusConnection* _tmp2_;
#line 230 "../lib/DBusManager.vala"
			_tmp2_ = self->priv->connection;
#line 230 "../lib/DBusManager.vala"
			g_dbus_connection_signal_unsubscribe (_tmp2_, self->priv->dbus_client_ping_signal_id);
#line 1864 "DBusManager.c"
		}
	}
#line 170 "../lib/DBusManager.vala"
	_g_object_unref0 (self->priv->_controller);
#line 172 "../lib/DBusManager.vala"
	_g_object_unref0 (self->priv->connection);
#line 173 "../lib/DBusManager.vala"
	_g_free0 (self->priv->dock_object_path);
#line 168 "../lib/DBusManager.vala"
	G_OBJECT_CLASS (plank_dbus_manager_parent_class)->finalize (obj);
#line 1875 "DBusManager.c"
}

/**
 * Handles all the exported DBus functions of the dock
 */
static GType
plank_dbus_manager_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankDBusManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_dbus_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankDBusManager), 0, (GInstanceInitFunc) plank_dbus_manager_instance_init, NULL };
	GType plank_dbus_manager_type_id;
	plank_dbus_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "PlankDBusManager", &g_define_type_info, 0);
	PlankDBusManager_private_offset = g_type_add_instance_private (plank_dbus_manager_type_id, sizeof (PlankDBusManagerPrivate));
	return plank_dbus_manager_type_id;
}

GType
plank_dbus_manager_get_type (void)
{
	static volatile gsize plank_dbus_manager_type_id__volatile = 0;
	if (g_once_init_enter (&plank_dbus_manager_type_id__volatile)) {
		GType plank_dbus_manager_type_id;
		plank_dbus_manager_type_id = plank_dbus_manager_get_type_once ();
		g_once_init_leave (&plank_dbus_manager_type_id__volatile, plank_dbus_manager_type_id);
	}
	return plank_dbus_manager_type_id__volatile;
}

static void
_vala_plank_dbus_manager_get_property (GObject * object,
                                       guint property_id,
                                       GValue * value,
                                       GParamSpec * pspec)
{
	PlankDBusManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_DBUS_MANAGER, PlankDBusManager);
#line 168 "../lib/DBusManager.vala"
	switch (property_id) {
#line 168 "../lib/DBusManager.vala"
		case PLANK_DBUS_MANAGER_CONTROLLER_PROPERTY:
#line 168 "../lib/DBusManager.vala"
		g_value_set_object (value, plank_dbus_manager_get_controller (self));
#line 168 "../lib/DBusManager.vala"
		break;
#line 1919 "DBusManager.c"
		default:
#line 168 "../lib/DBusManager.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 168 "../lib/DBusManager.vala"
		break;
#line 1925 "DBusManager.c"
	}
}

static void
_vala_plank_dbus_manager_set_property (GObject * object,
                                       guint property_id,
                                       const GValue * value,
                                       GParamSpec * pspec)
{
	PlankDBusManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_DBUS_MANAGER, PlankDBusManager);
#line 168 "../lib/DBusManager.vala"
	switch (property_id) {
#line 168 "../lib/DBusManager.vala"
		case PLANK_DBUS_MANAGER_CONTROLLER_PROPERTY:
#line 168 "../lib/DBusManager.vala"
		plank_dbus_manager_set_controller (self, g_value_get_object (value));
#line 168 "../lib/DBusManager.vala"
		break;
#line 1945 "DBusManager.c"
		default:
#line 168 "../lib/DBusManager.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 168 "../lib/DBusManager.vala"
		break;
#line 1951 "DBusManager.c"
	}
}

