/* DragManager.c generated by valac 0.48.17, the Vala compiler
 * generated from DragManager.vala, do not modify */

/**/
/*  Copyright (C) 2011-2012 Robert Dyer, Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <glib.h>
#include <gdk/gdk.h>
#include <gee.h>
#include <stdlib.h>
#include <string.h>
#include <gtk/gtk.h>
#include <float.h>
#include <math.h>
#include <cairo-gobject.h>
#include "plank-internal.h"
#include <gio/gio.h>
#include <glib/gi18n-lib.h>

#define PLANK_TYPE_DRAG_MANAGER (plank_drag_manager_get_type ())
#define PLANK_DRAG_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DRAG_MANAGER, PlankDragManager))
#define PLANK_DRAG_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DRAG_MANAGER, PlankDragManagerClass))
#define PLANK_IS_DRAG_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DRAG_MANAGER))
#define PLANK_IS_DRAG_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DRAG_MANAGER))
#define PLANK_DRAG_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DRAG_MANAGER, PlankDragManagerClass))

typedef struct _PlankDragManager PlankDragManager;
typedef struct _PlankDragManagerClass PlankDragManagerClass;
typedef struct _PlankDragManagerPrivate PlankDragManagerPrivate;

#define PLANK_TYPE_DOCK_ELEMENT (plank_dock_element_get_type ())
#define PLANK_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElement))
#define PLANK_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))
#define PLANK_IS_DOCK_ELEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_IS_DOCK_ELEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ELEMENT))
#define PLANK_DOCK_ELEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ELEMENT, PlankDockElementClass))

typedef struct _PlankDockElement PlankDockElement;
typedef struct _PlankDockElementClass PlankDockElementClass;

#define PLANK_TYPE_DOCK_CONTAINER (plank_dock_container_get_type ())
#define PLANK_DOCK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainer))
#define PLANK_DOCK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainerClass))
#define PLANK_IS_DOCK_CONTAINER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_CONTAINER))
#define PLANK_IS_DOCK_CONTAINER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_CONTAINER))
#define PLANK_DOCK_CONTAINER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_CONTAINER, PlankDockContainerClass))

typedef struct _PlankDockContainer PlankDockContainer;
typedef struct _PlankDockContainerClass PlankDockContainerClass;

#define PLANK_TYPE_DOCK_CONTROLLER (plank_dock_controller_get_type ())
#define PLANK_DOCK_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_CONTROLLER, PlankDockController))
#define PLANK_DOCK_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_CONTROLLER, PlankDockControllerClass))
#define PLANK_IS_DOCK_CONTROLLER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_CONTROLLER))
#define PLANK_IS_DOCK_CONTROLLER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_CONTROLLER))
#define PLANK_DOCK_CONTROLLER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_CONTROLLER, PlankDockControllerClass))

typedef struct _PlankDockController PlankDockController;
typedef struct _PlankDockControllerClass PlankDockControllerClass;

#define PLANK_TYPE_DOCK_ITEM (plank_dock_item_get_type ())
#define PLANK_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ITEM, PlankDockItem))
#define PLANK_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ITEM, PlankDockItemClass))
#define PLANK_IS_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ITEM))
#define PLANK_IS_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ITEM))
#define PLANK_DOCK_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ITEM, PlankDockItemClass))

typedef struct _PlankDockItem PlankDockItem;
typedef struct _PlankDockItemClass PlankDockItemClass;
enum  {
	PLANK_DRAG_MANAGER_0_PROPERTY,
	PLANK_DRAG_MANAGER_CONTROLLER_PROPERTY,
	PLANK_DRAG_MANAGER_INTERNAL_DRAG_ACTIVE_PROPERTY,
	PLANK_DRAG_MANAGER_DRAG_ITEM_PROPERTY,
	PLANK_DRAG_MANAGER_DRAG_NEEDS_CHECK_PROPERTY,
	PLANK_DRAG_MANAGER_EXTERNAL_DRAG_ACTIVE_PROPERTY,
	PLANK_DRAG_MANAGER_REPOSITION_MODE_PROPERTY,
	PLANK_DRAG_MANAGER_NUM_PROPERTIES
};
static GParamSpec* plank_drag_manager_properties[PLANK_DRAG_MANAGER_NUM_PROPERTIES];

#define PLANK_TYPE_COMPOSITED_WINDOW (plank_composited_window_get_type ())
#define PLANK_COMPOSITED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_COMPOSITED_WINDOW, PlankCompositedWindow))
#define PLANK_COMPOSITED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_COMPOSITED_WINDOW, PlankCompositedWindowClass))
#define PLANK_IS_COMPOSITED_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_COMPOSITED_WINDOW))
#define PLANK_IS_COMPOSITED_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_COMPOSITED_WINDOW))
#define PLANK_COMPOSITED_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_COMPOSITED_WINDOW, PlankCompositedWindowClass))

typedef struct _PlankCompositedWindow PlankCompositedWindow;
typedef struct _PlankCompositedWindowClass PlankCompositedWindowClass;

#define PLANK_TYPE_DOCK_WINDOW (plank_dock_window_get_type ())
#define PLANK_DOCK_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_WINDOW, PlankDockWindow))
#define PLANK_DOCK_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_WINDOW, PlankDockWindowClass))
#define PLANK_IS_DOCK_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_WINDOW))
#define PLANK_IS_DOCK_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_WINDOW))
#define PLANK_DOCK_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_WINDOW, PlankDockWindowClass))

typedef struct _PlankDockWindow PlankDockWindow;
typedef struct _PlankDockWindowClass PlankDockWindowClass;

#define PLANK_TYPE_SETTINGS (plank_settings_get_type ())
#define PLANK_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_SETTINGS, PlankSettings))
#define PLANK_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_SETTINGS, PlankSettingsClass))
#define PLANK_IS_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_SETTINGS))
#define PLANK_IS_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_SETTINGS))
#define PLANK_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_SETTINGS, PlankSettingsClass))

typedef struct _PlankSettings PlankSettings;
typedef struct _PlankSettingsClass PlankSettingsClass;

#define PLANK_TYPE_DOCK_PREFERENCES (plank_dock_preferences_get_type ())
#define PLANK_DOCK_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_PREFERENCES, PlankDockPreferences))
#define PLANK_DOCK_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_PREFERENCES, PlankDockPreferencesClass))
#define PLANK_IS_DOCK_PREFERENCES(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_PREFERENCES))
#define PLANK_IS_DOCK_PREFERENCES_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_PREFERENCES))
#define PLANK_DOCK_PREFERENCES_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_PREFERENCES, PlankDockPreferencesClass))

typedef struct _PlankDockPreferences PlankDockPreferences;
typedef struct _PlankDockPreferencesClass PlankDockPreferencesClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define PLANK_TYPE_POSITION_MANAGER (plank_position_manager_get_type ())
#define PLANK_POSITION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_POSITION_MANAGER, PlankPositionManager))
#define PLANK_POSITION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_POSITION_MANAGER, PlankPositionManagerClass))
#define PLANK_IS_POSITION_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_POSITION_MANAGER))
#define PLANK_IS_POSITION_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_POSITION_MANAGER))
#define PLANK_POSITION_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_POSITION_MANAGER, PlankPositionManagerClass))

typedef struct _PlankPositionManager PlankPositionManager;
typedef struct _PlankPositionManagerClass PlankPositionManagerClass;

#define PLANK_TYPE_SURFACE (plank_surface_get_type ())
#define PLANK_SURFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_SURFACE, PlankSurface))
#define PLANK_SURFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_SURFACE, PlankSurfaceClass))
#define PLANK_IS_SURFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_SURFACE))
#define PLANK_IS_SURFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_SURFACE))
#define PLANK_SURFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_SURFACE, PlankSurfaceClass))

typedef struct _PlankSurface PlankSurface;
typedef struct _PlankSurfaceClass PlankSurfaceClass;
typedef struct _Block3Data Block3Data;

#define PLANK_TYPE_RENDERER (plank_renderer_get_type ())
#define PLANK_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_RENDERER, PlankRenderer))
#define PLANK_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_RENDERER, PlankRendererClass))
#define PLANK_IS_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_RENDERER))
#define PLANK_IS_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_RENDERER))
#define PLANK_RENDERER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_RENDERER, PlankRendererClass))

typedef struct _PlankRenderer PlankRenderer;
typedef struct _PlankRendererClass PlankRendererClass;

#define PLANK_TYPE_DOCK_RENDERER (plank_dock_renderer_get_type ())
#define PLANK_DOCK_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_RENDERER, PlankDockRenderer))
#define PLANK_DOCK_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_RENDERER, PlankDockRendererClass))
#define PLANK_IS_DOCK_RENDERER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_RENDERER))
#define PLANK_IS_DOCK_RENDERER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_RENDERER))
#define PLANK_DOCK_RENDERER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_RENDERER, PlankDockRendererClass))

typedef struct _PlankDockRenderer PlankDockRenderer;
typedef struct _PlankDockRendererClass PlankDockRendererClass;

#define PLANK_TYPE_DOCK_ITEM_PROVIDER (plank_dock_item_provider_get_type ())
#define PLANK_DOCK_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DOCK_ITEM_PROVIDER, PlankDockItemProvider))
#define PLANK_DOCK_ITEM_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DOCK_ITEM_PROVIDER, PlankDockItemProviderClass))
#define PLANK_IS_DOCK_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DOCK_ITEM_PROVIDER))
#define PLANK_IS_DOCK_ITEM_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DOCK_ITEM_PROVIDER))
#define PLANK_DOCK_ITEM_PROVIDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DOCK_ITEM_PROVIDER, PlankDockItemProviderClass))

typedef struct _PlankDockItemProvider PlankDockItemProvider;
typedef struct _PlankDockItemProviderClass PlankDockItemProviderClass;

#define PLANK_TYPE_HIDE_MANAGER (plank_hide_manager_get_type ())
#define PLANK_HIDE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_HIDE_MANAGER, PlankHideManager))
#define PLANK_HIDE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_HIDE_MANAGER, PlankHideManagerClass))
#define PLANK_IS_HIDE_MANAGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_HIDE_MANAGER))
#define PLANK_IS_HIDE_MANAGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_HIDE_MANAGER))
#define PLANK_HIDE_MANAGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_HIDE_MANAGER, PlankHideManagerClass))

typedef struct _PlankHideManager PlankHideManager;
typedef struct _PlankHideManagerClass PlankHideManagerClass;

#define PLANK_TYPE_APPLICATION_DOCK_ITEM (plank_application_dock_item_get_type ())
#define PLANK_APPLICATION_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_APPLICATION_DOCK_ITEM, PlankApplicationDockItem))
#define PLANK_APPLICATION_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_APPLICATION_DOCK_ITEM, PlankApplicationDockItemClass))
#define PLANK_IS_APPLICATION_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_APPLICATION_DOCK_ITEM))
#define PLANK_IS_APPLICATION_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_APPLICATION_DOCK_ITEM))
#define PLANK_APPLICATION_DOCK_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_APPLICATION_DOCK_ITEM, PlankApplicationDockItemClass))

typedef struct _PlankApplicationDockItem PlankApplicationDockItem;
typedef struct _PlankApplicationDockItemClass PlankApplicationDockItemClass;

#define PLANK_TYPE_POOF_WINDOW (plank_poof_window_get_type ())
#define PLANK_POOF_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_POOF_WINDOW, PlankPoofWindow))
#define PLANK_POOF_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_POOF_WINDOW, PlankPoofWindowClass))
#define PLANK_IS_POOF_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_POOF_WINDOW))
#define PLANK_IS_POOF_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_POOF_WINDOW))
#define PLANK_POOF_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_POOF_WINDOW, PlankPoofWindowClass))

typedef struct _PlankPoofWindow PlankPoofWindow;
typedef struct _PlankPoofWindowClass PlankPoofWindowClass;

#define PLANK_TYPE_TRANSIENT_DOCK_ITEM (plank_transient_dock_item_get_type ())
#define PLANK_TRANSIENT_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_TRANSIENT_DOCK_ITEM, PlankTransientDockItem))
#define PLANK_TRANSIENT_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_TRANSIENT_DOCK_ITEM, PlankTransientDockItemClass))
#define PLANK_IS_TRANSIENT_DOCK_ITEM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_TRANSIENT_DOCK_ITEM))
#define PLANK_IS_TRANSIENT_DOCK_ITEM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_TRANSIENT_DOCK_ITEM))
#define PLANK_TRANSIENT_DOCK_ITEM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_TRANSIENT_DOCK_ITEM, PlankTransientDockItemClass))

typedef struct _PlankTransientDockItem PlankTransientDockItem;
typedef struct _PlankTransientDockItemClass PlankTransientDockItemClass;

#define PLANK_TYPE_APPLICATION_DOCK_ITEM_PROVIDER (plank_application_dock_item_provider_get_type ())
#define PLANK_APPLICATION_DOCK_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_APPLICATION_DOCK_ITEM_PROVIDER, PlankApplicationDockItemProvider))
#define PLANK_APPLICATION_DOCK_ITEM_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_APPLICATION_DOCK_ITEM_PROVIDER, PlankApplicationDockItemProviderClass))
#define PLANK_IS_APPLICATION_DOCK_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_APPLICATION_DOCK_ITEM_PROVIDER))
#define PLANK_IS_APPLICATION_DOCK_ITEM_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_APPLICATION_DOCK_ITEM_PROVIDER))
#define PLANK_APPLICATION_DOCK_ITEM_PROVIDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_APPLICATION_DOCK_ITEM_PROVIDER, PlankApplicationDockItemProviderClass))

typedef struct _PlankApplicationDockItemProvider PlankApplicationDockItemProvider;
typedef struct _PlankApplicationDockItemProviderClass PlankApplicationDockItemProviderClass;

#define PLANK_TYPE_DEFAULT_APPLICATION_DOCK_ITEM_PROVIDER (plank_default_application_dock_item_provider_get_type ())
#define PLANK_DEFAULT_APPLICATION_DOCK_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_DEFAULT_APPLICATION_DOCK_ITEM_PROVIDER, PlankDefaultApplicationDockItemProvider))
#define PLANK_DEFAULT_APPLICATION_DOCK_ITEM_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_DEFAULT_APPLICATION_DOCK_ITEM_PROVIDER, PlankDefaultApplicationDockItemProviderClass))
#define PLANK_IS_DEFAULT_APPLICATION_DOCK_ITEM_PROVIDER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_DEFAULT_APPLICATION_DOCK_ITEM_PROVIDER))
#define PLANK_IS_DEFAULT_APPLICATION_DOCK_ITEM_PROVIDER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_DEFAULT_APPLICATION_DOCK_ITEM_PROVIDER))
#define PLANK_DEFAULT_APPLICATION_DOCK_ITEM_PROVIDER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_DEFAULT_APPLICATION_DOCK_ITEM_PROVIDER, PlankDefaultApplicationDockItemProviderClass))

typedef struct _PlankDefaultApplicationDockItemProvider PlankDefaultApplicationDockItemProvider;
typedef struct _PlankDefaultApplicationDockItemProviderClass PlankDefaultApplicationDockItemProviderClass;

#define PLANK_TYPE_HOVER_WINDOW (plank_hover_window_get_type ())
#define PLANK_HOVER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_HOVER_WINDOW, PlankHoverWindow))
#define PLANK_HOVER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_HOVER_WINDOW, PlankHoverWindowClass))
#define PLANK_IS_HOVER_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_HOVER_WINDOW))
#define PLANK_IS_HOVER_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_HOVER_WINDOW))
#define PLANK_HOVER_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_HOVER_WINDOW, PlankHoverWindowClass))

typedef struct _PlankHoverWindow PlankHoverWindow;
typedef struct _PlankHoverWindowClass PlankHoverWindowClass;
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

struct _PlankDragManager {
	GObject parent_instance;
	PlankDragManagerPrivate * priv;
};

struct _PlankDragManagerClass {
	GObjectClass parent_class;
};

struct _PlankDragManagerPrivate {
	PlankDockController* _controller;
	gboolean _InternalDragActive;
	PlankDockItem* _DragItem;
	gboolean _DragNeedsCheck;
	gboolean external_drag_active;
	gboolean reposition_mode;
	GdkWindow* proxy_window;
	gboolean drag_canceled;
	gboolean drag_known;
	gboolean drag_data_requested;
	guint marker;
	guint drag_hover_timer_id;
	GeeArrayList* drag_data;
	gint window_scale_factor;
	gulong drag_item_redraw_handler_id;
};

struct _Block3Data {
	int _ref_count_;
	PlankDragManager* self;
	GdkDragContext* context;
};

static gint PlankDragManager_private_offset;
static gpointer plank_drag_manager_parent_class = NULL;

GType plank_drag_manager_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDragManager, g_object_unref)
GType plank_dock_element_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockElement, g_object_unref)
GType plank_dock_container_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockContainer, g_object_unref)
GType plank_dock_controller_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockController, g_object_unref)
GType plank_dock_item_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockItem, g_object_unref)
GType plank_composited_window_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankCompositedWindow, g_object_unref)
GType plank_dock_window_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockWindow, g_object_unref)
static PlankDockController* plank_drag_manager_get_controller (PlankDragManager* self);
PlankDockWindow* plank_dock_controller_get_window (PlankDockController* self);
static gboolean plank_drag_manager_drag_motion (GtkWidget* w,
                                         GdkDragContext* context,
                                         gint x,
                                         gint y,
                                         guint time_,
                                         PlankDragManager* self);
static gboolean _plank_drag_manager_drag_motion_gtk_widget_drag_motion (GtkWidget* _sender,
                                                                 GdkDragContext* context,
                                                                 gint x,
                                                                 gint y,
                                                                 guint time_,
                                                                 gpointer self);
static void plank_drag_manager_drag_begin (GtkWidget* w,
                                    GdkDragContext* context,
                                    PlankDragManager* self);
static void _plank_drag_manager_drag_begin_gtk_widget_drag_begin (GtkWidget* _sender,
                                                           GdkDragContext* context,
                                                           gpointer self);
static void plank_drag_manager_drag_data_received (GtkWidget* w,
                                            GdkDragContext* context,
                                            gint x,
                                            gint y,
                                            GtkSelectionData* selection_data,
                                            guint info,
                                            guint time_,
                                            PlankDragManager* self);
static void _plank_drag_manager_drag_data_received_gtk_widget_drag_data_received (GtkWidget* _sender,
                                                                           GdkDragContext* context,
                                                                           gint x,
                                                                           gint y,
                                                                           GtkSelectionData* selection_data,
                                                                           guint info,
                                                                           guint time_,
                                                                           gpointer self);
static void plank_drag_manager_drag_data_get (GtkWidget* w,
                                       GdkDragContext* context,
                                       GtkSelectionData* selection_data,
                                       guint info,
                                       guint time_,
                                       PlankDragManager* self);
static void _plank_drag_manager_drag_data_get_gtk_widget_drag_data_get (GtkWidget* _sender,
                                                                 GdkDragContext* context,
                                                                 GtkSelectionData* selection_data,
                                                                 guint info,
                                                                 guint time_,
                                                                 gpointer self);
static gboolean plank_drag_manager_drag_drop (GtkWidget* w,
                                       GdkDragContext* context,
                                       gint x,
                                       gint y,
                                       guint time_,
                                       PlankDragManager* self);
static gboolean _plank_drag_manager_drag_drop_gtk_widget_drag_drop (GtkWidget* _sender,
                                                             GdkDragContext* context,
                                                             gint x,
                                                             gint y,
                                                             guint time_,
                                                             gpointer self);
static void plank_drag_manager_drag_end (GtkWidget* w,
                                  GdkDragContext* context,
                                  PlankDragManager* self);
static void _plank_drag_manager_drag_end_gtk_widget_drag_end (GtkWidget* _sender,
                                                       GdkDragContext* context,
                                                       gpointer self);
static void plank_drag_manager_drag_leave (GtkWidget* w,
                                    GdkDragContext* context,
                                    guint time_,
                                    PlankDragManager* self);
static void _plank_drag_manager_drag_leave_gtk_widget_drag_leave (GtkWidget* _sender,
                                                           GdkDragContext* context,
                                                           guint time_,
                                                           gpointer self);
static gboolean plank_drag_manager_drag_failed (GtkWidget* w,
                                         GdkDragContext* context,
                                         GtkDragResult _result_,
                                         PlankDragManager* self);
static gboolean _plank_drag_manager_drag_failed_gtk_widget_drag_failed (GtkWidget* _sender,
                                                                 GdkDragContext* context,
                                                                 GtkDragResult _result_,
                                                                 gpointer self);
GType plank_settings_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankSettings, g_object_unref)
GType plank_dock_preferences_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockPreferences, g_object_unref)
PlankDockPreferences* plank_dock_controller_get_prefs (PlankDockController* self);
static void plank_drag_manager_lock_items_changed (PlankDragManager* self);
static void _plank_drag_manager_lock_items_changed_g_object_notify (GObject* _sender,
                                                             GParamSpec* pspec,
                                                             gpointer self);
static void plank_drag_manager_disable_drag_to (PlankDragManager* self,
                                         PlankDockWindow* window);
static void plank_drag_manager_disable_drag_from (PlankDragManager* self,
                                           PlankDockWindow* window);
PlankDragManager* plank_drag_manager_new (PlankDockController* controller);
PlankDragManager* plank_drag_manager_construct (GType object_type,
                                                PlankDockController* controller);
void plank_drag_manager_initialize (PlankDragManager* self);
static void plank_drag_manager_enable_drag_to (PlankDragManager* self,
                                        PlankDockWindow* window);
gboolean plank_dock_preferences_get_LockItems (PlankDockPreferences* self);
static void plank_drag_manager_enable_drag_from (PlankDragManager* self,
                                          PlankDockWindow* window);
gboolean plank_drag_manager_get_InternalDragActive (PlankDragManager* self);
PlankDockItem* plank_drag_manager_get_DragItem (PlankDragManager* self);
gchar* plank_dock_element_as_uri (PlankDockElement* self);
gboolean plank_drag_manager_drop_is_accepted_by (PlankDragManager* self,
                                                 PlankDockItem* item);
gboolean plank_dock_element_can_accept_drop (PlankDockElement* self,
                                             GeeArrayList* uris);
static void plank_drag_manager_set_drag_icon (PlankDragManager* self,
                                       GdkDragContext* context,
                                       PlankDockItem* item,
                                       gdouble opacity);
GType plank_position_manager_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankPositionManager, g_object_unref)
PlankPositionManager* plank_dock_controller_get_position_manager (PlankDockController* self);
gint plank_position_manager_get_ZoomIconSize (PlankPositionManager* self);
GType plank_surface_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankSurface, g_object_unref)
PlankSurface* plank_surface_new (gint width,
                                 gint height);
PlankSurface* plank_surface_construct (GType object_type,
                                       gint width,
                                       gint height);
cairo_surface_t* plank_surface_get_Internal (PlankSurface* self);
PlankSurface* plank_dock_item_get_surface_copy (PlankDockItem* self,
                                                gint width,
                                                gint height,
                                                PlankSurface* model);
cairo_t* plank_surface_get_Context (PlankSurface* self);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static void plank_drag_manager_hovered_item_changed (PlankDragManager* self);
static void _plank_drag_manager_hovered_item_changed_g_object_notify (GObject* _sender,
                                                               GParamSpec* pspec,
                                                               gpointer self);
static void plank_drag_manager_set_InternalDragActive (PlankDragManager* self,
                                                gboolean value);
PlankDockItem* plank_dock_window_get_HoveredItem (PlankDockWindow* self);
static void plank_drag_manager_set_DragItem (PlankDragManager* self,
                                      PlankDockItem* value);
gboolean plank_drag_manager_get_RepositionMode (PlankDragManager* self);
static void __lambda58_ (Block3Data* _data3_);
static void ___lambda58__plank_dock_element_needs_redraw (PlankDockElement* _sender,
                                                   gpointer self);
static void plank_drag_manager_set_DragNeedsCheck (PlankDragManager* self,
                                            gboolean value);
GType plank_renderer_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankRenderer, g_object_unref)
GType plank_dock_renderer_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockRenderer, g_object_unref)
PlankDockRenderer* plank_dock_controller_get_renderer (PlankDockController* self);
void plank_renderer_animated_draw (PlankRenderer* self);
GType plank_dock_item_provider_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDockItemProvider, g_object_unref)
PlankDockItemProvider* plank_dock_window_get_HoveredItemProvider (PlankDockWindow* self);
gboolean plank_drag_manager_get_DragNeedsCheck (PlankDragManager* self);
gboolean plank_dock_element_accept_drop (PlankDockElement* self,
                                         GeeArrayList* uris);
static void plank_drag_manager_set_ExternalDragActive (PlankDragManager* self,
                                                gboolean value);
GType plank_hide_manager_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankHideManager, g_object_unref)
PlankHideManager* plank_dock_controller_get_hide_manager (PlankDockController* self);
void plank_hide_manager_update_hovered (PlankHideManager* self);
gboolean plank_hide_manager_get_Hovered (PlankHideManager* self);
gboolean plank_dock_element_can_be_removed (PlankDockElement* self);
GType plank_application_dock_item_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankApplicationDockItem, g_object_unref)
gboolean plank_application_dock_item_is_running (PlankApplicationDockItem* self);
gboolean plank_application_dock_item_has_unity_info (PlankApplicationDockItem* self);
void plank_dock_element_set_IsVisible (PlankDockElement* self,
                                       gboolean value);
PlankDockContainer* plank_dock_element_get_Container (PlankDockElement* self);
gboolean plank_dock_container_remove (PlankDockContainer* self,
                                      PlankDockElement* element);
void plank_dock_item_delete (PlankDockItem* self);
GType plank_poof_window_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankPoofWindow, g_object_unref)
PlankPoofWindow* plank_poof_window_get_default (void);
void plank_poof_window_show_at (PlankPoofWindow* self,
                                gint x,
                                gint y);
gboolean plank_dock_preferences_get_AutoPinning (PlankDockPreferences* self);
GType plank_transient_dock_item_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankTransientDockItem, g_object_unref)
GType plank_application_dock_item_provider_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankApplicationDockItemProvider, g_object_unref)
GType plank_default_application_dock_item_provider_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankDefaultApplicationDockItemProvider, g_object_unref)
void plank_default_application_dock_item_provider_pin_item (PlankDefaultApplicationDockItemProvider* self,
                                                            PlankDockItem* item);
GType plank_hover_window_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankHoverWindow, g_object_unref)
PlankHoverWindow* plank_dock_controller_get_hover (PlankDockController* self);
gboolean plank_drag_manager_get_ExternalDragActive (PlankDragManager* self);
static gboolean ___lambda60_ (PlankDragManager* self);
gboolean plank_dock_window_update_hovered (PlankDockWindow* self,
                                           gint x,
                                           gint y);
static gboolean ____lambda60__gsource_func (gpointer self);
void plank_position_manager_get_hover_position (PlankPositionManager* self,
                                                PlankDockItem* hovered,
                                                gint* x,
                                                gint* y);
void plank_hover_window_set_text (PlankHoverWindow* self,
                                  const gchar* text);
gchar* plank_dock_element_get_drop_text (PlankDockElement* self);
void plank_hover_window_show_at (PlankHoverWindow* self,
                                 gint x,
                                 gint y,
                                 GtkPositionType position);
GtkPositionType plank_position_manager_get_Position (PlankPositionManager* self);
void plank_position_manager_get_hover_position_at (PlankPositionManager* self,
                                                   gint* x,
                                                   gint* y);
void plank_dock_renderer_update_local_cursor (PlankDockRenderer* self,
                                              gint x,
                                              gint y);
void plank_hide_manager_update_hovered_with_coords (PlankHideManager* self,
                                                    gint x,
                                                    gint y);
gboolean plank_dock_container_move_to (PlankDockContainer* self,
                                       PlankDockElement* move,
                                       PlankDockElement* target);
static gboolean ___lambda57_ (PlankDragManager* self);
void plank_dock_element_scrolled (PlankDockElement* self,
                                  GdkScrollDirection direction,
                                  GdkModifierType mod,
                                  guint32 event_time);
static gboolean ____lambda57__gsource_func (gpointer self);
static GdkWindow* plank_drag_manager_best_proxy_window (PlankDragManager* self);
static void _g_object_unref0_ (gpointer var);
static inline void _g_list_free__g_object_unref0_ (GList* self);
void plank_drag_manager_ensure_proxy (PlankDragManager* self);
static void plank_drag_manager_set_controller (PlankDragManager* self,
                                        PlankDockController* value);
static void plank_drag_manager_set_RepositionMode (PlankDragManager* self,
                                            gboolean value);
static void plank_drag_manager_finalize (GObject * obj);
static GType plank_drag_manager_get_type_once (void);
static void _vala_plank_drag_manager_get_property (GObject * object,
                                            guint property_id,
                                            GValue * value,
                                            GParamSpec * pspec);
static void _vala_plank_drag_manager_set_property (GObject * object,
                                            guint property_id,
                                            const GValue * value,
                                            GParamSpec * pspec);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static inline gpointer
plank_drag_manager_get_instance_private (PlankDragManager* self)
{
	return G_STRUCT_MEMBER_P (self, PlankDragManager_private_offset);
}

static gboolean
_plank_drag_manager_drag_motion_gtk_widget_drag_motion (GtkWidget* _sender,
                                                        GdkDragContext* context,
                                                        gint x,
                                                        gint y,
                                                        guint time_,
                                                        gpointer self)
{
	gboolean result;
	result = plank_drag_manager_drag_motion (_sender, context, x, y, time_, (PlankDragManager*) self);
#line 120 "../lib/DragManager.vala"
	return result;
#line 594 "DragManager.c"
}

static void
_plank_drag_manager_drag_begin_gtk_widget_drag_begin (GtkWidget* _sender,
                                                      GdkDragContext* context,
                                                      gpointer self)
{
#line 121 "../lib/DragManager.vala"
	plank_drag_manager_drag_begin (_sender, context, (PlankDragManager*) self);
#line 604 "DragManager.c"
}

static void
_plank_drag_manager_drag_data_received_gtk_widget_drag_data_received (GtkWidget* _sender,
                                                                      GdkDragContext* context,
                                                                      gint x,
                                                                      gint y,
                                                                      GtkSelectionData* selection_data,
                                                                      guint info,
                                                                      guint time_,
                                                                      gpointer self)
{
#line 122 "../lib/DragManager.vala"
	plank_drag_manager_drag_data_received (_sender, context, x, y, selection_data, info, time_, (PlankDragManager*) self);
#line 619 "DragManager.c"
}

static void
_plank_drag_manager_drag_data_get_gtk_widget_drag_data_get (GtkWidget* _sender,
                                                            GdkDragContext* context,
                                                            GtkSelectionData* selection_data,
                                                            guint info,
                                                            guint time_,
                                                            gpointer self)
{
#line 123 "../lib/DragManager.vala"
	plank_drag_manager_drag_data_get (_sender, context, selection_data, info, time_, (PlankDragManager*) self);
#line 632 "DragManager.c"
}

static gboolean
_plank_drag_manager_drag_drop_gtk_widget_drag_drop (GtkWidget* _sender,
                                                    GdkDragContext* context,
                                                    gint x,
                                                    gint y,
                                                    guint time_,
                                                    gpointer self)
{
	gboolean result;
	result = plank_drag_manager_drag_drop (_sender, context, x, y, time_, (PlankDragManager*) self);
#line 124 "../lib/DragManager.vala"
	return result;
#line 647 "DragManager.c"
}

static void
_plank_drag_manager_drag_end_gtk_widget_drag_end (GtkWidget* _sender,
                                                  GdkDragContext* context,
                                                  gpointer self)
{
#line 125 "../lib/DragManager.vala"
	plank_drag_manager_drag_end (_sender, context, (PlankDragManager*) self);
#line 657 "DragManager.c"
}

static void
_plank_drag_manager_drag_leave_gtk_widget_drag_leave (GtkWidget* _sender,
                                                      GdkDragContext* context,
                                                      guint time_,
                                                      gpointer self)
{
#line 126 "../lib/DragManager.vala"
	plank_drag_manager_drag_leave (_sender, context, time_, (PlankDragManager*) self);
#line 668 "DragManager.c"
}

static gboolean
_plank_drag_manager_drag_failed_gtk_widget_drag_failed (GtkWidget* _sender,
                                                        GdkDragContext* context,
                                                        GtkDragResult _result_,
                                                        gpointer self)
{
	gboolean result;
	result = plank_drag_manager_drag_failed (_sender, context, _result_, (PlankDragManager*) self);
#line 127 "../lib/DragManager.vala"
	return result;
#line 681 "DragManager.c"
}

static void
_plank_drag_manager_lock_items_changed_g_object_notify (GObject* _sender,
                                                        GParamSpec* pspec,
                                                        gpointer self)
{
#line 129 "../lib/DragManager.vala"
	plank_drag_manager_lock_items_changed ((PlankDragManager*) self);
#line 691 "DragManager.c"
}

/**
 * Creates a new instance of a DragManager, which handles
 * drag'n'drop interactions of a dock.
 *
 * @param controller the {@link DockController} to manage drag'n'drop for
 */
PlankDragManager*
plank_drag_manager_construct (GType object_type,
                              PlankDockController* controller)
{
	PlankDragManager * self = NULL;
#line 86 "../lib/DragManager.vala"
	g_return_val_if_fail (controller != NULL, NULL);
#line 88 "../lib/DragManager.vala"
	self = (PlankDragManager*) g_object_new (object_type, "controller", controller, NULL);
#line 86 "../lib/DragManager.vala"
	return self;
#line 711 "DragManager.c"
}

PlankDragManager*
plank_drag_manager_new (PlankDockController* controller)
{
#line 86 "../lib/DragManager.vala"
	return plank_drag_manager_construct (PLANK_TYPE_DRAG_MANAGER, controller);
#line 719 "DragManager.c"
}

/**
 * Initializes the drag-manager.  Call after the DockWindow is constructed.
 */
void
plank_drag_manager_initialize (PlankDragManager* self)
{
	PlankDockController* _tmp0_;
	PlankDockWindow* _tmp1_;
	PlankDockWindow* _tmp2_;
	PlankDockWindow* window = NULL;
	PlankDockController* _tmp3_;
	PlankDockWindow* _tmp4_;
	PlankDockWindow* _tmp5_;
	PlankDockPreferences* prefs = NULL;
	PlankDockController* _tmp6_;
	PlankDockPreferences* _tmp7_;
	PlankDockPreferences* _tmp8_;
	PlankDockWindow* _tmp9_;
	PlankDockWindow* _tmp10_;
	PlankDockWindow* _tmp11_;
	PlankDockWindow* _tmp12_;
	PlankDockWindow* _tmp13_;
	PlankDockWindow* _tmp14_;
	PlankDockWindow* _tmp15_;
	PlankDockWindow* _tmp16_;
	PlankDockPreferences* _tmp17_;
	PlankDockWindow* _tmp18_;
	PlankDockPreferences* _tmp19_;
	gboolean _tmp20_;
	gboolean _tmp21_;
#line 94 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 94 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_controller;
#line 94 "../lib/DragManager.vala"
	_tmp1_ = plank_dock_controller_get_window (_tmp0_);
#line 94 "../lib/DragManager.vala"
	_tmp2_ = _tmp1_;
#line 94 "../lib/DragManager.vala"
	_vala_return_if_fail (_tmp2_ != NULL, "controller.window != null");
#line 97 "../lib/DragManager.vala"
	_tmp3_ = self->priv->_controller;
#line 97 "../lib/DragManager.vala"
	_tmp4_ = plank_dock_controller_get_window (_tmp3_);
#line 97 "../lib/DragManager.vala"
	_tmp5_ = _tmp4_;
#line 97 "../lib/DragManager.vala"
	window = _tmp5_;
#line 98 "../lib/DragManager.vala"
	_tmp6_ = self->priv->_controller;
#line 98 "../lib/DragManager.vala"
	_tmp7_ = plank_dock_controller_get_prefs (_tmp6_);
#line 98 "../lib/DragManager.vala"
	_tmp8_ = _tmp7_;
#line 98 "../lib/DragManager.vala"
	prefs = _tmp8_;
#line 100 "../lib/DragManager.vala"
	_tmp9_ = window;
#line 100 "../lib/DragManager.vala"
	g_signal_connect_object ((GtkWidget*) _tmp9_, "drag-motion", (GCallback) _plank_drag_manager_drag_motion_gtk_widget_drag_motion, self, 0);
#line 101 "../lib/DragManager.vala"
	_tmp10_ = window;
#line 101 "../lib/DragManager.vala"
	g_signal_connect_object ((GtkWidget*) _tmp10_, "drag-begin", (GCallback) _plank_drag_manager_drag_begin_gtk_widget_drag_begin, self, 0);
#line 102 "../lib/DragManager.vala"
	_tmp11_ = window;
#line 102 "../lib/DragManager.vala"
	g_signal_connect_object ((GtkWidget*) _tmp11_, "drag-data-received", (GCallback) _plank_drag_manager_drag_data_received_gtk_widget_drag_data_received, self, 0);
#line 103 "../lib/DragManager.vala"
	_tmp12_ = window;
#line 103 "../lib/DragManager.vala"
	g_signal_connect_object ((GtkWidget*) _tmp12_, "drag-data-get", (GCallback) _plank_drag_manager_drag_data_get_gtk_widget_drag_data_get, self, 0);
#line 104 "../lib/DragManager.vala"
	_tmp13_ = window;
#line 104 "../lib/DragManager.vala"
	g_signal_connect_object ((GtkWidget*) _tmp13_, "drag-drop", (GCallback) _plank_drag_manager_drag_drop_gtk_widget_drag_drop, self, 0);
#line 105 "../lib/DragManager.vala"
	_tmp14_ = window;
#line 105 "../lib/DragManager.vala"
	g_signal_connect_object ((GtkWidget*) _tmp14_, "drag-end", (GCallback) _plank_drag_manager_drag_end_gtk_widget_drag_end, self, 0);
#line 106 "../lib/DragManager.vala"
	_tmp15_ = window;
#line 106 "../lib/DragManager.vala"
	g_signal_connect_object ((GtkWidget*) _tmp15_, "drag-leave", (GCallback) _plank_drag_manager_drag_leave_gtk_widget_drag_leave, self, 0);
#line 107 "../lib/DragManager.vala"
	_tmp16_ = window;
#line 107 "../lib/DragManager.vala"
	g_signal_connect_object ((GtkWidget*) _tmp16_, "drag-failed", (GCallback) _plank_drag_manager_drag_failed_gtk_widget_drag_failed, self, 0);
#line 109 "../lib/DragManager.vala"
	_tmp17_ = prefs;
#line 109 "../lib/DragManager.vala"
	g_signal_connect_object ((GObject*) _tmp17_, "notify::LockItems", (GCallback) _plank_drag_manager_lock_items_changed_g_object_notify, self, 0);
#line 111 "../lib/DragManager.vala"
	_tmp18_ = window;
#line 111 "../lib/DragManager.vala"
	plank_drag_manager_enable_drag_to (self, _tmp18_);
#line 112 "../lib/DragManager.vala"
	_tmp19_ = prefs;
#line 112 "../lib/DragManager.vala"
	_tmp20_ = plank_dock_preferences_get_LockItems (_tmp19_);
#line 112 "../lib/DragManager.vala"
	_tmp21_ = _tmp20_;
#line 112 "../lib/DragManager.vala"
	if (!_tmp21_) {
#line 826 "DragManager.c"
		PlankDockWindow* _tmp22_;
#line 113 "../lib/DragManager.vala"
		_tmp22_ = window;
#line 113 "../lib/DragManager.vala"
		plank_drag_manager_enable_drag_from (self, _tmp22_);
#line 832 "DragManager.c"
	}
}

static void
plank_drag_manager_lock_items_changed (PlankDragManager* self)
{
	PlankDockWindow* window = NULL;
	PlankDockController* _tmp0_;
	PlankDockWindow* _tmp1_;
	PlankDockWindow* _tmp2_;
	PlankDockController* _tmp3_;
	PlankDockPreferences* _tmp4_;
	PlankDockPreferences* _tmp5_;
	gboolean _tmp6_;
	gboolean _tmp7_;
#line 135 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 137 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_controller;
#line 137 "../lib/DragManager.vala"
	_tmp1_ = plank_dock_controller_get_window (_tmp0_);
#line 137 "../lib/DragManager.vala"
	_tmp2_ = _tmp1_;
#line 137 "../lib/DragManager.vala"
	window = _tmp2_;
#line 139 "../lib/DragManager.vala"
	_tmp3_ = self->priv->_controller;
#line 139 "../lib/DragManager.vala"
	_tmp4_ = plank_dock_controller_get_prefs (_tmp3_);
#line 139 "../lib/DragManager.vala"
	_tmp5_ = _tmp4_;
#line 139 "../lib/DragManager.vala"
	_tmp6_ = plank_dock_preferences_get_LockItems (_tmp5_);
#line 139 "../lib/DragManager.vala"
	_tmp7_ = _tmp6_;
#line 139 "../lib/DragManager.vala"
	if (_tmp7_) {
#line 870 "DragManager.c"
		PlankDockWindow* _tmp8_;
#line 140 "../lib/DragManager.vala"
		_tmp8_ = window;
#line 140 "../lib/DragManager.vala"
		plank_drag_manager_disable_drag_from (self, _tmp8_);
#line 876 "DragManager.c"
	} else {
		PlankDockWindow* _tmp9_;
#line 142 "../lib/DragManager.vala"
		_tmp9_ = window;
#line 142 "../lib/DragManager.vala"
		plank_drag_manager_enable_drag_from (self, _tmp9_);
#line 883 "DragManager.c"
	}
}

static gchar*
string_to_utf8 (const gchar* self,
                gint* result_length1)
{
	gint string_length = 0;
	gint _tmp0_;
	gint _tmp1_;
	gchar* _result_ = NULL;
	gchar* _tmp2_;
	gint _result__length1;
	gint __result__size_;
	gint _tmp3_;
	gchar* _tmp4_;
	gint _tmp4__length1;
	gchar* result = NULL;
#line 1570 "glib-2.0.vapi"
	g_return_val_if_fail (self != NULL, NULL);
#line 1571 "glib-2.0.vapi"
	_tmp0_ = strlen (self);
#line 1571 "glib-2.0.vapi"
	_tmp1_ = _tmp0_;
#line 1571 "glib-2.0.vapi"
	string_length = _tmp1_;
#line 1572 "glib-2.0.vapi"
	_tmp2_ = g_new0 (gchar, string_length + 1);
#line 1572 "glib-2.0.vapi"
	_result_ = _tmp2_;
#line 1572 "glib-2.0.vapi"
	_result__length1 = string_length + 1;
#line 1572 "glib-2.0.vapi"
	__result__size_ = _result__length1;
#line 1573 "glib-2.0.vapi"
	_tmp3_ = _result__length1;
#line 1573 "glib-2.0.vapi"
	_result__length1 = _tmp3_ - 1;
#line 1574 "glib-2.0.vapi"
	memcpy (_result_, self, (gsize) string_length);
#line 1575 "glib-2.0.vapi"
	_tmp4_ = _result_;
#line 1575 "glib-2.0.vapi"
	_tmp4__length1 = _result__length1;
#line 1575 "glib-2.0.vapi"
	if (result_length1) {
#line 1575 "glib-2.0.vapi"
		*result_length1 = _tmp4__length1;
#line 932 "DragManager.c"
	}
#line 1575 "glib-2.0.vapi"
	result = _tmp4_;
#line 1575 "glib-2.0.vapi"
	return result;
#line 938 "DragManager.c"
}

static void
plank_drag_manager_drag_data_get (GtkWidget* w,
                                  GdkDragContext* context,
                                  GtkSelectionData* selection_data,
                                  guint info,
                                  guint time_,
                                  PlankDragManager* self)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
#line 146 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 146 "../lib/DragManager.vala"
	g_return_if_fail (w != NULL);
#line 146 "../lib/DragManager.vala"
	g_return_if_fail (context != NULL);
#line 146 "../lib/DragManager.vala"
	g_return_if_fail (selection_data != NULL);
#line 148 "../lib/DragManager.vala"
	_tmp1_ = self->priv->_InternalDragActive;
#line 148 "../lib/DragManager.vala"
	if (_tmp1_) {
#line 963 "DragManager.c"
		PlankDockItem* _tmp2_;
#line 148 "../lib/DragManager.vala"
		_tmp2_ = self->priv->_DragItem;
#line 148 "../lib/DragManager.vala"
		_tmp0_ = _tmp2_ != NULL;
#line 969 "DragManager.c"
	} else {
#line 148 "../lib/DragManager.vala"
		_tmp0_ = FALSE;
#line 973 "DragManager.c"
	}
#line 148 "../lib/DragManager.vala"
	if (_tmp0_) {
#line 977 "DragManager.c"
		gchar* uri = NULL;
		PlankDockItem* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		const gchar* _tmp8_;
		gint _tmp9_ = 0;
		gchar* _tmp10_;
		guchar* _tmp11_;
		gint _tmp11__length1;
#line 149 "../lib/DragManager.vala"
		_tmp3_ = self->priv->_DragItem;
#line 149 "../lib/DragManager.vala"
		_tmp4_ = plank_dock_element_as_uri ((PlankDockElement*) _tmp3_);
#line 149 "../lib/DragManager.vala"
		_tmp5_ = _tmp4_;
#line 149 "../lib/DragManager.vala"
		_tmp6_ = g_strdup_printf ("%s\r\n", _tmp5_);
#line 149 "../lib/DragManager.vala"
		_tmp7_ = _tmp6_;
#line 149 "../lib/DragManager.vala"
		_g_free0 (_tmp5_);
#line 149 "../lib/DragManager.vala"
		uri = _tmp7_;
#line 150 "../lib/DragManager.vala"
		_tmp8_ = uri;
#line 150 "../lib/DragManager.vala"
		_tmp10_ = string_to_utf8 (_tmp8_, &_tmp9_);
#line 150 "../lib/DragManager.vala"
		_tmp11_ = (guchar*) _tmp10_;
#line 150 "../lib/DragManager.vala"
		_tmp11__length1 = (_tmp9_ * sizeof (gchar)) / sizeof (guchar);
#line 150 "../lib/DragManager.vala"
		gtk_selection_data_set (selection_data, gtk_selection_data_get_target (selection_data), 8, _tmp11_, (gint) ((_tmp9_ * sizeof (gchar)) / sizeof (guchar)));
#line 150 "../lib/DragManager.vala"
		_tmp11_ = (g_free (_tmp11_), NULL);
#line 148 "../lib/DragManager.vala"
		_g_free0 (uri);
#line 1017 "DragManager.c"
	}
}

/**
 * Whether the current dragged-data is accepted by the given dock-item
 *
 * @param item the dock-item
 */
gboolean
plank_drag_manager_drop_is_accepted_by (PlankDragManager* self,
                                        PlankDockItem* item)
{
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp1_;
	gboolean result = FALSE;
#line 159 "../lib/DragManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 159 "../lib/DragManager.vala"
	g_return_val_if_fail (item != NULL, FALSE);
#line 161 "../lib/DragManager.vala"
	_tmp0_ = self->priv->drag_data;
#line 161 "../lib/DragManager.vala"
	if (_tmp0_ == NULL) {
#line 162 "../lib/DragManager.vala"
		result = FALSE;
#line 162 "../lib/DragManager.vala"
		return result;
#line 1045 "DragManager.c"
	}
#line 164 "../lib/DragManager.vala"
	_tmp1_ = self->priv->drag_data;
#line 164 "../lib/DragManager.vala"
	result = plank_dock_element_can_accept_drop ((PlankDockElement*) item, _tmp1_);
#line 164 "../lib/DragManager.vala"
	return result;
#line 1053 "DragManager.c"
}

static void
plank_drag_manager_set_drag_icon (PlankDragManager* self,
                                  GdkDragContext* context,
                                  PlankDockItem* item,
                                  gdouble opacity)
{
	PlankDockController* _tmp0_;
	PlankDockWindow* _tmp1_;
	PlankDockWindow* _tmp2_;
	GdkWindow* _tmp3_;
	gint drag_icon_size = 0;
	PlankDockController* _tmp4_;
	PlankPositionManager* _tmp5_;
	PlankPositionManager* _tmp6_;
	gint _tmp7_;
	gint _tmp8_;
	PlankSurface* drag_surface = NULL;
	PlankSurface* _tmp10_;
	PlankSurface* _tmp11_;
	cairo_surface_t* _tmp12_;
	cairo_surface_t* _tmp13_;
	PlankSurface* item_surface = NULL;
	PlankSurface* _tmp14_;
	PlankSurface* _tmp15_;
	cairo_t* cr = NULL;
	PlankSurface* _tmp16_;
	cairo_t* _tmp17_;
	cairo_t* _tmp18_;
	cairo_t* _tmp21_;
	cairo_t* _tmp22_;
	PlankSurface* _tmp23_;
	cairo_surface_t* _tmp24_;
	cairo_surface_t* _tmp25_;
	cairo_t* _tmp26_;
	cairo_surface_t* surface = NULL;
	PlankSurface* _tmp28_;
	cairo_surface_t* _tmp29_;
	cairo_surface_t* _tmp30_;
	cairo_surface_t* _tmp31_;
	cairo_surface_t* _tmp32_;
#line 167 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 167 "../lib/DragManager.vala"
	g_return_if_fail (context != NULL);
#line 169 "../lib/DragManager.vala"
	if (item == NULL) {
#line 170 "../lib/DragManager.vala"
		gtk_drag_set_icon_default (context);
#line 171 "../lib/DragManager.vala"
		return;
#line 1106 "DragManager.c"
	}
#line 174 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_controller;
#line 174 "../lib/DragManager.vala"
	_tmp1_ = plank_dock_controller_get_window (_tmp0_);
#line 174 "../lib/DragManager.vala"
	_tmp2_ = _tmp1_;
#line 174 "../lib/DragManager.vala"
	_tmp3_ = gtk_widget_get_window ((GtkWidget*) _tmp2_);
#line 174 "../lib/DragManager.vala"
	self->priv->window_scale_factor = gdk_window_get_scale_factor (_tmp3_);
#line 175 "../lib/DragManager.vala"
	_tmp4_ = self->priv->_controller;
#line 175 "../lib/DragManager.vala"
	_tmp5_ = plank_dock_controller_get_position_manager (_tmp4_);
#line 175 "../lib/DragManager.vala"
	_tmp6_ = _tmp5_;
#line 175 "../lib/DragManager.vala"
	_tmp7_ = plank_position_manager_get_ZoomIconSize (_tmp6_);
#line 175 "../lib/DragManager.vala"
	_tmp8_ = _tmp7_;
#line 175 "../lib/DragManager.vala"
	drag_icon_size = (gint) (1.2 * _tmp8_);
#line 176 "../lib/DragManager.vala"
	if ((drag_icon_size % 2) == 1) {
#line 1132 "DragManager.c"
		gint _tmp9_;
#line 177 "../lib/DragManager.vala"
		_tmp9_ = drag_icon_size;
#line 177 "../lib/DragManager.vala"
		drag_icon_size = _tmp9_ + 1;
#line 1138 "DragManager.c"
	}
#line 178 "../lib/DragManager.vala"
	drag_icon_size *= self->priv->window_scale_factor;
#line 179 "../lib/DragManager.vala"
	_tmp10_ = plank_surface_new (drag_icon_size, drag_icon_size);
#line 179 "../lib/DragManager.vala"
	drag_surface = _tmp10_;
#line 180 "../lib/DragManager.vala"
	_tmp11_ = drag_surface;
#line 180 "../lib/DragManager.vala"
	_tmp12_ = plank_surface_get_Internal (_tmp11_);
#line 180 "../lib/DragManager.vala"
	_tmp13_ = _tmp12_;
#line 180 "../lib/DragManager.vala"
	cairo_surface_set_device_scale (_tmp13_, (gdouble) self->priv->window_scale_factor, (gdouble) self->priv->window_scale_factor);
#line 182 "../lib/DragManager.vala"
	_tmp14_ = drag_surface;
#line 182 "../lib/DragManager.vala"
	_tmp15_ = plank_dock_item_get_surface_copy (item, drag_icon_size, drag_icon_size, _tmp14_);
#line 182 "../lib/DragManager.vala"
	item_surface = _tmp15_;
#line 183 "../lib/DragManager.vala"
	_tmp16_ = drag_surface;
#line 183 "../lib/DragManager.vala"
	_tmp17_ = plank_surface_get_Context (_tmp16_);
#line 183 "../lib/DragManager.vala"
	_tmp18_ = _tmp17_;
#line 183 "../lib/DragManager.vala"
	cr = _tmp18_;
#line 184 "../lib/DragManager.vala"
	if (self->priv->window_scale_factor > 1) {
#line 1170 "DragManager.c"
		cairo_t* _tmp19_;
		cairo_t* _tmp20_;
#line 185 "../lib/DragManager.vala"
		_tmp19_ = cr;
#line 185 "../lib/DragManager.vala"
		cairo_save (_tmp19_);
#line 186 "../lib/DragManager.vala"
		_tmp20_ = cr;
#line 186 "../lib/DragManager.vala"
		cairo_scale (_tmp20_, 1.0 / self->priv->window_scale_factor, 1.0 / self->priv->window_scale_factor);
#line 1181 "DragManager.c"
	}
#line 188 "../lib/DragManager.vala"
	_tmp21_ = cr;
#line 188 "../lib/DragManager.vala"
	cairo_set_operator (_tmp21_, CAIRO_OPERATOR_OVER);
#line 189 "../lib/DragManager.vala"
	_tmp22_ = cr;
#line 189 "../lib/DragManager.vala"
	_tmp23_ = item_surface;
#line 189 "../lib/DragManager.vala"
	_tmp24_ = plank_surface_get_Internal (_tmp23_);
#line 189 "../lib/DragManager.vala"
	_tmp25_ = _tmp24_;
#line 189 "../lib/DragManager.vala"
	cairo_set_source_surface (_tmp22_, _tmp25_, (gdouble) 0, (gdouble) 0);
#line 190 "../lib/DragManager.vala"
	_tmp26_ = cr;
#line 190 "../lib/DragManager.vala"
	cairo_paint_with_alpha (_tmp26_, opacity);
#line 191 "../lib/DragManager.vala"
	if (self->priv->window_scale_factor > 1) {
#line 1203 "DragManager.c"
		cairo_t* _tmp27_;
#line 192 "../lib/DragManager.vala"
		_tmp27_ = cr;
#line 192 "../lib/DragManager.vala"
		cairo_restore (_tmp27_);
#line 1209 "DragManager.c"
	}
#line 194 "../lib/DragManager.vala"
	_tmp28_ = drag_surface;
#line 194 "../lib/DragManager.vala"
	_tmp29_ = plank_surface_get_Internal (_tmp28_);
#line 194 "../lib/DragManager.vala"
	_tmp30_ = _tmp29_;
#line 194 "../lib/DragManager.vala"
	surface = _tmp30_;
#line 195 "../lib/DragManager.vala"
	_tmp31_ = surface;
#line 195 "../lib/DragManager.vala"
	cairo_surface_set_device_offset (_tmp31_, (-drag_icon_size) / 2.0, (-drag_icon_size) / 2.0);
#line 196 "../lib/DragManager.vala"
	_tmp32_ = surface;
#line 196 "../lib/DragManager.vala"
	gtk_drag_set_icon_surface (context, _tmp32_);
#line 167 "../lib/DragManager.vala"
	_g_object_unref0 (item_surface);
#line 167 "../lib/DragManager.vala"
	_g_object_unref0 (drag_surface);
#line 1231 "DragManager.c"
}

static gpointer
_g_object_ref0 (gpointer self)
{
#line 200 "../lib/DragManager.vala"
	return self ? g_object_ref (self) : NULL;
#line 1239 "DragManager.c"
}

static Block3Data*
block3_data_ref (Block3Data* _data3_)
{
#line 200 "../lib/DragManager.vala"
	g_atomic_int_inc (&_data3_->_ref_count_);
#line 200 "../lib/DragManager.vala"
	return _data3_;
#line 1249 "DragManager.c"
}

static void
block3_data_unref (void * _userdata_)
{
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
#line 200 "../lib/DragManager.vala"
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
#line 1259 "DragManager.c"
		PlankDragManager* self;
#line 200 "../lib/DragManager.vala"
		self = _data3_->self;
#line 200 "../lib/DragManager.vala"
		_g_object_unref0 (_data3_->context);
#line 200 "../lib/DragManager.vala"
		_g_object_unref0 (self);
#line 200 "../lib/DragManager.vala"
		g_slice_free (Block3Data, _data3_);
#line 1269 "DragManager.c"
	}
}

static void
_plank_drag_manager_hovered_item_changed_g_object_notify (GObject* _sender,
                                                          GParamSpec* pspec,
                                                          gpointer self)
{
#line 204 "../lib/DragManager.vala"
	plank_drag_manager_hovered_item_changed ((PlankDragManager*) self);
#line 1280 "DragManager.c"
}

static void
__lambda58_ (Block3Data* _data3_)
{
	PlankDragManager* self;
	PlankDockItem* _tmp0_;
#line 225 "../lib/DragManager.vala"
	self = _data3_->self;
#line 226 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_DragItem;
#line 226 "../lib/DragManager.vala"
	plank_drag_manager_set_drag_icon (self, _data3_->context, _tmp0_, 0.8);
#line 1294 "DragManager.c"
}

static void
___lambda58__plank_dock_element_needs_redraw (PlankDockElement* _sender,
                                              gpointer self)
{
#line 225 "../lib/DragManager.vala"
	__lambda58_ (self);
#line 1303 "DragManager.c"
}

static void
plank_drag_manager_drag_begin (GtkWidget* w,
                               GdkDragContext* context,
                               PlankDragManager* self)
{
	Block3Data* _data3_;
	GdkDragContext* _tmp0_;
	PlankDockWindow* window = NULL;
	PlankDockController* _tmp1_;
	PlankDockWindow* _tmp2_;
	PlankDockWindow* _tmp3_;
	PlankDockWindow* _tmp4_;
	GdkWindow* _tmp5_;
	PlankDockWindow* _tmp7_;
	PlankDockItem* _tmp8_;
	PlankDockItem* _tmp9_;
	gboolean _tmp10_;
	gboolean _tmp11_;
	PlankDockItem* _tmp12_;
	PlankDockItem* _tmp13_;
	PlankDockItem* _tmp14_;
	gulong _tmp15_;
	GdkDevice* _tmp16_;
	PlankDockWindow* _tmp17_;
	GdkWindow* _tmp18_;
#line 200 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 200 "../lib/DragManager.vala"
	g_return_if_fail (w != NULL);
#line 200 "../lib/DragManager.vala"
	g_return_if_fail (context != NULL);
#line 200 "../lib/DragManager.vala"
	_data3_ = g_slice_new0 (Block3Data);
#line 200 "../lib/DragManager.vala"
	_data3_->_ref_count_ = 1;
#line 200 "../lib/DragManager.vala"
	_data3_->self = g_object_ref (self);
#line 200 "../lib/DragManager.vala"
	_tmp0_ = _g_object_ref0 (context);
#line 200 "../lib/DragManager.vala"
	_g_object_unref0 (_data3_->context);
#line 200 "../lib/DragManager.vala"
	_data3_->context = _tmp0_;
#line 202 "../lib/DragManager.vala"
	_tmp1_ = self->priv->_controller;
#line 202 "../lib/DragManager.vala"
	_tmp2_ = plank_dock_controller_get_window (_tmp1_);
#line 202 "../lib/DragManager.vala"
	_tmp3_ = _tmp2_;
#line 202 "../lib/DragManager.vala"
	window = _tmp3_;
#line 204 "../lib/DragManager.vala"
	_tmp4_ = window;
#line 204 "../lib/DragManager.vala"
	g_signal_connect_object ((GObject*) _tmp4_, "notify::HoveredItem", (GCallback) _plank_drag_manager_hovered_item_changed_g_object_notify, self, 0);
#line 206 "../lib/DragManager.vala"
	plank_drag_manager_set_InternalDragActive (self, TRUE);
#line 207 "../lib/DragManager.vala"
	self->priv->drag_canceled = FALSE;
#line 209 "../lib/DragManager.vala"
	_tmp5_ = self->priv->proxy_window;
#line 209 "../lib/DragManager.vala"
	if (_tmp5_ != NULL) {
#line 1369 "DragManager.c"
		PlankDockWindow* _tmp6_;
#line 210 "../lib/DragManager.vala"
		_tmp6_ = window;
#line 210 "../lib/DragManager.vala"
		plank_drag_manager_enable_drag_to (self, _tmp6_);
#line 211 "../lib/DragManager.vala"
		_g_object_unref0 (self->priv->proxy_window);
#line 211 "../lib/DragManager.vala"
		self->priv->proxy_window = NULL;
#line 1379 "DragManager.c"
	}
#line 214 "../lib/DragManager.vala"
	_tmp7_ = window;
#line 214 "../lib/DragManager.vala"
	_tmp8_ = plank_dock_window_get_HoveredItem (_tmp7_);
#line 214 "../lib/DragManager.vala"
	_tmp9_ = _tmp8_;
#line 214 "../lib/DragManager.vala"
	plank_drag_manager_set_DragItem (self, _tmp9_);
#line 216 "../lib/DragManager.vala"
	_tmp10_ = plank_drag_manager_get_RepositionMode (self);
#line 216 "../lib/DragManager.vala"
	_tmp11_ = _tmp10_;
#line 216 "../lib/DragManager.vala"
	if (_tmp11_) {
#line 217 "../lib/DragManager.vala"
		plank_drag_manager_set_DragItem (self, NULL);
#line 1397 "DragManager.c"
	}
#line 219 "../lib/DragManager.vala"
	_tmp12_ = self->priv->_DragItem;
#line 219 "../lib/DragManager.vala"
	if (_tmp12_ == NULL) {
#line 220 "../lib/DragManager.vala"
		gdk_drag_abort (_data3_->context, gtk_get_current_event_time ());
#line 221 "../lib/DragManager.vala"
		block3_data_unref (_data3_);
#line 221 "../lib/DragManager.vala"
		_data3_ = NULL;
#line 221 "../lib/DragManager.vala"
		return;
#line 1411 "DragManager.c"
	}
#line 224 "../lib/DragManager.vala"
	_tmp13_ = self->priv->_DragItem;
#line 224 "../lib/DragManager.vala"
	plank_drag_manager_set_drag_icon (self, _data3_->context, _tmp13_, 0.8);
#line 225 "../lib/DragManager.vala"
	_tmp14_ = self->priv->_DragItem;
#line 225 "../lib/DragManager.vala"
	_tmp15_ = g_signal_connect_data ((PlankDockElement*) _tmp14_, "needs-redraw", (GCallback) ___lambda58__plank_dock_element_needs_redraw, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
#line 225 "../lib/DragManager.vala"
	self->priv->drag_item_redraw_handler_id = _tmp15_;
#line 229 "../lib/DragManager.vala"
	_tmp16_ = gdk_drag_context_get_device (_data3_->context);
#line 229 "../lib/DragManager.vala"
	_tmp17_ = window;
#line 229 "../lib/DragManager.vala"
	_tmp18_ = gtk_widget_get_window ((GtkWidget*) _tmp17_);
#line 229 "../lib/DragManager.vala"
	gdk_device_grab (_tmp16_, _tmp18_, GDK_OWNERSHIP_APPLICATION, TRUE, GDK_ALL_EVENTS_MASK, NULL, gtk_get_current_event_time ());
#line 200 "../lib/DragManager.vala"
	block3_data_unref (_data3_);
#line 200 "../lib/DragManager.vala"
	_data3_ = NULL;
#line 1435 "DragManager.c"
}

static void
plank_drag_manager_drag_data_received (GtkWidget* w,
                                       GdkDragContext* context,
                                       gint x,
                                       gint y,
                                       GtkSelectionData* selection_data,
                                       guint info,
                                       guint time_,
                                       PlankDragManager* self)
{
#line 234 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 234 "../lib/DragManager.vala"
	g_return_if_fail (w != NULL);
#line 234 "../lib/DragManager.vala"
	g_return_if_fail (context != NULL);
#line 234 "../lib/DragManager.vala"
	g_return_if_fail (selection_data != NULL);
#line 236 "../lib/DragManager.vala"
	if (self->priv->drag_data_requested) {
#line 1458 "DragManager.c"
		const gchar* data = NULL;
		guint8* _tmp0_;
		const gchar* _tmp1_;
		gchar** uris = NULL;
		const gchar* _tmp2_;
		gchar** _tmp3_;
		gchar** _tmp4_;
		gint uris_length1;
		gint _uris_size_;
		GeeArrayList* _tmp5_;
		gchar** _tmp6_;
		gint _tmp6__length1;
		GeeArrayList* _tmp18_;
		gint _tmp19_;
		gint _tmp20_;
		PlankDockController* _tmp26_;
		PlankDockRenderer* _tmp27_;
		PlankDockRenderer* _tmp28_;
#line 237 "../lib/DragManager.vala"
		_tmp0_ = gtk_selection_data_get_data (selection_data);
#line 237 "../lib/DragManager.vala"
		data = (const gchar*) _tmp0_;
#line 238 "../lib/DragManager.vala"
		_tmp1_ = data;
#line 238 "../lib/DragManager.vala"
		if (_tmp1_ == NULL) {
#line 239 "../lib/DragManager.vala"
			self->priv->drag_data_requested = FALSE;
#line 240 "../lib/DragManager.vala"
			gdk_drag_status (context, GDK_ACTION_COPY, (guint32) time_);
#line 241 "../lib/DragManager.vala"
			return;
#line 1491 "DragManager.c"
		}
#line 244 "../lib/DragManager.vala"
		_tmp2_ = data;
#line 244 "../lib/DragManager.vala"
		_tmp4_ = _tmp3_ = g_uri_list_extract_uris (_tmp2_);
#line 244 "../lib/DragManager.vala"
		uris = _tmp4_;
#line 244 "../lib/DragManager.vala"
		uris_length1 = _vala_array_length (_tmp3_);
#line 244 "../lib/DragManager.vala"
		_uris_size_ = uris_length1;
#line 246 "../lib/DragManager.vala"
		_tmp5_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL);
#line 246 "../lib/DragManager.vala"
		_g_object_unref0 (self->priv->drag_data);
#line 246 "../lib/DragManager.vala"
		self->priv->drag_data = _tmp5_;
#line 247 "../lib/DragManager.vala"
		_tmp6_ = uris;
#line 247 "../lib/DragManager.vala"
		_tmp6__length1 = uris_length1;
#line 1513 "DragManager.c"
		{
			gchar** s_collection = NULL;
			gint s_collection_length1 = 0;
			gint _s_collection_size_ = 0;
			gint s_it = 0;
#line 247 "../lib/DragManager.vala"
			s_collection = _tmp6_;
#line 247 "../lib/DragManager.vala"
			s_collection_length1 = _tmp6__length1;
#line 247 "../lib/DragManager.vala"
			for (s_it = 0; s_it < s_collection_length1; s_it = s_it + 1) {
#line 1525 "DragManager.c"
				const gchar* s = NULL;
#line 247 "../lib/DragManager.vala"
				s = s_collection[s_it];
#line 1529 "DragManager.c"
				{
					const gchar* _tmp7_;
					gchar* uri = NULL;
					const gchar* _tmp10_;
					GFile* _tmp11_;
					GFile* _tmp12_;
					gchar* _tmp13_;
					gchar* _tmp14_;
					const gchar* _tmp15_;
#line 248 "../lib/DragManager.vala"
					_tmp7_ = s;
#line 248 "../lib/DragManager.vala"
					if (g_str_has_prefix (_tmp7_, PLANK_DOCKLET_URI_PREFIX)) {
#line 1543 "DragManager.c"
						GeeArrayList* _tmp8_;
						const gchar* _tmp9_;
#line 249 "../lib/DragManager.vala"
						_tmp8_ = self->priv->drag_data;
#line 249 "../lib/DragManager.vala"
						_tmp9_ = s;
#line 249 "../lib/DragManager.vala"
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp8_, _tmp9_);
#line 250 "../lib/DragManager.vala"
						continue;
#line 1554 "DragManager.c"
					}
#line 253 "../lib/DragManager.vala"
					_tmp10_ = s;
#line 253 "../lib/DragManager.vala"
					_tmp11_ = g_file_new_for_uri (_tmp10_);
#line 253 "../lib/DragManager.vala"
					_tmp12_ = _tmp11_;
#line 253 "../lib/DragManager.vala"
					_tmp13_ = g_file_get_uri (_tmp12_);
#line 253 "../lib/DragManager.vala"
					_tmp14_ = _tmp13_;
#line 253 "../lib/DragManager.vala"
					_g_object_unref0 (_tmp12_);
#line 253 "../lib/DragManager.vala"
					uri = _tmp14_;
#line 254 "../lib/DragManager.vala"
					_tmp15_ = uri;
#line 254 "../lib/DragManager.vala"
					if (_tmp15_ != NULL) {
#line 1574 "DragManager.c"
						GeeArrayList* _tmp16_;
						const gchar* _tmp17_;
#line 255 "../lib/DragManager.vala"
						_tmp16_ = self->priv->drag_data;
#line 255 "../lib/DragManager.vala"
						_tmp17_ = uri;
#line 255 "../lib/DragManager.vala"
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp16_, _tmp17_);
#line 1583 "DragManager.c"
					}
#line 247 "../lib/DragManager.vala"
					_g_free0 (uri);
#line 1587 "DragManager.c"
				}
			}
		}
#line 258 "../lib/DragManager.vala"
		self->priv->drag_data_requested = FALSE;
#line 260 "../lib/DragManager.vala"
		_tmp18_ = self->priv->drag_data;
#line 260 "../lib/DragManager.vala"
		_tmp19_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp18_);
#line 260 "../lib/DragManager.vala"
		_tmp20_ = _tmp19_;
#line 260 "../lib/DragManager.vala"
		if (_tmp20_ == 1) {
#line 1601 "DragManager.c"
			gchar* uri = NULL;
			GeeArrayList* _tmp21_;
			gpointer _tmp22_;
			gboolean _tmp23_ = FALSE;
			const gchar* _tmp24_;
#line 261 "../lib/DragManager.vala"
			_tmp21_ = self->priv->drag_data;
#line 261 "../lib/DragManager.vala"
			_tmp22_ = gee_abstract_list_get ((GeeAbstractList*) _tmp21_, 0);
#line 261 "../lib/DragManager.vala"
			uri = (gchar*) _tmp22_;
#line 262 "../lib/DragManager.vala"
			_tmp24_ = uri;
#line 262 "../lib/DragManager.vala"
			if (g_str_has_prefix (_tmp24_, PLANK_DOCKLET_URI_PREFIX)) {
#line 262 "../lib/DragManager.vala"
				_tmp23_ = TRUE;
#line 1619 "DragManager.c"
			} else {
				const gchar* _tmp25_;
#line 262 "../lib/DragManager.vala"
				_tmp25_ = uri;
#line 262 "../lib/DragManager.vala"
				_tmp23_ = g_str_has_suffix (_tmp25_, ".desktop");
#line 1626 "DragManager.c"
			}
#line 262 "../lib/DragManager.vala"
			plank_drag_manager_set_DragNeedsCheck (self, !_tmp23_);
#line 260 "../lib/DragManager.vala"
			_g_free0 (uri);
#line 1632 "DragManager.c"
		} else {
#line 264 "../lib/DragManager.vala"
			plank_drag_manager_set_DragNeedsCheck (self, TRUE);
#line 1636 "DragManager.c"
		}
#line 269 "../lib/DragManager.vala"
		_tmp26_ = self->priv->_controller;
#line 269 "../lib/DragManager.vala"
		_tmp27_ = plank_dock_controller_get_renderer (_tmp26_);
#line 269 "../lib/DragManager.vala"
		_tmp28_ = _tmp27_;
#line 269 "../lib/DragManager.vala"
		plank_renderer_animated_draw ((PlankRenderer*) _tmp28_);
#line 273 "../lib/DragManager.vala"
		plank_drag_manager_hovered_item_changed (self);
#line 236 "../lib/DragManager.vala"
		uris = (_vala_array_free (uris, uris_length1, (GDestroyNotify) g_free), NULL);
#line 1650 "DragManager.c"
	}
#line 276 "../lib/DragManager.vala"
	gdk_drag_status (context, GDK_ACTION_COPY, (guint32) time_);
#line 1654 "DragManager.c"
}

static gboolean
plank_drag_manager_drag_drop (GtkWidget* w,
                              GdkDragContext* context,
                              gint x,
                              gint y,
                              guint time_,
                              PlankDragManager* self)
{
	GeeArrayList* _tmp0_;
	PlankDockWindow* window = NULL;
	PlankDockController* _tmp1_;
	PlankDockWindow* _tmp2_;
	PlankDockWindow* _tmp3_;
	PlankDockItem* item = NULL;
	PlankDockWindow* _tmp4_;
	PlankDockItem* _tmp5_;
	PlankDockItem* _tmp6_;
	PlankDockItemProvider* provider = NULL;
	PlankDockWindow* _tmp7_;
	PlankDockItemProvider* _tmp8_;
	PlankDockItemProvider* _tmp9_;
	gboolean _tmp10_ = FALSE;
	gboolean _tmp11_ = FALSE;
	gboolean _tmp12_;
	gboolean result = FALSE;
#line 280 "../lib/DragManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 280 "../lib/DragManager.vala"
	g_return_val_if_fail (w != NULL, FALSE);
#line 280 "../lib/DragManager.vala"
	g_return_val_if_fail (context != NULL, FALSE);
#line 282 "../lib/DragManager.vala"
	gtk_drag_finish (context, TRUE, FALSE, (guint32) time_);
#line 284 "../lib/DragManager.vala"
	if (self->priv->drag_hover_timer_id > 0U) {
#line 285 "../lib/DragManager.vala"
		g_source_remove (self->priv->drag_hover_timer_id);
#line 286 "../lib/DragManager.vala"
		self->priv->drag_hover_timer_id = 0U;
#line 1696 "DragManager.c"
	}
#line 289 "../lib/DragManager.vala"
	_tmp0_ = self->priv->drag_data;
#line 289 "../lib/DragManager.vala"
	if (_tmp0_ == NULL) {
#line 290 "../lib/DragManager.vala"
		result = TRUE;
#line 290 "../lib/DragManager.vala"
		return result;
#line 1706 "DragManager.c"
	}
#line 292 "../lib/DragManager.vala"
	_tmp1_ = self->priv->_controller;
#line 292 "../lib/DragManager.vala"
	_tmp2_ = plank_dock_controller_get_window (_tmp1_);
#line 292 "../lib/DragManager.vala"
	_tmp3_ = _tmp2_;
#line 292 "../lib/DragManager.vala"
	window = _tmp3_;
#line 293 "../lib/DragManager.vala"
	_tmp4_ = window;
#line 293 "../lib/DragManager.vala"
	_tmp5_ = plank_dock_window_get_HoveredItem (_tmp4_);
#line 293 "../lib/DragManager.vala"
	_tmp6_ = _tmp5_;
#line 293 "../lib/DragManager.vala"
	item = _tmp6_;
#line 294 "../lib/DragManager.vala"
	_tmp7_ = window;
#line 294 "../lib/DragManager.vala"
	_tmp8_ = plank_dock_window_get_HoveredItemProvider (_tmp7_);
#line 294 "../lib/DragManager.vala"
	_tmp9_ = _tmp8_;
#line 294 "../lib/DragManager.vala"
	provider = _tmp9_;
#line 296 "../lib/DragManager.vala"
	_tmp12_ = self->priv->_DragNeedsCheck;
#line 296 "../lib/DragManager.vala"
	if (_tmp12_) {
#line 1736 "DragManager.c"
		PlankDockItem* _tmp13_;
#line 296 "../lib/DragManager.vala"
		_tmp13_ = item;
#line 296 "../lib/DragManager.vala"
		_tmp11_ = _tmp13_ != NULL;
#line 1742 "DragManager.c"
	} else {
#line 296 "../lib/DragManager.vala"
		_tmp11_ = FALSE;
#line 1746 "DragManager.c"
	}
#line 296 "../lib/DragManager.vala"
	if (_tmp11_) {
#line 1750 "DragManager.c"
		PlankDockItem* _tmp14_;
		GeeArrayList* _tmp15_;
#line 296 "../lib/DragManager.vala"
		_tmp14_ = item;
#line 296 "../lib/DragManager.vala"
		_tmp15_ = self->priv->drag_data;
#line 296 "../lib/DragManager.vala"
		_tmp10_ = plank_dock_element_can_accept_drop ((PlankDockElement*) _tmp14_, _tmp15_);
#line 1759 "DragManager.c"
	} else {
#line 296 "../lib/DragManager.vala"
		_tmp10_ = FALSE;
#line 1763 "DragManager.c"
	}
#line 296 "../lib/DragManager.vala"
	if (_tmp10_) {
#line 1767 "DragManager.c"
		PlankDockItem* _tmp16_;
		GeeArrayList* _tmp17_;
#line 297 "../lib/DragManager.vala"
		_tmp16_ = item;
#line 297 "../lib/DragManager.vala"
		_tmp17_ = self->priv->drag_data;
#line 297 "../lib/DragManager.vala"
		plank_dock_element_accept_drop ((PlankDockElement*) _tmp16_, _tmp17_);
#line 1776 "DragManager.c"
	} else {
		gboolean _tmp18_ = FALSE;
		gboolean _tmp19_ = FALSE;
		PlankDockController* _tmp20_;
		PlankDockPreferences* _tmp21_;
		PlankDockPreferences* _tmp22_;
		gboolean _tmp23_;
		gboolean _tmp24_;
#line 298 "../lib/DragManager.vala"
		_tmp20_ = self->priv->_controller;
#line 298 "../lib/DragManager.vala"
		_tmp21_ = plank_dock_controller_get_prefs (_tmp20_);
#line 298 "../lib/DragManager.vala"
		_tmp22_ = _tmp21_;
#line 298 "../lib/DragManager.vala"
		_tmp23_ = plank_dock_preferences_get_LockItems (_tmp22_);
#line 298 "../lib/DragManager.vala"
		_tmp24_ = _tmp23_;
#line 298 "../lib/DragManager.vala"
		if (!_tmp24_) {
#line 1797 "DragManager.c"
			PlankDockItemProvider* _tmp25_;
#line 298 "../lib/DragManager.vala"
			_tmp25_ = provider;
#line 298 "../lib/DragManager.vala"
			_tmp19_ = _tmp25_ != NULL;
#line 1803 "DragManager.c"
		} else {
#line 298 "../lib/DragManager.vala"
			_tmp19_ = FALSE;
#line 1807 "DragManager.c"
		}
#line 298 "../lib/DragManager.vala"
		if (_tmp19_) {
#line 1811 "DragManager.c"
			PlankDockItemProvider* _tmp26_;
			GeeArrayList* _tmp27_;
#line 298 "../lib/DragManager.vala"
			_tmp26_ = provider;
#line 298 "../lib/DragManager.vala"
			_tmp27_ = self->priv->drag_data;
#line 298 "../lib/DragManager.vala"
			_tmp18_ = plank_dock_element_can_accept_drop ((PlankDockElement*) _tmp26_, _tmp27_);
#line 1820 "DragManager.c"
		} else {
#line 298 "../lib/DragManager.vala"
			_tmp18_ = FALSE;
#line 1824 "DragManager.c"
		}
#line 298 "../lib/DragManager.vala"
		if (_tmp18_) {
#line 1828 "DragManager.c"
			PlankDockItemProvider* _tmp28_;
			GeeArrayList* _tmp29_;
#line 299 "../lib/DragManager.vala"
			_tmp28_ = provider;
#line 299 "../lib/DragManager.vala"
			_tmp29_ = self->priv->drag_data;
#line 299 "../lib/DragManager.vala"
			plank_dock_element_accept_drop ((PlankDockElement*) _tmp28_, _tmp29_);
#line 1837 "DragManager.c"
		}
	}
#line 301 "../lib/DragManager.vala"
	plank_drag_manager_set_ExternalDragActive (self, FALSE);
#line 302 "../lib/DragManager.vala"
	result = TRUE;
#line 302 "../lib/DragManager.vala"
	return result;
#line 1846 "DragManager.c"
}

static void
plank_drag_manager_drag_end (GtkWidget* w,
                             GdkDragContext* context,
                             PlankDragManager* self)
{
	PlankHideManager* hide_manager = NULL;
	PlankDockController* _tmp0_;
	PlankHideManager* _tmp1_;
	PlankHideManager* _tmp2_;
	gboolean _tmp5_ = FALSE;
	GdkDevice* _tmp46_;
	PlankDockController* _tmp47_;
	PlankDockWindow* _tmp48_;
	PlankDockWindow* _tmp49_;
	guint _tmp50_;
	GQuark _tmp51_;
	PlankDockController* _tmp52_;
	PlankHoverWindow* _tmp53_;
	PlankHoverWindow* _tmp54_;
	PlankDockController* _tmp55_;
	PlankDockRenderer* _tmp56_;
	PlankDockRenderer* _tmp57_;
	PlankHideManager* _tmp58_;
#line 306 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 306 "../lib/DragManager.vala"
	g_return_if_fail (w != NULL);
#line 306 "../lib/DragManager.vala"
	g_return_if_fail (context != NULL);
#line 308 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_controller;
#line 308 "../lib/DragManager.vala"
	_tmp1_ = plank_dock_controller_get_hide_manager (_tmp0_);
#line 308 "../lib/DragManager.vala"
	_tmp2_ = _tmp1_;
#line 308 "../lib/DragManager.vala"
	hide_manager = _tmp2_;
#line 310 "../lib/DragManager.vala"
	if (self->priv->drag_item_redraw_handler_id > 0UL) {
#line 1888 "DragManager.c"
		PlankDockItem* _tmp3_;
#line 311 "../lib/DragManager.vala"
		_tmp3_ = self->priv->_DragItem;
#line 311 "../lib/DragManager.vala"
		if (_tmp3_ != NULL) {
#line 1894 "DragManager.c"
			PlankDockItem* _tmp4_;
#line 312 "../lib/DragManager.vala"
			_tmp4_ = self->priv->_DragItem;
#line 312 "../lib/DragManager.vala"
			g_signal_handler_disconnect (_tmp4_, self->priv->drag_item_redraw_handler_id);
#line 1900 "DragManager.c"
		}
#line 313 "../lib/DragManager.vala"
		self->priv->drag_item_redraw_handler_id = 0UL;
#line 1904 "DragManager.c"
	}
#line 316 "../lib/DragManager.vala"
	if (!self->priv->drag_canceled) {
#line 1908 "DragManager.c"
		PlankDockItem* _tmp6_;
#line 316 "../lib/DragManager.vala"
		_tmp6_ = self->priv->_DragItem;
#line 316 "../lib/DragManager.vala"
		_tmp5_ = _tmp6_ != NULL;
#line 1914 "DragManager.c"
	} else {
#line 316 "../lib/DragManager.vala"
		_tmp5_ = FALSE;
#line 1918 "DragManager.c"
	}
#line 316 "../lib/DragManager.vala"
	if (_tmp5_) {
#line 1922 "DragManager.c"
		PlankHideManager* _tmp7_;
		PlankHideManager* _tmp8_;
		gboolean _tmp9_;
		gboolean _tmp10_;
#line 317 "../lib/DragManager.vala"
		_tmp7_ = hide_manager;
#line 317 "../lib/DragManager.vala"
		plank_hide_manager_update_hovered (_tmp7_);
#line 318 "../lib/DragManager.vala"
		_tmp8_ = hide_manager;
#line 318 "../lib/DragManager.vala"
		_tmp9_ = plank_hide_manager_get_Hovered (_tmp8_);
#line 318 "../lib/DragManager.vala"
		_tmp10_ = _tmp9_;
#line 318 "../lib/DragManager.vala"
		if (!_tmp10_) {
#line 1939 "DragManager.c"
			PlankDockItem* _tmp11_;
#line 319 "../lib/DragManager.vala"
			_tmp11_ = self->priv->_DragItem;
#line 319 "../lib/DragManager.vala"
			if (plank_dock_element_can_be_removed ((PlankDockElement*) _tmp11_)) {
#line 1945 "DragManager.c"
				PlankApplicationDockItem* app_item = NULL;
				PlankDockItem* _tmp12_;
				gboolean _tmp13_ = FALSE;
				PlankApplicationDockItem* _tmp14_;
				PlankDockItem* _tmp23_;
				gint x = 0;
				gint y = 0;
				GdkDevice* _tmp24_;
				gint _tmp25_ = 0;
				gint _tmp26_ = 0;
				PlankPoofWindow* _tmp27_;
#line 321 "../lib/DragManager.vala"
				_tmp12_ = self->priv->_DragItem;
#line 321 "../lib/DragManager.vala"
				app_item = PLANK_IS_APPLICATION_DOCK_ITEM (_tmp12_) ? ((PlankApplicationDockItem*) _tmp12_) : NULL;
#line 322 "../lib/DragManager.vala"
				_tmp14_ = app_item;
#line 322 "../lib/DragManager.vala"
				if (_tmp14_ == NULL) {
#line 322 "../lib/DragManager.vala"
					_tmp13_ = TRUE;
#line 1967 "DragManager.c"
				} else {
					gboolean _tmp15_ = FALSE;
					PlankApplicationDockItem* _tmp16_;
#line 322 "../lib/DragManager.vala"
					_tmp16_ = app_item;
#line 322 "../lib/DragManager.vala"
					if (plank_application_dock_item_is_running (_tmp16_)) {
#line 322 "../lib/DragManager.vala"
						_tmp15_ = TRUE;
#line 1977 "DragManager.c"
					} else {
						PlankApplicationDockItem* _tmp17_;
#line 322 "../lib/DragManager.vala"
						_tmp17_ = app_item;
#line 322 "../lib/DragManager.vala"
						_tmp15_ = plank_application_dock_item_has_unity_info (_tmp17_);
#line 1984 "DragManager.c"
					}
#line 322 "../lib/DragManager.vala"
					_tmp13_ = !_tmp15_;
#line 1988 "DragManager.c"
				}
#line 322 "../lib/DragManager.vala"
				if (_tmp13_) {
#line 1992 "DragManager.c"
					PlankDockItem* _tmp18_;
					PlankDockItem* _tmp19_;
					PlankDockContainer* _tmp20_;
					PlankDockContainer* _tmp21_;
					PlankDockItem* _tmp22_;
#line 323 "../lib/DragManager.vala"
					_tmp18_ = self->priv->_DragItem;
#line 323 "../lib/DragManager.vala"
					plank_dock_element_set_IsVisible ((PlankDockElement*) _tmp18_, FALSE);
#line 324 "../lib/DragManager.vala"
					_tmp19_ = self->priv->_DragItem;
#line 324 "../lib/DragManager.vala"
					_tmp20_ = plank_dock_element_get_Container ((PlankDockElement*) _tmp19_);
#line 324 "../lib/DragManager.vala"
					_tmp21_ = _tmp20_;
#line 324 "../lib/DragManager.vala"
					_tmp22_ = self->priv->_DragItem;
#line 324 "../lib/DragManager.vala"
					plank_dock_container_remove (_tmp21_, (PlankDockElement*) _tmp22_);
#line 2012 "DragManager.c"
				}
#line 326 "../lib/DragManager.vala"
				_tmp23_ = self->priv->_DragItem;
#line 326 "../lib/DragManager.vala"
				plank_dock_item_delete (_tmp23_);
#line 329 "../lib/DragManager.vala"
				_tmp24_ = gdk_drag_context_get_device (context);
#line 329 "../lib/DragManager.vala"
				gdk_device_get_position (_tmp24_, NULL, &_tmp25_, &_tmp26_);
#line 329 "../lib/DragManager.vala"
				x = _tmp25_;
#line 329 "../lib/DragManager.vala"
				y = _tmp26_;
#line 330 "../lib/DragManager.vala"
				_tmp27_ = plank_poof_window_get_default ();
#line 330 "../lib/DragManager.vala"
				plank_poof_window_show_at (_tmp27_, x, y);
#line 2030 "DragManager.c"
			}
		} else {
			PlankDockController* _tmp28_;
			PlankDockWindow* _tmp29_;
			PlankDockWindow* _tmp30_;
			PlankDockItem* _tmp31_;
			PlankDockItem* _tmp32_;
#line 332 "../lib/DragManager.vala"
			_tmp28_ = self->priv->_controller;
#line 332 "../lib/DragManager.vala"
			_tmp29_ = plank_dock_controller_get_window (_tmp28_);
#line 332 "../lib/DragManager.vala"
			_tmp30_ = _tmp29_;
#line 332 "../lib/DragManager.vala"
			_tmp31_ = plank_dock_window_get_HoveredItem (_tmp30_);
#line 332 "../lib/DragManager.vala"
			_tmp32_ = _tmp31_;
#line 332 "../lib/DragManager.vala"
			if (_tmp32_ == NULL) {
#line 2050 "DragManager.c"
				gboolean _tmp33_ = FALSE;
				PlankDockController* _tmp34_;
				PlankDockPreferences* _tmp35_;
				PlankDockPreferences* _tmp36_;
				gboolean _tmp37_;
				gboolean _tmp38_;
#line 336 "../lib/DragManager.vala"
				_tmp34_ = self->priv->_controller;
#line 336 "../lib/DragManager.vala"
				_tmp35_ = plank_dock_controller_get_prefs (_tmp34_);
#line 336 "../lib/DragManager.vala"
				_tmp36_ = _tmp35_;
#line 336 "../lib/DragManager.vala"
				_tmp37_ = plank_dock_preferences_get_AutoPinning (_tmp36_);
#line 336 "../lib/DragManager.vala"
				_tmp38_ = _tmp37_;
#line 336 "../lib/DragManager.vala"
				if (_tmp38_) {
#line 2069 "DragManager.c"
					PlankDockItem* _tmp39_;
#line 336 "../lib/DragManager.vala"
					_tmp39_ = self->priv->_DragItem;
#line 336 "../lib/DragManager.vala"
					_tmp33_ = PLANK_IS_TRANSIENT_DOCK_ITEM (_tmp39_);
#line 2075 "DragManager.c"
				} else {
#line 336 "../lib/DragManager.vala"
					_tmp33_ = FALSE;
#line 2079 "DragManager.c"
				}
#line 336 "../lib/DragManager.vala"
				if (_tmp33_) {
#line 2083 "DragManager.c"
					PlankDefaultApplicationDockItemProvider* provider = NULL;
					PlankDockItem* _tmp40_;
					PlankDockContainer* _tmp41_;
					PlankDockContainer* _tmp42_;
					PlankDefaultApplicationDockItemProvider* _tmp43_;
#line 337 "../lib/DragManager.vala"
					_tmp40_ = self->priv->_DragItem;
#line 337 "../lib/DragManager.vala"
					_tmp41_ = plank_dock_element_get_Container ((PlankDockElement*) _tmp40_);
#line 337 "../lib/DragManager.vala"
					_tmp42_ = _tmp41_;
#line 337 "../lib/DragManager.vala"
					provider = PLANK_IS_DEFAULT_APPLICATION_DOCK_ITEM_PROVIDER (_tmp42_) ? ((PlankDefaultApplicationDockItemProvider*) _tmp42_) : NULL;
#line 338 "../lib/DragManager.vala"
					_tmp43_ = provider;
#line 338 "../lib/DragManager.vala"
					if (_tmp43_ != NULL) {
#line 2101 "DragManager.c"
						PlankDefaultApplicationDockItemProvider* _tmp44_;
						PlankDockItem* _tmp45_;
#line 339 "../lib/DragManager.vala"
						_tmp44_ = provider;
#line 339 "../lib/DragManager.vala"
						_tmp45_ = self->priv->_DragItem;
#line 339 "../lib/DragManager.vala"
						plank_default_application_dock_item_provider_pin_item (_tmp44_, _tmp45_);
#line 2110 "DragManager.c"
					}
				}
			} else {
			}
		}
	}
#line 351 "../lib/DragManager.vala"
	plank_drag_manager_set_InternalDragActive (self, FALSE);
#line 352 "../lib/DragManager.vala"
	plank_drag_manager_set_DragItem (self, NULL);
#line 353 "../lib/DragManager.vala"
	_tmp46_ = gdk_drag_context_get_device (context);
#line 353 "../lib/DragManager.vala"
	gdk_device_ungrab (_tmp46_, gtk_get_current_event_time ());
#line 355 "../lib/DragManager.vala"
	_tmp47_ = self->priv->_controller;
#line 355 "../lib/DragManager.vala"
	_tmp48_ = plank_dock_controller_get_window (_tmp47_);
#line 355 "../lib/DragManager.vala"
	_tmp49_ = _tmp48_;
#line 355 "../lib/DragManager.vala"
	g_signal_parse_name ("notify::HoveredItem", G_TYPE_OBJECT, &_tmp50_, &_tmp51_, TRUE);
#line 355 "../lib/DragManager.vala"
	g_signal_handlers_disconnect_matched ((GObject*) _tmp49_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp50_, _tmp51_, NULL, (GCallback) _plank_drag_manager_hovered_item_changed_g_object_notify, self);
#line 357 "../lib/DragManager.vala"
	_tmp52_ = self->priv->_controller;
#line 357 "../lib/DragManager.vala"
	_tmp53_ = plank_dock_controller_get_hover (_tmp52_);
#line 357 "../lib/DragManager.vala"
	_tmp54_ = _tmp53_;
#line 357 "../lib/DragManager.vala"
	gtk_widget_hide ((GtkWidget*) _tmp54_);
#line 360 "../lib/DragManager.vala"
	_tmp55_ = self->priv->_controller;
#line 360 "../lib/DragManager.vala"
	_tmp56_ = plank_dock_controller_get_renderer (_tmp55_);
#line 360 "../lib/DragManager.vala"
	_tmp57_ = _tmp56_;
#line 360 "../lib/DragManager.vala"
	plank_renderer_animated_draw ((PlankRenderer*) _tmp57_);
#line 363 "../lib/DragManager.vala"
	_tmp58_ = hide_manager;
#line 363 "../lib/DragManager.vala"
	plank_hide_manager_update_hovered (_tmp58_);
#line 2155 "DragManager.c"
}

static gboolean
___lambda60_ (PlankDragManager* self)
{
	PlankDockController* _tmp0_;
	PlankHoverWindow* _tmp1_;
	PlankHoverWindow* _tmp2_;
	PlankDockController* _tmp3_;
	PlankDockWindow* _tmp4_;
	PlankDockWindow* _tmp5_;
	PlankDockController* _tmp6_;
	PlankDockRenderer* _tmp7_;
	PlankDockRenderer* _tmp8_;
	PlankDockController* _tmp9_;
	PlankHideManager* _tmp10_;
	PlankHideManager* _tmp11_;
	gboolean result = FALSE;
#line 384 "../lib/DragManager.vala"
	plank_drag_manager_set_ExternalDragActive (self, FALSE);
#line 386 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_controller;
#line 386 "../lib/DragManager.vala"
	_tmp1_ = plank_dock_controller_get_hover (_tmp0_);
#line 386 "../lib/DragManager.vala"
	_tmp2_ = _tmp1_;
#line 386 "../lib/DragManager.vala"
	gtk_widget_hide ((GtkWidget*) _tmp2_);
#line 390 "../lib/DragManager.vala"
	_tmp3_ = self->priv->_controller;
#line 390 "../lib/DragManager.vala"
	_tmp4_ = plank_dock_controller_get_window (_tmp3_);
#line 390 "../lib/DragManager.vala"
	_tmp5_ = _tmp4_;
#line 390 "../lib/DragManager.vala"
	plank_dock_window_update_hovered (_tmp5_, -1, -1);
#line 393 "../lib/DragManager.vala"
	_tmp6_ = self->priv->_controller;
#line 393 "../lib/DragManager.vala"
	_tmp7_ = plank_dock_controller_get_renderer (_tmp6_);
#line 393 "../lib/DragManager.vala"
	_tmp8_ = _tmp7_;
#line 393 "../lib/DragManager.vala"
	plank_renderer_animated_draw ((PlankRenderer*) _tmp8_);
#line 396 "../lib/DragManager.vala"
	_tmp9_ = self->priv->_controller;
#line 396 "../lib/DragManager.vala"
	_tmp10_ = plank_dock_controller_get_hide_manager (_tmp9_);
#line 396 "../lib/DragManager.vala"
	_tmp11_ = _tmp10_;
#line 396 "../lib/DragManager.vala"
	plank_hide_manager_update_hovered (_tmp11_);
#line 398 "../lib/DragManager.vala"
	result = FALSE;
#line 398 "../lib/DragManager.vala"
	return result;
#line 2212 "DragManager.c"
}

static gboolean
____lambda60__gsource_func (gpointer self)
{
	gboolean result;
	result = ___lambda60_ ((PlankDragManager*) self);
#line 383 "../lib/DragManager.vala"
	return result;
#line 2222 "DragManager.c"
}

static void
plank_drag_manager_drag_leave (GtkWidget* w,
                               GdkDragContext* context,
                               guint time_,
                               PlankDragManager* self)
{
	PlankDockController* _tmp0_;
	PlankHideManager* _tmp1_;
	PlankHideManager* _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	PlankDockItem* _tmp10_;
	PlankDockController* _tmp11_;
	PlankHideManager* _tmp12_;
	PlankHideManager* _tmp13_;
	gboolean _tmp14_;
	gboolean _tmp15_;
#line 367 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 367 "../lib/DragManager.vala"
	g_return_if_fail (w != NULL);
#line 367 "../lib/DragManager.vala"
	g_return_if_fail (context != NULL);
#line 369 "../lib/DragManager.vala"
	if (self->priv->drag_hover_timer_id > 0U) {
#line 370 "../lib/DragManager.vala"
		g_source_remove (self->priv->drag_hover_timer_id);
#line 371 "../lib/DragManager.vala"
		self->priv->drag_hover_timer_id = 0U;
#line 2254 "DragManager.c"
	}
#line 374 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_controller;
#line 374 "../lib/DragManager.vala"
	_tmp1_ = plank_dock_controller_get_hide_manager (_tmp0_);
#line 374 "../lib/DragManager.vala"
	_tmp2_ = _tmp1_;
#line 374 "../lib/DragManager.vala"
	plank_hide_manager_update_hovered (_tmp2_);
#line 375 "../lib/DragManager.vala"
	self->priv->drag_known = FALSE;
#line 377 "../lib/DragManager.vala"
	_tmp3_ = plank_drag_manager_get_ExternalDragActive (self);
#line 377 "../lib/DragManager.vala"
	_tmp4_ = _tmp3_;
#line 377 "../lib/DragManager.vala"
	if (_tmp4_) {
#line 2272 "DragManager.c"
		PlankDockController* _tmp5_;
		PlankDockWindow* _tmp6_;
		PlankDockWindow* _tmp7_;
		guint _tmp8_;
		GQuark _tmp9_;
#line 378 "../lib/DragManager.vala"
		_tmp5_ = self->priv->_controller;
#line 378 "../lib/DragManager.vala"
		_tmp6_ = plank_dock_controller_get_window (_tmp5_);
#line 378 "../lib/DragManager.vala"
		_tmp7_ = _tmp6_;
#line 378 "../lib/DragManager.vala"
		g_signal_parse_name ("notify::HoveredItem", G_TYPE_OBJECT, &_tmp8_, &_tmp9_, TRUE);
#line 378 "../lib/DragManager.vala"
		g_signal_handlers_disconnect_matched ((GObject*) _tmp7_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp8_, _tmp9_, NULL, (GCallback) _plank_drag_manager_hovered_item_changed_g_object_notify, self);
#line 383 "../lib/DragManager.vala"
		gdk_threads_add_idle (____lambda60__gsource_func, self);
#line 2290 "DragManager.c"
	}
#line 402 "../lib/DragManager.vala"
	_tmp10_ = self->priv->_DragItem;
#line 402 "../lib/DragManager.vala"
	if (_tmp10_ == NULL) {
#line 403 "../lib/DragManager.vala"
		return;
#line 2298 "DragManager.c"
	}
#line 405 "../lib/DragManager.vala"
	_tmp11_ = self->priv->_controller;
#line 405 "../lib/DragManager.vala"
	_tmp12_ = plank_dock_controller_get_hide_manager (_tmp11_);
#line 405 "../lib/DragManager.vala"
	_tmp13_ = _tmp12_;
#line 405 "../lib/DragManager.vala"
	_tmp14_ = plank_hide_manager_get_Hovered (_tmp13_);
#line 405 "../lib/DragManager.vala"
	_tmp15_ = _tmp14_;
#line 405 "../lib/DragManager.vala"
	if (!_tmp15_) {
#line 2312 "DragManager.c"
		PlankDockController* _tmp16_;
		PlankDockWindow* _tmp17_;
		PlankDockWindow* _tmp18_;
		PlankDockController* _tmp19_;
		PlankDockRenderer* _tmp20_;
		PlankDockRenderer* _tmp21_;
#line 406 "../lib/DragManager.vala"
		_tmp16_ = self->priv->_controller;
#line 406 "../lib/DragManager.vala"
		_tmp17_ = plank_dock_controller_get_window (_tmp16_);
#line 406 "../lib/DragManager.vala"
		_tmp18_ = _tmp17_;
#line 406 "../lib/DragManager.vala"
		plank_dock_window_update_hovered (_tmp18_, -1, -1);
#line 407 "../lib/DragManager.vala"
		_tmp19_ = self->priv->_controller;
#line 407 "../lib/DragManager.vala"
		_tmp20_ = plank_dock_controller_get_renderer (_tmp19_);
#line 407 "../lib/DragManager.vala"
		_tmp21_ = _tmp20_;
#line 407 "../lib/DragManager.vala"
		plank_renderer_animated_draw ((PlankRenderer*) _tmp21_);
#line 2335 "DragManager.c"
	}
}

static gboolean
plank_drag_manager_drag_failed (GtkWidget* w,
                                GdkDragContext* context,
                                GtkDragResult _result_,
                                PlankDragManager* self)
{
	gboolean result = FALSE;
#line 412 "../lib/DragManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 412 "../lib/DragManager.vala"
	g_return_val_if_fail (w != NULL, FALSE);
#line 412 "../lib/DragManager.vala"
	g_return_val_if_fail (context != NULL, FALSE);
#line 414 "../lib/DragManager.vala"
	self->priv->drag_canceled = _result_ == GTK_DRAG_RESULT_USER_CANCELLED;
#line 416 "../lib/DragManager.vala"
	result = !self->priv->drag_canceled;
#line 416 "../lib/DragManager.vala"
	return result;
#line 2358 "DragManager.c"
}

static gboolean
plank_drag_manager_drag_motion (GtkWidget* w,
                                GdkDragContext* context,
                                gint x,
                                gint y,
                                guint time_,
                                PlankDragManager* self)
{
	gboolean _tmp0_;
	gboolean _tmp1_;
	gboolean _tmp2_;
	gboolean _tmp3_;
	gboolean _tmp4_;
	GHashFunc _tmp6_;
	PlankDockWindow* window = NULL;
	PlankDockController* _tmp8_;
	PlankDockWindow* _tmp9_;
	PlankDockWindow* _tmp10_;
	PlankHideManager* hide_manager = NULL;
	PlankDockController* _tmp11_;
	PlankHideManager* _tmp12_;
	PlankHideManager* _tmp13_;
	gboolean _tmp14_ = FALSE;
	gboolean _tmp15_;
	gboolean _tmp16_;
	gboolean _tmp27_;
	gboolean _tmp28_;
	PlankDockController* _tmp72_;
	PlankDockRenderer* _tmp73_;
	PlankDockRenderer* _tmp74_;
	PlankHideManager* _tmp75_;
	PlankDockWindow* _tmp76_;
	gboolean result = FALSE;
#line 420 "../lib/DragManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 420 "../lib/DragManager.vala"
	g_return_val_if_fail (w != NULL, FALSE);
#line 420 "../lib/DragManager.vala"
	g_return_val_if_fail (context != NULL, FALSE);
#line 422 "../lib/DragManager.vala"
	_tmp0_ = plank_drag_manager_get_RepositionMode (self);
#line 422 "../lib/DragManager.vala"
	_tmp1_ = _tmp0_;
#line 422 "../lib/DragManager.vala"
	if (_tmp1_) {
#line 423 "../lib/DragManager.vala"
		result = TRUE;
#line 423 "../lib/DragManager.vala"
		return result;
#line 2410 "DragManager.c"
	}
#line 425 "../lib/DragManager.vala"
	_tmp2_ = plank_drag_manager_get_ExternalDragActive (self);
#line 425 "../lib/DragManager.vala"
	_tmp3_ = _tmp2_;
#line 425 "../lib/DragManager.vala"
	_tmp4_ = self->priv->_InternalDragActive;
#line 425 "../lib/DragManager.vala"
	if (_tmp3_ == _tmp4_) {
#line 2420 "DragManager.c"
		gboolean _tmp5_;
#line 426 "../lib/DragManager.vala"
		_tmp5_ = self->priv->_InternalDragActive;
#line 426 "../lib/DragManager.vala"
		plank_drag_manager_set_ExternalDragActive (self, !_tmp5_);
#line 2426 "DragManager.c"
	}
#line 428 "../lib/DragManager.vala"
	_tmp6_ = g_direct_hash;
#line 428 "../lib/DragManager.vala"
	if (self->priv->marker != _tmp6_ (context)) {
#line 2432 "DragManager.c"
		GHashFunc _tmp7_;
#line 429 "../lib/DragManager.vala"
		_tmp7_ = g_direct_hash;
#line 429 "../lib/DragManager.vala"
		self->priv->marker = _tmp7_ (context);
#line 430 "../lib/DragManager.vala"
		self->priv->drag_known = FALSE;
#line 2440 "DragManager.c"
	}
#line 433 "../lib/DragManager.vala"
	_tmp8_ = self->priv->_controller;
#line 433 "../lib/DragManager.vala"
	_tmp9_ = plank_dock_controller_get_window (_tmp8_);
#line 433 "../lib/DragManager.vala"
	_tmp10_ = _tmp9_;
#line 433 "../lib/DragManager.vala"
	window = _tmp10_;
#line 434 "../lib/DragManager.vala"
	_tmp11_ = self->priv->_controller;
#line 434 "../lib/DragManager.vala"
	_tmp12_ = plank_dock_controller_get_hide_manager (_tmp11_);
#line 434 "../lib/DragManager.vala"
	_tmp13_ = _tmp12_;
#line 434 "../lib/DragManager.vala"
	hide_manager = _tmp13_;
#line 437 "../lib/DragManager.vala"
	_tmp15_ = plank_drag_manager_get_ExternalDragActive (self);
#line 437 "../lib/DragManager.vala"
	_tmp16_ = _tmp15_;
#line 437 "../lib/DragManager.vala"
	if (_tmp16_) {
#line 437 "../lib/DragManager.vala"
		_tmp14_ = !self->priv->drag_known;
#line 2466 "DragManager.c"
	} else {
#line 437 "../lib/DragManager.vala"
		_tmp14_ = FALSE;
#line 2470 "DragManager.c"
	}
#line 437 "../lib/DragManager.vala"
	if (_tmp14_) {
#line 2474 "DragManager.c"
		PlankDockWindow* _tmp17_;
		GdkAtom atom = 0U;
		PlankDockWindow* _tmp18_;
		PlankDockWindow* _tmp19_;
		GtkTargetList* _tmp20_;
		gchar* _tmp21_;
		gchar* _tmp22_;
		gchar* _tmp23_;
		gchar* _tmp24_;
		gboolean _tmp25_;
#line 438 "../lib/DragManager.vala"
		self->priv->drag_known = TRUE;
#line 440 "../lib/DragManager.vala"
		_tmp17_ = window;
#line 440 "../lib/DragManager.vala"
		g_signal_connect_object ((GObject*) _tmp17_, "notify::HoveredItem", (GCallback) _plank_drag_manager_hovered_item_changed_g_object_notify, self, 0);
#line 442 "../lib/DragManager.vala"
		_tmp18_ = window;
#line 442 "../lib/DragManager.vala"
		_tmp19_ = window;
#line 442 "../lib/DragManager.vala"
		_tmp20_ = gtk_drag_dest_get_target_list ((GtkWidget*) _tmp19_);
#line 442 "../lib/DragManager.vala"
		atom = gtk_drag_dest_find_target ((GtkWidget*) _tmp18_, context, _tmp20_);
#line 443 "../lib/DragManager.vala"
		_tmp21_ = gdk_atom_name (atom);
#line 443 "../lib/DragManager.vala"
		_tmp22_ = _tmp21_;
#line 443 "../lib/DragManager.vala"
		_tmp23_ = gdk_atom_name (GDK_NONE);
#line 443 "../lib/DragManager.vala"
		_tmp24_ = _tmp23_;
#line 443 "../lib/DragManager.vala"
		_tmp25_ = g_strcmp0 (_tmp22_, _tmp24_) != 0;
#line 443 "../lib/DragManager.vala"
		_g_free0 (_tmp24_);
#line 443 "../lib/DragManager.vala"
		_g_free0 (_tmp22_);
#line 443 "../lib/DragManager.vala"
		if (_tmp25_) {
#line 2515 "DragManager.c"
			PlankDockWindow* _tmp26_;
#line 444 "../lib/DragManager.vala"
			self->priv->drag_data_requested = TRUE;
#line 445 "../lib/DragManager.vala"
			_tmp26_ = window;
#line 445 "../lib/DragManager.vala"
			gtk_drag_get_data ((GtkWidget*) _tmp26_, context, atom, (guint32) time_);
#line 2523 "DragManager.c"
		} else {
#line 447 "../lib/DragManager.vala"
			gdk_drag_status (context, GDK_ACTION_PRIVATE, (guint32) time_);
#line 2527 "DragManager.c"
		}
	} else {
#line 450 "../lib/DragManager.vala"
		gdk_drag_status (context, GDK_ACTION_COPY, (guint32) time_);
#line 2532 "DragManager.c"
	}
#line 453 "../lib/DragManager.vala"
	_tmp27_ = plank_drag_manager_get_ExternalDragActive (self);
#line 453 "../lib/DragManager.vala"
	_tmp28_ = _tmp27_;
#line 453 "../lib/DragManager.vala"
	if (_tmp28_) {
#line 2540 "DragManager.c"
		PlankPositionManager* position_manager = NULL;
		PlankDockController* _tmp29_;
		PlankPositionManager* _tmp30_;
		PlankPositionManager* _tmp31_;
		PlankDockItem* hovered_item = NULL;
		PlankDockWindow* _tmp32_;
		PlankDockItem* _tmp33_;
		PlankDockItem* _tmp34_;
		PlankHoverWindow* hover = NULL;
		PlankDockController* _tmp35_;
		PlankHoverWindow* _tmp36_;
		PlankHoverWindow* _tmp37_;
		gboolean _tmp38_ = FALSE;
		gboolean _tmp39_ = FALSE;
		gboolean _tmp40_;
#line 454 "../lib/DragManager.vala"
		_tmp29_ = self->priv->_controller;
#line 454 "../lib/DragManager.vala"
		_tmp30_ = plank_dock_controller_get_position_manager (_tmp29_);
#line 454 "../lib/DragManager.vala"
		_tmp31_ = _tmp30_;
#line 454 "../lib/DragManager.vala"
		position_manager = _tmp31_;
#line 455 "../lib/DragManager.vala"
		_tmp32_ = window;
#line 455 "../lib/DragManager.vala"
		_tmp33_ = plank_dock_window_get_HoveredItem (_tmp32_);
#line 455 "../lib/DragManager.vala"
		_tmp34_ = _tmp33_;
#line 455 "../lib/DragManager.vala"
		hovered_item = _tmp34_;
#line 456 "../lib/DragManager.vala"
		_tmp35_ = self->priv->_controller;
#line 456 "../lib/DragManager.vala"
		_tmp36_ = plank_dock_controller_get_hover (_tmp35_);
#line 456 "../lib/DragManager.vala"
		_tmp37_ = _tmp36_;
#line 456 "../lib/DragManager.vala"
		hover = _tmp37_;
#line 457 "../lib/DragManager.vala"
		_tmp40_ = self->priv->_DragNeedsCheck;
#line 457 "../lib/DragManager.vala"
		if (_tmp40_) {
#line 2584 "DragManager.c"
			PlankDockItem* _tmp41_;
#line 457 "../lib/DragManager.vala"
			_tmp41_ = hovered_item;
#line 457 "../lib/DragManager.vala"
			_tmp39_ = _tmp41_ != NULL;
#line 2590 "DragManager.c"
		} else {
#line 457 "../lib/DragManager.vala"
			_tmp39_ = FALSE;
#line 2594 "DragManager.c"
		}
#line 457 "../lib/DragManager.vala"
		if (_tmp39_) {
#line 2598 "DragManager.c"
			PlankDockItem* _tmp42_;
			GeeArrayList* _tmp43_;
#line 457 "../lib/DragManager.vala"
			_tmp42_ = hovered_item;
#line 457 "../lib/DragManager.vala"
			_tmp43_ = self->priv->drag_data;
#line 457 "../lib/DragManager.vala"
			_tmp38_ = plank_dock_element_can_accept_drop ((PlankDockElement*) _tmp42_, _tmp43_);
#line 2607 "DragManager.c"
		} else {
#line 457 "../lib/DragManager.vala"
			_tmp38_ = FALSE;
#line 2611 "DragManager.c"
		}
#line 457 "../lib/DragManager.vala"
		if (_tmp38_) {
#line 2615 "DragManager.c"
			gint hx = 0;
			gint hy = 0;
			PlankPositionManager* _tmp44_;
			PlankDockItem* _tmp45_;
			gint _tmp46_ = 0;
			gint _tmp47_ = 0;
			PlankHoverWindow* _tmp48_;
			PlankDockItem* _tmp49_;
			gchar* _tmp50_;
			gchar* _tmp51_;
			PlankHoverWindow* _tmp52_;
			PlankPositionManager* _tmp53_;
			GtkPositionType _tmp54_;
			GtkPositionType _tmp55_;
#line 459 "../lib/DragManager.vala"
			_tmp44_ = position_manager;
#line 459 "../lib/DragManager.vala"
			_tmp45_ = hovered_item;
#line 459 "../lib/DragManager.vala"
			plank_position_manager_get_hover_position (_tmp44_, _tmp45_, &_tmp46_, &_tmp47_);
#line 459 "../lib/DragManager.vala"
			hx = _tmp46_;
#line 459 "../lib/DragManager.vala"
			hy = _tmp47_;
#line 460 "../lib/DragManager.vala"
			_tmp48_ = hover;
#line 460 "../lib/DragManager.vala"
			_tmp49_ = hovered_item;
#line 460 "../lib/DragManager.vala"
			_tmp50_ = plank_dock_element_get_drop_text ((PlankDockElement*) _tmp49_);
#line 460 "../lib/DragManager.vala"
			_tmp51_ = _tmp50_;
#line 460 "../lib/DragManager.vala"
			plank_hover_window_set_text (_tmp48_, _tmp51_);
#line 460 "../lib/DragManager.vala"
			_g_free0 (_tmp51_);
#line 461 "../lib/DragManager.vala"
			_tmp52_ = hover;
#line 461 "../lib/DragManager.vala"
			_tmp53_ = position_manager;
#line 461 "../lib/DragManager.vala"
			_tmp54_ = plank_position_manager_get_Position (_tmp53_);
#line 461 "../lib/DragManager.vala"
			_tmp55_ = _tmp54_;
#line 461 "../lib/DragManager.vala"
			plank_hover_window_show_at (_tmp52_, hx, hy, _tmp55_);
#line 2662 "DragManager.c"
		} else {
			gboolean _tmp56_ = FALSE;
			PlankHideManager* _tmp57_;
			gboolean _tmp58_;
			gboolean _tmp59_;
#line 462 "../lib/DragManager.vala"
			_tmp57_ = hide_manager;
#line 462 "../lib/DragManager.vala"
			_tmp58_ = plank_hide_manager_get_Hovered (_tmp57_);
#line 462 "../lib/DragManager.vala"
			_tmp59_ = _tmp58_;
#line 462 "../lib/DragManager.vala"
			if (_tmp59_) {
#line 2676 "DragManager.c"
				PlankDockController* _tmp60_;
				PlankDockPreferences* _tmp61_;
				PlankDockPreferences* _tmp62_;
				gboolean _tmp63_;
				gboolean _tmp64_;
#line 462 "../lib/DragManager.vala"
				_tmp60_ = self->priv->_controller;
#line 462 "../lib/DragManager.vala"
				_tmp61_ = plank_dock_controller_get_prefs (_tmp60_);
#line 462 "../lib/DragManager.vala"
				_tmp62_ = _tmp61_;
#line 462 "../lib/DragManager.vala"
				_tmp63_ = plank_dock_preferences_get_LockItems (_tmp62_);
#line 462 "../lib/DragManager.vala"
				_tmp64_ = _tmp63_;
#line 462 "../lib/DragManager.vala"
				_tmp56_ = !_tmp64_;
#line 2694 "DragManager.c"
			} else {
#line 462 "../lib/DragManager.vala"
				_tmp56_ = FALSE;
#line 2698 "DragManager.c"
			}
#line 462 "../lib/DragManager.vala"
			if (_tmp56_) {
#line 2702 "DragManager.c"
				gint hx = 0;
				gint hy = 0;
				PlankPositionManager* _tmp65_;
				PlankHoverWindow* _tmp66_;
				PlankHoverWindow* _tmp67_;
				PlankPositionManager* _tmp68_;
				GtkPositionType _tmp69_;
				GtkPositionType _tmp70_;
#line 463 "../lib/DragManager.vala"
				hx = x;
#line 463 "../lib/DragManager.vala"
				hy = y;
#line 464 "../lib/DragManager.vala"
				_tmp65_ = position_manager;
#line 464 "../lib/DragManager.vala"
				plank_position_manager_get_hover_position_at (_tmp65_, &hx, &hy);
#line 465 "../lib/DragManager.vala"
				_tmp66_ = hover;
#line 465 "../lib/DragManager.vala"
				plank_hover_window_set_text (_tmp66_, _ ("Drop to add to dock"));
#line 466 "../lib/DragManager.vala"
				_tmp67_ = hover;
#line 466 "../lib/DragManager.vala"
				_tmp68_ = position_manager;
#line 466 "../lib/DragManager.vala"
				_tmp69_ = plank_position_manager_get_Position (_tmp68_);
#line 466 "../lib/DragManager.vala"
				_tmp70_ = _tmp69_;
#line 466 "../lib/DragManager.vala"
				plank_hover_window_show_at (_tmp67_, hx, hy, _tmp70_);
#line 2733 "DragManager.c"
			} else {
				PlankHoverWindow* _tmp71_;
#line 468 "../lib/DragManager.vala"
				_tmp71_ = hover;
#line 468 "../lib/DragManager.vala"
				gtk_widget_hide ((GtkWidget*) _tmp71_);
#line 2740 "DragManager.c"
			}
		}
	}
#line 472 "../lib/DragManager.vala"
	_tmp72_ = self->priv->_controller;
#line 472 "../lib/DragManager.vala"
	_tmp73_ = plank_dock_controller_get_renderer (_tmp72_);
#line 472 "../lib/DragManager.vala"
	_tmp74_ = _tmp73_;
#line 472 "../lib/DragManager.vala"
	plank_dock_renderer_update_local_cursor (_tmp74_, x, y);
#line 473 "../lib/DragManager.vala"
	_tmp75_ = hide_manager;
#line 473 "../lib/DragManager.vala"
	plank_hide_manager_update_hovered_with_coords (_tmp75_, x, y);
#line 474 "../lib/DragManager.vala"
	_tmp76_ = window;
#line 474 "../lib/DragManager.vala"
	plank_dock_window_update_hovered (_tmp76_, x, y);
#line 476 "../lib/DragManager.vala"
	result = TRUE;
#line 476 "../lib/DragManager.vala"
	return result;
#line 2764 "DragManager.c"
}

static gboolean
___lambda57_ (PlankDragManager* self)
{
	PlankDockItem* item = NULL;
	PlankDockController* _tmp0_;
	PlankDockWindow* _tmp1_;
	PlankDockWindow* _tmp2_;
	PlankDockItem* _tmp3_;
	PlankDockItem* _tmp4_;
	PlankDockItem* _tmp5_;
	PlankDockItem* _tmp7_;
	gboolean result = FALSE;
#line 496 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_controller;
#line 496 "../lib/DragManager.vala"
	_tmp1_ = plank_dock_controller_get_window (_tmp0_);
#line 496 "../lib/DragManager.vala"
	_tmp2_ = _tmp1_;
#line 496 "../lib/DragManager.vala"
	_tmp3_ = plank_dock_window_get_HoveredItem (_tmp2_);
#line 496 "../lib/DragManager.vala"
	_tmp4_ = _tmp3_;
#line 496 "../lib/DragManager.vala"
	item = _tmp4_;
#line 497 "../lib/DragManager.vala"
	_tmp5_ = item;
#line 497 "../lib/DragManager.vala"
	if (_tmp5_ != NULL) {
#line 2795 "DragManager.c"
		PlankDockItem* _tmp6_;
#line 498 "../lib/DragManager.vala"
		_tmp6_ = item;
#line 498 "../lib/DragManager.vala"
		plank_dock_element_scrolled ((PlankDockElement*) _tmp6_, GDK_SCROLL_DOWN, 0, gtk_get_current_event_time ());
#line 2801 "DragManager.c"
	} else {
#line 500 "../lib/DragManager.vala"
		self->priv->drag_hover_timer_id = 0U;
#line 2805 "DragManager.c"
	}
#line 501 "../lib/DragManager.vala"
	_tmp7_ = item;
#line 501 "../lib/DragManager.vala"
	result = _tmp7_ != NULL;
#line 501 "../lib/DragManager.vala"
	return result;
#line 2813 "DragManager.c"
}

static gboolean
____lambda57__gsource_func (gpointer self)
{
	gboolean result;
	result = ___lambda57_ ((PlankDragManager*) self);
#line 495 "../lib/DragManager.vala"
	return result;
#line 2823 "DragManager.c"
}

static void
plank_drag_manager_hovered_item_changed (PlankDragManager* self)
{
	PlankDockItem* hovered_item = NULL;
	PlankDockController* _tmp0_;
	PlankDockWindow* _tmp1_;
	PlankDockWindow* _tmp2_;
	PlankDockItem* _tmp3_;
	PlankDockItem* _tmp4_;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	gboolean _tmp8_ = FALSE;
	gboolean _tmp9_;
	gboolean _tmp25_ = FALSE;
	gboolean _tmp26_;
	gboolean _tmp27_;
#line 479 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 481 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_controller;
#line 481 "../lib/DragManager.vala"
	_tmp1_ = plank_dock_controller_get_window (_tmp0_);
#line 481 "../lib/DragManager.vala"
	_tmp2_ = _tmp1_;
#line 481 "../lib/DragManager.vala"
	_tmp3_ = plank_dock_window_get_HoveredItem (_tmp2_);
#line 481 "../lib/DragManager.vala"
	_tmp4_ = _tmp3_;
#line 481 "../lib/DragManager.vala"
	hovered_item = _tmp4_;
#line 483 "../lib/DragManager.vala"
	_tmp9_ = self->priv->_InternalDragActive;
#line 483 "../lib/DragManager.vala"
	if (_tmp9_) {
#line 2861 "DragManager.c"
		PlankDockItem* _tmp10_;
#line 483 "../lib/DragManager.vala"
		_tmp10_ = self->priv->_DragItem;
#line 483 "../lib/DragManager.vala"
		_tmp8_ = _tmp10_ != NULL;
#line 2867 "DragManager.c"
	} else {
#line 483 "../lib/DragManager.vala"
		_tmp8_ = FALSE;
#line 2871 "DragManager.c"
	}
#line 483 "../lib/DragManager.vala"
	if (_tmp8_) {
#line 2875 "DragManager.c"
		PlankDockItem* _tmp11_;
#line 483 "../lib/DragManager.vala"
		_tmp11_ = hovered_item;
#line 483 "../lib/DragManager.vala"
		_tmp7_ = _tmp11_ != NULL;
#line 2881 "DragManager.c"
	} else {
#line 483 "../lib/DragManager.vala"
		_tmp7_ = FALSE;
#line 2885 "DragManager.c"
	}
#line 483 "../lib/DragManager.vala"
	if (_tmp7_) {
#line 2889 "DragManager.c"
		PlankDockItem* _tmp12_;
		PlankDockItem* _tmp13_;
#line 484 "../lib/DragManager.vala"
		_tmp12_ = self->priv->_DragItem;
#line 484 "../lib/DragManager.vala"
		_tmp13_ = hovered_item;
#line 484 "../lib/DragManager.vala"
		_tmp6_ = _tmp12_ != _tmp13_;
#line 2898 "DragManager.c"
	} else {
#line 483 "../lib/DragManager.vala"
		_tmp6_ = FALSE;
#line 2902 "DragManager.c"
	}
#line 483 "../lib/DragManager.vala"
	if (_tmp6_) {
#line 2906 "DragManager.c"
		PlankDockItem* _tmp14_;
		PlankDockContainer* _tmp15_;
		PlankDockContainer* _tmp16_;
		PlankDockItem* _tmp17_;
		PlankDockContainer* _tmp18_;
		PlankDockContainer* _tmp19_;
#line 485 "../lib/DragManager.vala"
		_tmp14_ = self->priv->_DragItem;
#line 485 "../lib/DragManager.vala"
		_tmp15_ = plank_dock_element_get_Container ((PlankDockElement*) _tmp14_);
#line 485 "../lib/DragManager.vala"
		_tmp16_ = _tmp15_;
#line 485 "../lib/DragManager.vala"
		_tmp17_ = hovered_item;
#line 485 "../lib/DragManager.vala"
		_tmp18_ = plank_dock_element_get_Container ((PlankDockElement*) _tmp17_);
#line 485 "../lib/DragManager.vala"
		_tmp19_ = _tmp18_;
#line 485 "../lib/DragManager.vala"
		_tmp5_ = _tmp16_ == _tmp19_;
#line 2927 "DragManager.c"
	} else {
#line 483 "../lib/DragManager.vala"
		_tmp5_ = FALSE;
#line 2931 "DragManager.c"
	}
#line 483 "../lib/DragManager.vala"
	if (_tmp5_) {
#line 2935 "DragManager.c"
		PlankDockItem* _tmp20_;
		PlankDockContainer* _tmp21_;
		PlankDockContainer* _tmp22_;
		PlankDockItem* _tmp23_;
		PlankDockItem* _tmp24_;
#line 486 "../lib/DragManager.vala"
		_tmp20_ = self->priv->_DragItem;
#line 486 "../lib/DragManager.vala"
		_tmp21_ = plank_dock_element_get_Container ((PlankDockElement*) _tmp20_);
#line 486 "../lib/DragManager.vala"
		_tmp22_ = _tmp21_;
#line 486 "../lib/DragManager.vala"
		_tmp23_ = self->priv->_DragItem;
#line 486 "../lib/DragManager.vala"
		_tmp24_ = hovered_item;
#line 486 "../lib/DragManager.vala"
		plank_dock_container_move_to (_tmp22_, (PlankDockElement*) _tmp23_, (PlankDockElement*) _tmp24_);
#line 2953 "DragManager.c"
	}
#line 489 "../lib/DragManager.vala"
	if (self->priv->drag_hover_timer_id > 0U) {
#line 490 "../lib/DragManager.vala"
		g_source_remove (self->priv->drag_hover_timer_id);
#line 491 "../lib/DragManager.vala"
		self->priv->drag_hover_timer_id = 0U;
#line 2961 "DragManager.c"
	}
#line 494 "../lib/DragManager.vala"
	_tmp26_ = plank_drag_manager_get_ExternalDragActive (self);
#line 494 "../lib/DragManager.vala"
	_tmp27_ = _tmp26_;
#line 494 "../lib/DragManager.vala"
	if (_tmp27_) {
#line 2969 "DragManager.c"
		GeeArrayList* _tmp28_;
#line 494 "../lib/DragManager.vala"
		_tmp28_ = self->priv->drag_data;
#line 494 "../lib/DragManager.vala"
		_tmp25_ = _tmp28_ != NULL;
#line 2975 "DragManager.c"
	} else {
#line 494 "../lib/DragManager.vala"
		_tmp25_ = FALSE;
#line 2979 "DragManager.c"
	}
#line 494 "../lib/DragManager.vala"
	if (_tmp25_) {
#line 495 "../lib/DragManager.vala"
		self->priv->drag_hover_timer_id = gdk_threads_add_timeout ((guint) 1500, ____lambda57__gsource_func, self);
#line 2985 "DragManager.c"
	}
}

static void
_g_object_unref0_ (gpointer var)
{
#line 521 "../lib/DragManager.vala"
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
#line 2994 "DragManager.c"
}

static inline void
_g_list_free__g_object_unref0_ (GList* self)
{
#line 521 "../lib/DragManager.vala"
	g_list_free_full (self, (GDestroyNotify) _g_object_unref0_);
#line 3002 "DragManager.c"
}

static GdkWindow*
plank_drag_manager_best_proxy_window (PlankDragManager* self)
{
	GList* window_stack = NULL;
	PlankDockController* _tmp0_;
	PlankDockWindow* _tmp1_;
	PlankDockWindow* _tmp2_;
	GdkScreen* _tmp3_;
	GList* _tmp4_;
	GList* _tmp5_;
	GdkWindow* result = NULL;
#line 505 "../lib/DragManager.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 507 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_controller;
#line 507 "../lib/DragManager.vala"
	_tmp1_ = plank_dock_controller_get_window (_tmp0_);
#line 507 "../lib/DragManager.vala"
	_tmp2_ = _tmp1_;
#line 507 "../lib/DragManager.vala"
	_tmp3_ = gtk_window_get_screen ((GtkWindow*) _tmp2_);
#line 507 "../lib/DragManager.vala"
	_tmp4_ = gdk_screen_get_window_stack (_tmp3_);
#line 507 "../lib/DragManager.vala"
	window_stack = _tmp4_;
#line 508 "../lib/DragManager.vala"
	window_stack = g_list_reverse (window_stack);
#line 510 "../lib/DragManager.vala"
	_tmp5_ = window_stack;
#line 3034 "DragManager.c"
	{
		GList* window_collection = NULL;
		GList* window_it = NULL;
#line 510 "../lib/DragManager.vala"
		window_collection = _tmp5_;
#line 510 "../lib/DragManager.vala"
		for (window_it = window_collection; window_it != NULL; window_it = window_it->next) {
#line 3042 "DragManager.c"
			GdkWindow* _tmp6_;
			GdkWindow* window = NULL;
#line 510 "../lib/DragManager.vala"
			_tmp6_ = _g_object_ref0 ((GdkWindow*) window_it->data);
#line 510 "../lib/DragManager.vala"
			window = _tmp6_;
#line 3049 "DragManager.c"
			{
				gint w_x = 0;
				gint w_y = 0;
				gint w_width = 0;
				gint w_height = 0;
				GdkWindow* _tmp7_;
				gint _tmp8_ = 0;
				gint _tmp9_ = 0;
				GdkWindow* _tmp10_;
				GdkWindow* _tmp11_;
				GdkRectangle w_geo = {0};
				GdkRectangle _tmp12_ = {0};
				gint x = 0;
				gint y = 0;
				PlankDockController* _tmp13_;
				PlankDockWindow* _tmp14_;
				PlankDockWindow* _tmp15_;
				GdkDisplay* _tmp16_;
				GdkDeviceManager* _tmp17_;
				GdkDevice* _tmp18_;
				gint _tmp19_ = 0;
				gint _tmp20_ = 0;
				gboolean _tmp21_ = FALSE;
				GdkWindow* _tmp22_;
#line 512 "../lib/DragManager.vala"
				_tmp7_ = window;
#line 512 "../lib/DragManager.vala"
				gdk_window_get_position (_tmp7_, &_tmp8_, &_tmp9_);
#line 512 "../lib/DragManager.vala"
				w_x = _tmp8_;
#line 512 "../lib/DragManager.vala"
				w_y = _tmp9_;
#line 513 "../lib/DragManager.vala"
				_tmp10_ = window;
#line 513 "../lib/DragManager.vala"
				w_width = gdk_window_get_width (_tmp10_);
#line 514 "../lib/DragManager.vala"
				_tmp11_ = window;
#line 514 "../lib/DragManager.vala"
				w_height = gdk_window_get_height (_tmp11_);
#line 515 "../lib/DragManager.vala"
				_tmp12_.x = w_x;
#line 515 "../lib/DragManager.vala"
				_tmp12_.y = w_y;
#line 515 "../lib/DragManager.vala"
				_tmp12_.width = w_width;
#line 515 "../lib/DragManager.vala"
				_tmp12_.height = w_height;
#line 515 "../lib/DragManager.vala"
				w_geo = _tmp12_;
#line 518 "../lib/DragManager.vala"
				_tmp13_ = self->priv->_controller;
#line 518 "../lib/DragManager.vala"
				_tmp14_ = plank_dock_controller_get_window (_tmp13_);
#line 518 "../lib/DragManager.vala"
				_tmp15_ = _tmp14_;
#line 518 "../lib/DragManager.vala"
				_tmp16_ = gtk_widget_get_display ((GtkWidget*) _tmp15_);
#line 518 "../lib/DragManager.vala"
				_tmp17_ = gdk_display_get_device_manager (_tmp16_);
#line 518 "../lib/DragManager.vala"
				_tmp18_ = gdk_device_manager_get_client_pointer (_tmp17_);
#line 518 "../lib/DragManager.vala"
				gdk_device_get_position (_tmp18_, NULL, &_tmp19_, &_tmp20_);
#line 518 "../lib/DragManager.vala"
				x = _tmp19_;
#line 518 "../lib/DragManager.vala"
				y = _tmp20_;
#line 520 "../lib/DragManager.vala"
				_tmp22_ = window;
#line 520 "../lib/DragManager.vala"
				if (gdk_window_is_visible (_tmp22_)) {
#line 3122 "DragManager.c"
					GdkRectangle _tmp23_ = {0};
#line 520 "../lib/DragManager.vala"
					_tmp23_.x = x;
#line 520 "../lib/DragManager.vala"
					_tmp23_.y = y;
#line 520 "../lib/DragManager.vala"
					_tmp23_.width = 0;
#line 520 "../lib/DragManager.vala"
					_tmp23_.height = 0;
#line 520 "../lib/DragManager.vala"
					_tmp21_ = gdk_rectangle_intersect (&w_geo, &_tmp23_, NULL);
#line 3134 "DragManager.c"
				} else {
#line 520 "../lib/DragManager.vala"
					_tmp21_ = FALSE;
#line 3138 "DragManager.c"
				}
#line 520 "../lib/DragManager.vala"
				if (_tmp21_) {
#line 521 "../lib/DragManager.vala"
					result = window;
#line 521 "../lib/DragManager.vala"
					(window_stack == NULL) ? NULL : (window_stack = (_g_list_free__g_object_unref0_ (window_stack), NULL));
#line 521 "../lib/DragManager.vala"
					return result;
#line 3148 "DragManager.c"
				}
#line 510 "../lib/DragManager.vala"
				_g_object_unref0 (window);
#line 3152 "DragManager.c"
			}
		}
	}
#line 524 "../lib/DragManager.vala"
	result = NULL;
#line 524 "../lib/DragManager.vala"
	(window_stack == NULL) ? NULL : (window_stack = (_g_list_free__g_object_unref0_ (window_stack), NULL));
#line 524 "../lib/DragManager.vala"
	return result;
#line 3162 "DragManager.c"
}

void
plank_drag_manager_ensure_proxy (PlankDragManager* self)
{
	gboolean _tmp0_;
	PlankDockController* _tmp1_;
	PlankHideManager* _tmp2_;
	PlankHideManager* _tmp3_;
	gboolean _tmp4_;
	gboolean _tmp5_;
	GdkModifierType mod = 0U;
	gdouble* axes = NULL;
	gdouble* _tmp10_;
	gint axes_length1;
	gint _axes_size_;
	PlankDockController* _tmp11_;
	PlankDockWindow* _tmp12_;
	PlankDockWindow* _tmp13_;
	GdkDisplay* _tmp14_;
	GdkDeviceManager* _tmp15_;
	GdkDevice* _tmp16_;
	PlankDockController* _tmp17_;
	PlankDockWindow* _tmp18_;
	PlankDockWindow* _tmp19_;
	GdkWindow* _tmp20_;
	gdouble* _tmp21_;
	gint _tmp21__length1;
	GdkModifierType _tmp22_ = 0U;
	GdkModifierType _tmp23_;
#line 527 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 530 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_InternalDragActive;
#line 530 "../lib/DragManager.vala"
	if (_tmp0_) {
#line 531 "../lib/DragManager.vala"
		return;
#line 3201 "DragManager.c"
	}
#line 533 "../lib/DragManager.vala"
	_tmp1_ = self->priv->_controller;
#line 533 "../lib/DragManager.vala"
	_tmp2_ = plank_dock_controller_get_hide_manager (_tmp1_);
#line 533 "../lib/DragManager.vala"
	_tmp3_ = _tmp2_;
#line 533 "../lib/DragManager.vala"
	_tmp4_ = plank_hide_manager_get_Hovered (_tmp3_);
#line 533 "../lib/DragManager.vala"
	_tmp5_ = _tmp4_;
#line 533 "../lib/DragManager.vala"
	if (_tmp5_) {
#line 3215 "DragManager.c"
		GdkWindow* _tmp6_;
		PlankDockController* _tmp7_;
		PlankDockWindow* _tmp8_;
		PlankDockWindow* _tmp9_;
#line 534 "../lib/DragManager.vala"
		_tmp6_ = self->priv->proxy_window;
#line 534 "../lib/DragManager.vala"
		if (_tmp6_ == NULL) {
#line 535 "../lib/DragManager.vala"
			return;
#line 3226 "DragManager.c"
		}
#line 536 "../lib/DragManager.vala"
		_g_object_unref0 (self->priv->proxy_window);
#line 536 "../lib/DragManager.vala"
		self->priv->proxy_window = NULL;
#line 537 "../lib/DragManager.vala"
		_tmp7_ = self->priv->_controller;
#line 537 "../lib/DragManager.vala"
		_tmp8_ = plank_dock_controller_get_window (_tmp7_);
#line 537 "../lib/DragManager.vala"
		_tmp9_ = _tmp8_;
#line 537 "../lib/DragManager.vala"
		plank_drag_manager_enable_drag_to (self, _tmp9_);
#line 538 "../lib/DragManager.vala"
		return;
#line 3242 "DragManager.c"
	}
#line 542 "../lib/DragManager.vala"
	_tmp10_ = g_new0 (gdouble, 0);
#line 542 "../lib/DragManager.vala"
	axes = _tmp10_;
#line 542 "../lib/DragManager.vala"
	axes_length1 = 0;
#line 542 "../lib/DragManager.vala"
	_axes_size_ = axes_length1;
#line 543 "../lib/DragManager.vala"
	_tmp11_ = self->priv->_controller;
#line 543 "../lib/DragManager.vala"
	_tmp12_ = plank_dock_controller_get_window (_tmp11_);
#line 543 "../lib/DragManager.vala"
	_tmp13_ = _tmp12_;
#line 543 "../lib/DragManager.vala"
	_tmp14_ = gtk_widget_get_display ((GtkWidget*) _tmp13_);
#line 543 "../lib/DragManager.vala"
	_tmp15_ = gdk_display_get_device_manager (_tmp14_);
#line 543 "../lib/DragManager.vala"
	_tmp16_ = gdk_device_manager_get_client_pointer (_tmp15_);
#line 543 "../lib/DragManager.vala"
	_tmp17_ = self->priv->_controller;
#line 543 "../lib/DragManager.vala"
	_tmp18_ = plank_dock_controller_get_window (_tmp17_);
#line 543 "../lib/DragManager.vala"
	_tmp19_ = _tmp18_;
#line 543 "../lib/DragManager.vala"
	_tmp20_ = gtk_widget_get_window ((GtkWidget*) _tmp19_);
#line 543 "../lib/DragManager.vala"
	_tmp21_ = axes;
#line 543 "../lib/DragManager.vala"
	_tmp21__length1 = axes_length1;
#line 543 "../lib/DragManager.vala"
	gdk_device_get_state (_tmp16_, _tmp20_, _tmp21_, &_tmp22_);
#line 543 "../lib/DragManager.vala"
	mod = _tmp22_;
#line 545 "../lib/DragManager.vala"
	_tmp23_ = mod;
#line 545 "../lib/DragManager.vala"
	if ((_tmp23_ & GDK_BUTTON1_MASK) == GDK_BUTTON1_MASK) {
#line 3284 "DragManager.c"
		GdkWindow* bestProxy = NULL;
		GdkWindow* _tmp24_;
		gboolean _tmp25_ = FALSE;
		GdkWindow* _tmp26_;
#line 546 "../lib/DragManager.vala"
		_tmp24_ = plank_drag_manager_best_proxy_window (self);
#line 546 "../lib/DragManager.vala"
		bestProxy = _tmp24_;
#line 547 "../lib/DragManager.vala"
		_tmp26_ = bestProxy;
#line 547 "../lib/DragManager.vala"
		if (_tmp26_ != NULL) {
#line 3297 "DragManager.c"
			GdkWindow* _tmp27_;
			GdkWindow* _tmp28_;
#line 547 "../lib/DragManager.vala"
			_tmp27_ = self->priv->proxy_window;
#line 547 "../lib/DragManager.vala"
			_tmp28_ = bestProxy;
#line 547 "../lib/DragManager.vala"
			_tmp25_ = _tmp27_ != _tmp28_;
#line 3306 "DragManager.c"
		} else {
#line 547 "../lib/DragManager.vala"
			_tmp25_ = FALSE;
#line 3310 "DragManager.c"
		}
#line 547 "../lib/DragManager.vala"
		if (_tmp25_) {
#line 3314 "DragManager.c"
			GdkWindow* _tmp29_;
			GdkWindow* _tmp30_;
			PlankDockController* _tmp31_;
			PlankDockWindow* _tmp32_;
			PlankDockWindow* _tmp33_;
			GdkWindow* _tmp34_;
#line 548 "../lib/DragManager.vala"
			_tmp29_ = bestProxy;
#line 548 "../lib/DragManager.vala"
			_tmp30_ = _g_object_ref0 (_tmp29_);
#line 548 "../lib/DragManager.vala"
			_g_object_unref0 (self->priv->proxy_window);
#line 548 "../lib/DragManager.vala"
			self->priv->proxy_window = _tmp30_;
#line 549 "../lib/DragManager.vala"
			_tmp31_ = self->priv->_controller;
#line 549 "../lib/DragManager.vala"
			_tmp32_ = plank_dock_controller_get_window (_tmp31_);
#line 549 "../lib/DragManager.vala"
			_tmp33_ = _tmp32_;
#line 549 "../lib/DragManager.vala"
			_tmp34_ = self->priv->proxy_window;
#line 549 "../lib/DragManager.vala"
			gtk_drag_dest_set_proxy ((GtkWidget*) _tmp33_, _tmp34_, GDK_DRAG_PROTO_XDND, TRUE);
#line 3339 "DragManager.c"
		}
#line 545 "../lib/DragManager.vala"
		_g_object_unref0 (bestProxy);
#line 3343 "DragManager.c"
	}
#line 527 "../lib/DragManager.vala"
	axes = (g_free (axes), NULL);
#line 3347 "DragManager.c"
}

static void
plank_drag_manager_enable_drag_to (PlankDragManager* self,
                                   PlankDockWindow* window)
{
	GtkTargetEntry te1 = {0};
	GtkTargetEntry _tmp0_ = {0};
	GtkTargetEntry te2 = {0};
	GtkTargetEntry _tmp1_ = {0};
	GtkTargetEntry _tmp2_;
	GtkTargetEntry _tmp3_;
	GtkTargetEntry* _tmp4_;
	GtkTargetEntry* _tmp5_;
	gint _tmp5__length1;
#line 554 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 554 "../lib/DragManager.vala"
	g_return_if_fail (window != NULL);
#line 556 "../lib/DragManager.vala"
	_tmp0_.target = "text/uri-list";
#line 556 "../lib/DragManager.vala"
	_tmp0_.flags = (guint) 0;
#line 556 "../lib/DragManager.vala"
	_tmp0_.info = (guint) 0;
#line 556 "../lib/DragManager.vala"
	te1 = _tmp0_;
#line 557 "../lib/DragManager.vala"
	_tmp1_.target = "text/plank-uri-list";
#line 557 "../lib/DragManager.vala"
	_tmp1_.flags = (guint) 0;
#line 557 "../lib/DragManager.vala"
	_tmp1_.info = (guint) 0;
#line 557 "../lib/DragManager.vala"
	te2 = _tmp1_;
#line 558 "../lib/DragManager.vala"
	_tmp2_ = te1;
#line 558 "../lib/DragManager.vala"
	_tmp3_ = te2;
#line 558 "../lib/DragManager.vala"
	_tmp4_ = g_new0 (GtkTargetEntry, 2);
#line 558 "../lib/DragManager.vala"
	_tmp4_[0] = _tmp2_;
#line 558 "../lib/DragManager.vala"
	_tmp4_[1] = _tmp3_;
#line 558 "../lib/DragManager.vala"
	_tmp5_ = _tmp4_;
#line 558 "../lib/DragManager.vala"
	_tmp5__length1 = 2;
#line 558 "../lib/DragManager.vala"
	gtk_drag_dest_set ((GtkWidget*) window, 0, _tmp5_, (gint) 2, GDK_ACTION_COPY);
#line 558 "../lib/DragManager.vala"
	_tmp5_ = (g_free (_tmp5_), NULL);
#line 3401 "DragManager.c"
}

static void
plank_drag_manager_disable_drag_to (PlankDragManager* self,
                                    PlankDockWindow* window)
{
#line 561 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 561 "../lib/DragManager.vala"
	g_return_if_fail (window != NULL);
#line 563 "../lib/DragManager.vala"
	gtk_drag_dest_unset ((GtkWidget*) window);
#line 3414 "DragManager.c"
}

static void
plank_drag_manager_enable_drag_from (PlankDragManager* self,
                                     PlankDockWindow* window)
{
	GtkTargetEntry te = {0};
	GtkTargetEntry _tmp0_ = {0};
	GtkTargetEntry _tmp1_;
	GtkTargetEntry* _tmp2_;
	GtkTargetEntry* _tmp3_;
	gint _tmp3__length1;
#line 566 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 566 "../lib/DragManager.vala"
	g_return_if_fail (window != NULL);
#line 569 "../lib/DragManager.vala"
	_tmp0_.target = "text/plank-uri-list";
#line 569 "../lib/DragManager.vala"
	_tmp0_.flags = (guint) GTK_TARGET_SAME_APP;
#line 569 "../lib/DragManager.vala"
	_tmp0_.info = (guint) 0;
#line 569 "../lib/DragManager.vala"
	te = _tmp0_;
#line 570 "../lib/DragManager.vala"
	_tmp1_ = te;
#line 570 "../lib/DragManager.vala"
	_tmp2_ = g_new0 (GtkTargetEntry, 1);
#line 570 "../lib/DragManager.vala"
	_tmp2_[0] = _tmp1_;
#line 570 "../lib/DragManager.vala"
	_tmp3_ = _tmp2_;
#line 570 "../lib/DragManager.vala"
	_tmp3__length1 = 1;
#line 570 "../lib/DragManager.vala"
	gtk_drag_source_set ((GtkWidget*) window, GDK_BUTTON1_MASK, _tmp3_, (gint) 1, GDK_ACTION_PRIVATE);
#line 570 "../lib/DragManager.vala"
	_tmp3_ = (g_free (_tmp3_), NULL);
#line 3453 "DragManager.c"
}

static void
plank_drag_manager_disable_drag_from (PlankDragManager* self,
                                      PlankDockWindow* window)
{
#line 573 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 573 "../lib/DragManager.vala"
	g_return_if_fail (window != NULL);
#line 575 "../lib/DragManager.vala"
	gtk_drag_source_unset ((GtkWidget*) window);
#line 3466 "DragManager.c"
}

static PlankDockController*
plank_drag_manager_get_controller (PlankDragManager* self)
{
	PlankDockController* result;
	PlankDockController* _tmp0_;
#line 27 "../lib/DragManager.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 27 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_controller;
#line 27 "../lib/DragManager.vala"
	result = _tmp0_;
#line 27 "../lib/DragManager.vala"
	return result;
#line 3482 "DragManager.c"
}

static void
plank_drag_manager_set_controller (PlankDragManager* self,
                                   PlankDockController* value)
{
	PlankDockController* old_value;
#line 27 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 27 "../lib/DragManager.vala"
	old_value = plank_drag_manager_get_controller (self);
#line 27 "../lib/DragManager.vala"
	if (old_value != value) {
#line 3496 "DragManager.c"
		PlankDockController* _tmp0_;
#line 27 "../lib/DragManager.vala"
		_tmp0_ = _g_object_ref0 (value);
#line 27 "../lib/DragManager.vala"
		_g_object_unref0 (self->priv->_controller);
#line 27 "../lib/DragManager.vala"
		self->priv->_controller = _tmp0_;
#line 27 "../lib/DragManager.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_drag_manager_properties[PLANK_DRAG_MANAGER_CONTROLLER_PROPERTY]);
#line 3506 "DragManager.c"
	}
}

gboolean
plank_drag_manager_get_InternalDragActive (PlankDragManager* self)
{
	gboolean result;
#line 29 "../lib/DragManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 29 "../lib/DragManager.vala"
	result = self->priv->_InternalDragActive;
#line 29 "../lib/DragManager.vala"
	return result;
#line 3520 "DragManager.c"
}

static void
plank_drag_manager_set_InternalDragActive (PlankDragManager* self,
                                           gboolean value)
{
	gboolean old_value;
#line 29 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 29 "../lib/DragManager.vala"
	old_value = plank_drag_manager_get_InternalDragActive (self);
#line 29 "../lib/DragManager.vala"
	if (old_value != value) {
#line 29 "../lib/DragManager.vala"
		self->priv->_InternalDragActive = value;
#line 29 "../lib/DragManager.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_drag_manager_properties[PLANK_DRAG_MANAGER_INTERNAL_DRAG_ACTIVE_PROPERTY]);
#line 3538 "DragManager.c"
	}
}

PlankDockItem*
plank_drag_manager_get_DragItem (PlankDragManager* self)
{
	PlankDockItem* result;
	PlankDockItem* _tmp0_;
#line 31 "../lib/DragManager.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 31 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_DragItem;
#line 31 "../lib/DragManager.vala"
	result = _tmp0_;
#line 31 "../lib/DragManager.vala"
	return result;
#line 3555 "DragManager.c"
}

static void
plank_drag_manager_set_DragItem (PlankDragManager* self,
                                 PlankDockItem* value)
{
	PlankDockItem* old_value;
#line 31 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 31 "../lib/DragManager.vala"
	old_value = plank_drag_manager_get_DragItem (self);
#line 31 "../lib/DragManager.vala"
	if (old_value != value) {
#line 3569 "DragManager.c"
		PlankDockItem* _tmp0_;
#line 31 "../lib/DragManager.vala"
		_tmp0_ = _g_object_ref0 (value);
#line 31 "../lib/DragManager.vala"
		_g_object_unref0 (self->priv->_DragItem);
#line 31 "../lib/DragManager.vala"
		self->priv->_DragItem = _tmp0_;
#line 31 "../lib/DragManager.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_drag_manager_properties[PLANK_DRAG_MANAGER_DRAG_ITEM_PROPERTY]);
#line 3579 "DragManager.c"
	}
}

gboolean
plank_drag_manager_get_DragNeedsCheck (PlankDragManager* self)
{
	gboolean result;
#line 33 "../lib/DragManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 33 "../lib/DragManager.vala"
	result = self->priv->_DragNeedsCheck;
#line 33 "../lib/DragManager.vala"
	return result;
#line 3593 "DragManager.c"
}

static void
plank_drag_manager_set_DragNeedsCheck (PlankDragManager* self,
                                       gboolean value)
{
	gboolean old_value;
#line 33 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 33 "../lib/DragManager.vala"
	old_value = plank_drag_manager_get_DragNeedsCheck (self);
#line 33 "../lib/DragManager.vala"
	if (old_value != value) {
#line 33 "../lib/DragManager.vala"
		self->priv->_DragNeedsCheck = value;
#line 33 "../lib/DragManager.vala"
		g_object_notify_by_pspec ((GObject *) self, plank_drag_manager_properties[PLANK_DRAG_MANAGER_DRAG_NEEDS_CHECK_PROPERTY]);
#line 3611 "DragManager.c"
	}
}

gboolean
plank_drag_manager_get_ExternalDragActive (PlankDragManager* self)
{
	gboolean result;
#line 37 "../lib/DragManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 37 "../lib/DragManager.vala"
	result = self->priv->external_drag_active;
#line 37 "../lib/DragManager.vala"
	return result;
#line 3625 "DragManager.c"
}

static void
plank_drag_manager_set_ExternalDragActive (PlankDragManager* self,
                                           gboolean value)
{
#line 38 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 39 "../lib/DragManager.vala"
	if (self->priv->external_drag_active == value) {
#line 40 "../lib/DragManager.vala"
		return;
#line 3638 "DragManager.c"
	}
#line 41 "../lib/DragManager.vala"
	self->priv->external_drag_active = value;
#line 43 "../lib/DragManager.vala"
	if (!value) {
#line 44 "../lib/DragManager.vala"
		self->priv->drag_known = FALSE;
#line 45 "../lib/DragManager.vala"
		_g_object_unref0 (self->priv->drag_data);
#line 45 "../lib/DragManager.vala"
		self->priv->drag_data = NULL;
#line 46 "../lib/DragManager.vala"
		self->priv->drag_data_requested = FALSE;
#line 47 "../lib/DragManager.vala"
		plank_drag_manager_set_DragNeedsCheck (self, TRUE);
#line 3654 "DragManager.c"
	}
#line 38 "../lib/DragManager.vala"
	g_object_notify_by_pspec ((GObject *) self, plank_drag_manager_properties[PLANK_DRAG_MANAGER_EXTERNAL_DRAG_ACTIVE_PROPERTY]);
#line 3658 "DragManager.c"
}

gboolean
plank_drag_manager_get_RepositionMode (PlankDragManager* self)
{
	gboolean result;
#line 54 "../lib/DragManager.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 54 "../lib/DragManager.vala"
	result = self->priv->reposition_mode;
#line 54 "../lib/DragManager.vala"
	return result;
#line 3671 "DragManager.c"
}

static void
plank_drag_manager_set_RepositionMode (PlankDragManager* self,
                                       gboolean value)
{
#line 55 "../lib/DragManager.vala"
	g_return_if_fail (self != NULL);
#line 56 "../lib/DragManager.vala"
	if (self->priv->reposition_mode == value) {
#line 57 "../lib/DragManager.vala"
		return;
#line 3684 "DragManager.c"
	}
#line 58 "../lib/DragManager.vala"
	self->priv->reposition_mode = value;
#line 60 "../lib/DragManager.vala"
	if (self->priv->reposition_mode) {
#line 3690 "DragManager.c"
		PlankDockController* _tmp0_;
		PlankDockWindow* _tmp1_;
		PlankDockWindow* _tmp2_;
#line 61 "../lib/DragManager.vala"
		_tmp0_ = self->priv->_controller;
#line 61 "../lib/DragManager.vala"
		_tmp1_ = plank_dock_controller_get_window (_tmp0_);
#line 61 "../lib/DragManager.vala"
		_tmp2_ = _tmp1_;
#line 61 "../lib/DragManager.vala"
		plank_drag_manager_disable_drag_to (self, _tmp2_);
#line 3702 "DragManager.c"
	} else {
		PlankDockController* _tmp3_;
		PlankDockWindow* _tmp4_;
		PlankDockWindow* _tmp5_;
#line 63 "../lib/DragManager.vala"
		_tmp3_ = self->priv->_controller;
#line 63 "../lib/DragManager.vala"
		_tmp4_ = plank_dock_controller_get_window (_tmp3_);
#line 63 "../lib/DragManager.vala"
		_tmp5_ = _tmp4_;
#line 63 "../lib/DragManager.vala"
		plank_drag_manager_enable_drag_to (self, _tmp5_);
#line 3715 "DragManager.c"
	}
#line 55 "../lib/DragManager.vala"
	g_object_notify_by_pspec ((GObject *) self, plank_drag_manager_properties[PLANK_DRAG_MANAGER_REPOSITION_MODE_PROPERTY]);
#line 3719 "DragManager.c"
}

static void
plank_drag_manager_class_init (PlankDragManagerClass * klass,
                               gpointer klass_data)
{
#line 25 "../lib/DragManager.vala"
	plank_drag_manager_parent_class = g_type_class_peek_parent (klass);
#line 25 "../lib/DragManager.vala"
	g_type_class_adjust_private_offset (klass, &PlankDragManager_private_offset);
#line 25 "../lib/DragManager.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_plank_drag_manager_get_property;
#line 25 "../lib/DragManager.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_plank_drag_manager_set_property;
#line 25 "../lib/DragManager.vala"
	G_OBJECT_CLASS (klass)->finalize = plank_drag_manager_finalize;
#line 25 "../lib/DragManager.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DRAG_MANAGER_CONTROLLER_PROPERTY, plank_drag_manager_properties[PLANK_DRAG_MANAGER_CONTROLLER_PROPERTY] = g_param_spec_object ("controller", "controller", "controller", PLANK_TYPE_DOCK_CONTROLLER, G_PARAM_STATIC_STRINGS | G_PARAM_WRITABLE | G_PARAM_CONSTRUCT_ONLY));
#line 25 "../lib/DragManager.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DRAG_MANAGER_INTERNAL_DRAG_ACTIVE_PROPERTY, plank_drag_manager_properties[PLANK_DRAG_MANAGER_INTERNAL_DRAG_ACTIVE_PROPERTY] = g_param_spec_boolean ("InternalDragActive", "InternalDragActive", "InternalDragActive", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
#line 25 "../lib/DragManager.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DRAG_MANAGER_DRAG_ITEM_PROPERTY, plank_drag_manager_properties[PLANK_DRAG_MANAGER_DRAG_ITEM_PROPERTY] = g_param_spec_object ("DragItem", "DragItem", "DragItem", PLANK_TYPE_DOCK_ITEM, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
#line 25 "../lib/DragManager.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DRAG_MANAGER_DRAG_NEEDS_CHECK_PROPERTY, plank_drag_manager_properties[PLANK_DRAG_MANAGER_DRAG_NEEDS_CHECK_PROPERTY] = g_param_spec_boolean ("DragNeedsCheck", "DragNeedsCheck", "DragNeedsCheck", TRUE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
#line 25 "../lib/DragManager.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DRAG_MANAGER_EXTERNAL_DRAG_ACTIVE_PROPERTY, plank_drag_manager_properties[PLANK_DRAG_MANAGER_EXTERNAL_DRAG_ACTIVE_PROPERTY] = g_param_spec_boolean ("ExternalDragActive", "ExternalDragActive", "ExternalDragActive", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
#line 25 "../lib/DragManager.vala"
	g_object_class_install_property (G_OBJECT_CLASS (klass), PLANK_DRAG_MANAGER_REPOSITION_MODE_PROPERTY, plank_drag_manager_properties[PLANK_DRAG_MANAGER_REPOSITION_MODE_PROPERTY] = g_param_spec_boolean ("RepositionMode", "RepositionMode", "RepositionMode", FALSE, G_PARAM_STATIC_STRINGS | G_PARAM_READABLE));
#line 3748 "DragManager.c"
}

static void
plank_drag_manager_instance_init (PlankDragManager * self,
                                  gpointer klass)
{
#line 25 "../lib/DragManager.vala"
	self->priv = plank_drag_manager_get_instance_private (self);
#line 29 "../lib/DragManager.vala"
	self->priv->_InternalDragActive = FALSE;
#line 31 "../lib/DragManager.vala"
	self->priv->_DragItem = NULL;
#line 33 "../lib/DragManager.vala"
	self->priv->_DragNeedsCheck = TRUE;
#line 35 "../lib/DragManager.vala"
	self->priv->external_drag_active = FALSE;
#line 52 "../lib/DragManager.vala"
	self->priv->reposition_mode = FALSE;
#line 67 "../lib/DragManager.vala"
	self->priv->proxy_window = NULL;
#line 69 "../lib/DragManager.vala"
	self->priv->drag_canceled = FALSE;
#line 70 "../lib/DragManager.vala"
	self->priv->drag_known = FALSE;
#line 71 "../lib/DragManager.vala"
	self->priv->drag_data_requested = FALSE;
#line 72 "../lib/DragManager.vala"
	self->priv->marker = 0U;
#line 73 "../lib/DragManager.vala"
	self->priv->drag_hover_timer_id = 0U;
#line 75 "../lib/DragManager.vala"
	self->priv->drag_data = NULL;
#line 77 "../lib/DragManager.vala"
	self->priv->window_scale_factor = 1;
#line 78 "../lib/DragManager.vala"
	self->priv->drag_item_redraw_handler_id = 0UL;
#line 3785 "DragManager.c"
}

static void
plank_drag_manager_finalize (GObject * obj)
{
	PlankDragManager * self;
	PlankDockWindow* window = NULL;
	PlankDockController* _tmp0_;
	PlankDockWindow* _tmp1_;
	PlankDockWindow* _tmp2_;
	PlankDockWindow* _tmp3_;
	guint _tmp4_;
	PlankDockWindow* _tmp5_;
	guint _tmp6_;
	PlankDockWindow* _tmp7_;
	guint _tmp8_;
	PlankDockWindow* _tmp9_;
	guint _tmp10_;
	PlankDockWindow* _tmp11_;
	guint _tmp12_;
	PlankDockWindow* _tmp13_;
	guint _tmp14_;
	PlankDockWindow* _tmp15_;
	guint _tmp16_;
	PlankDockWindow* _tmp17_;
	guint _tmp18_;
	PlankDockController* _tmp19_;
	PlankDockPreferences* _tmp20_;
	PlankDockPreferences* _tmp21_;
	guint _tmp22_;
	GQuark _tmp23_;
	PlankDockWindow* _tmp24_;
	PlankDockWindow* _tmp25_;
#line 25 "../lib/DragManager.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_DRAG_MANAGER, PlankDragManager);
#line 118 "../lib/DragManager.vala"
	_tmp0_ = self->priv->_controller;
#line 118 "../lib/DragManager.vala"
	_tmp1_ = plank_dock_controller_get_window (_tmp0_);
#line 118 "../lib/DragManager.vala"
	_tmp2_ = _tmp1_;
#line 118 "../lib/DragManager.vala"
	window = _tmp2_;
#line 120 "../lib/DragManager.vala"
	_tmp3_ = window;
#line 120 "../lib/DragManager.vala"
	g_signal_parse_name ("drag-motion", gtk_widget_get_type (), &_tmp4_, NULL, FALSE);
#line 120 "../lib/DragManager.vala"
	g_signal_handlers_disconnect_matched ((GtkWidget*) _tmp3_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp4_, 0, NULL, (GCallback) _plank_drag_manager_drag_motion_gtk_widget_drag_motion, self);
#line 121 "../lib/DragManager.vala"
	_tmp5_ = window;
#line 121 "../lib/DragManager.vala"
	g_signal_parse_name ("drag-begin", gtk_widget_get_type (), &_tmp6_, NULL, FALSE);
#line 121 "../lib/DragManager.vala"
	g_signal_handlers_disconnect_matched ((GtkWidget*) _tmp5_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp6_, 0, NULL, (GCallback) _plank_drag_manager_drag_begin_gtk_widget_drag_begin, self);
#line 122 "../lib/DragManager.vala"
	_tmp7_ = window;
#line 122 "../lib/DragManager.vala"
	g_signal_parse_name ("drag-data-received", gtk_widget_get_type (), &_tmp8_, NULL, FALSE);
#line 122 "../lib/DragManager.vala"
	g_signal_handlers_disconnect_matched ((GtkWidget*) _tmp7_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp8_, 0, NULL, (GCallback) _plank_drag_manager_drag_data_received_gtk_widget_drag_data_received, self);
#line 123 "../lib/DragManager.vala"
	_tmp9_ = window;
#line 123 "../lib/DragManager.vala"
	g_signal_parse_name ("drag-data-get", gtk_widget_get_type (), &_tmp10_, NULL, FALSE);
#line 123 "../lib/DragManager.vala"
	g_signal_handlers_disconnect_matched ((GtkWidget*) _tmp9_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp10_, 0, NULL, (GCallback) _plank_drag_manager_drag_data_get_gtk_widget_drag_data_get, self);
#line 124 "../lib/DragManager.vala"
	_tmp11_ = window;
#line 124 "../lib/DragManager.vala"
	g_signal_parse_name ("drag-drop", gtk_widget_get_type (), &_tmp12_, NULL, FALSE);
#line 124 "../lib/DragManager.vala"
	g_signal_handlers_disconnect_matched ((GtkWidget*) _tmp11_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp12_, 0, NULL, (GCallback) _plank_drag_manager_drag_drop_gtk_widget_drag_drop, self);
#line 125 "../lib/DragManager.vala"
	_tmp13_ = window;
#line 125 "../lib/DragManager.vala"
	g_signal_parse_name ("drag-end", gtk_widget_get_type (), &_tmp14_, NULL, FALSE);
#line 125 "../lib/DragManager.vala"
	g_signal_handlers_disconnect_matched ((GtkWidget*) _tmp13_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp14_, 0, NULL, (GCallback) _plank_drag_manager_drag_end_gtk_widget_drag_end, self);
#line 126 "../lib/DragManager.vala"
	_tmp15_ = window;
#line 126 "../lib/DragManager.vala"
	g_signal_parse_name ("drag-leave", gtk_widget_get_type (), &_tmp16_, NULL, FALSE);
#line 126 "../lib/DragManager.vala"
	g_signal_handlers_disconnect_matched ((GtkWidget*) _tmp15_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp16_, 0, NULL, (GCallback) _plank_drag_manager_drag_leave_gtk_widget_drag_leave, self);
#line 127 "../lib/DragManager.vala"
	_tmp17_ = window;
#line 127 "../lib/DragManager.vala"
	g_signal_parse_name ("drag-failed", gtk_widget_get_type (), &_tmp18_, NULL, FALSE);
#line 127 "../lib/DragManager.vala"
	g_signal_handlers_disconnect_matched ((GtkWidget*) _tmp17_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp18_, 0, NULL, (GCallback) _plank_drag_manager_drag_failed_gtk_widget_drag_failed, self);
#line 129 "../lib/DragManager.vala"
	_tmp19_ = self->priv->_controller;
#line 129 "../lib/DragManager.vala"
	_tmp20_ = plank_dock_controller_get_prefs (_tmp19_);
#line 129 "../lib/DragManager.vala"
	_tmp21_ = _tmp20_;
#line 129 "../lib/DragManager.vala"
	g_signal_parse_name ("notify::LockItems", G_TYPE_OBJECT, &_tmp22_, &_tmp23_, TRUE);
#line 129 "../lib/DragManager.vala"
	g_signal_handlers_disconnect_matched ((GObject*) _tmp21_, G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA, _tmp22_, _tmp23_, NULL, (GCallback) _plank_drag_manager_lock_items_changed_g_object_notify, self);
#line 131 "../lib/DragManager.vala"
	_tmp24_ = window;
#line 131 "../lib/DragManager.vala"
	plank_drag_manager_disable_drag_to (self, _tmp24_);
#line 132 "../lib/DragManager.vala"
	_tmp25_ = window;
#line 132 "../lib/DragManager.vala"
	plank_drag_manager_disable_drag_from (self, _tmp25_);
#line 27 "../lib/DragManager.vala"
	_g_object_unref0 (self->priv->_controller);
#line 31 "../lib/DragManager.vala"
	_g_object_unref0 (self->priv->_DragItem);
#line 67 "../lib/DragManager.vala"
	_g_object_unref0 (self->priv->proxy_window);
#line 75 "../lib/DragManager.vala"
	_g_object_unref0 (self->priv->drag_data);
#line 25 "../lib/DragManager.vala"
	G_OBJECT_CLASS (plank_drag_manager_parent_class)->finalize (obj);
#line 3905 "DragManager.c"
}

/**
 * Handles all of the drag'n'drop events for a dock.
 */
static GType
plank_drag_manager_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankDragManagerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_drag_manager_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankDragManager), 0, (GInstanceInitFunc) plank_drag_manager_instance_init, NULL };
	GType plank_drag_manager_type_id;
	plank_drag_manager_type_id = g_type_register_static (G_TYPE_OBJECT, "PlankDragManager", &g_define_type_info, 0);
	PlankDragManager_private_offset = g_type_add_instance_private (plank_drag_manager_type_id, sizeof (PlankDragManagerPrivate));
	return plank_drag_manager_type_id;
}

GType
plank_drag_manager_get_type (void)
{
	static volatile gsize plank_drag_manager_type_id__volatile = 0;
	if (g_once_init_enter (&plank_drag_manager_type_id__volatile)) {
		GType plank_drag_manager_type_id;
		plank_drag_manager_type_id = plank_drag_manager_get_type_once ();
		g_once_init_leave (&plank_drag_manager_type_id__volatile, plank_drag_manager_type_id);
	}
	return plank_drag_manager_type_id__volatile;
}

static void
_vala_plank_drag_manager_get_property (GObject * object,
                                       guint property_id,
                                       GValue * value,
                                       GParamSpec * pspec)
{
	PlankDragManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_DRAG_MANAGER, PlankDragManager);
#line 25 "../lib/DragManager.vala"
	switch (property_id) {
#line 25 "../lib/DragManager.vala"
		case PLANK_DRAG_MANAGER_CONTROLLER_PROPERTY:
#line 25 "../lib/DragManager.vala"
		g_value_set_object (value, plank_drag_manager_get_controller (self));
#line 25 "../lib/DragManager.vala"
		break;
#line 25 "../lib/DragManager.vala"
		case PLANK_DRAG_MANAGER_INTERNAL_DRAG_ACTIVE_PROPERTY:
#line 25 "../lib/DragManager.vala"
		g_value_set_boolean (value, plank_drag_manager_get_InternalDragActive (self));
#line 25 "../lib/DragManager.vala"
		break;
#line 25 "../lib/DragManager.vala"
		case PLANK_DRAG_MANAGER_DRAG_ITEM_PROPERTY:
#line 25 "../lib/DragManager.vala"
		g_value_set_object (value, plank_drag_manager_get_DragItem (self));
#line 25 "../lib/DragManager.vala"
		break;
#line 25 "../lib/DragManager.vala"
		case PLANK_DRAG_MANAGER_DRAG_NEEDS_CHECK_PROPERTY:
#line 25 "../lib/DragManager.vala"
		g_value_set_boolean (value, plank_drag_manager_get_DragNeedsCheck (self));
#line 25 "../lib/DragManager.vala"
		break;
#line 25 "../lib/DragManager.vala"
		case PLANK_DRAG_MANAGER_EXTERNAL_DRAG_ACTIVE_PROPERTY:
#line 25 "../lib/DragManager.vala"
		g_value_set_boolean (value, plank_drag_manager_get_ExternalDragActive (self));
#line 25 "../lib/DragManager.vala"
		break;
#line 25 "../lib/DragManager.vala"
		case PLANK_DRAG_MANAGER_REPOSITION_MODE_PROPERTY:
#line 25 "../lib/DragManager.vala"
		g_value_set_boolean (value, plank_drag_manager_get_RepositionMode (self));
#line 25 "../lib/DragManager.vala"
		break;
#line 3979 "DragManager.c"
		default:
#line 25 "../lib/DragManager.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 25 "../lib/DragManager.vala"
		break;
#line 3985 "DragManager.c"
	}
}

static void
_vala_plank_drag_manager_set_property (GObject * object,
                                       guint property_id,
                                       const GValue * value,
                                       GParamSpec * pspec)
{
	PlankDragManager * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_DRAG_MANAGER, PlankDragManager);
#line 25 "../lib/DragManager.vala"
	switch (property_id) {
#line 25 "../lib/DragManager.vala"
		case PLANK_DRAG_MANAGER_CONTROLLER_PROPERTY:
#line 25 "../lib/DragManager.vala"
		plank_drag_manager_set_controller (self, g_value_get_object (value));
#line 25 "../lib/DragManager.vala"
		break;
#line 25 "../lib/DragManager.vala"
		case PLANK_DRAG_MANAGER_INTERNAL_DRAG_ACTIVE_PROPERTY:
#line 25 "../lib/DragManager.vala"
		plank_drag_manager_set_InternalDragActive (self, g_value_get_boolean (value));
#line 25 "../lib/DragManager.vala"
		break;
#line 25 "../lib/DragManager.vala"
		case PLANK_DRAG_MANAGER_DRAG_ITEM_PROPERTY:
#line 25 "../lib/DragManager.vala"
		plank_drag_manager_set_DragItem (self, g_value_get_object (value));
#line 25 "../lib/DragManager.vala"
		break;
#line 25 "../lib/DragManager.vala"
		case PLANK_DRAG_MANAGER_DRAG_NEEDS_CHECK_PROPERTY:
#line 25 "../lib/DragManager.vala"
		plank_drag_manager_set_DragNeedsCheck (self, g_value_get_boolean (value));
#line 25 "../lib/DragManager.vala"
		break;
#line 25 "../lib/DragManager.vala"
		case PLANK_DRAG_MANAGER_EXTERNAL_DRAG_ACTIVE_PROPERTY:
#line 25 "../lib/DragManager.vala"
		plank_drag_manager_set_ExternalDragActive (self, g_value_get_boolean (value));
#line 25 "../lib/DragManager.vala"
		break;
#line 25 "../lib/DragManager.vala"
		case PLANK_DRAG_MANAGER_REPOSITION_MODE_PROPERTY:
#line 25 "../lib/DragManager.vala"
		plank_drag_manager_set_RepositionMode (self, g_value_get_boolean (value));
#line 25 "../lib/DragManager.vala"
		break;
#line 4035 "DragManager.c"
		default:
#line 25 "../lib/DragManager.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 25 "../lib/DragManager.vala"
		break;
#line 4041 "DragManager.c"
	}
}

static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gint i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gint
_vala_array_length (gpointer array)
{
	gint length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

