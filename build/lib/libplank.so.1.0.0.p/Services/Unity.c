/* Unity.c generated by valac 0.48.17, the Vala compiler
 * generated from Unity.vala, do not modify */

/**/
/*  Copyright (C) 2015 Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <gee.h>
#include <gio/gio.h>
#include "plank-internal.h"
#include <gobject/gvaluecollector.h>

#define PLANK_TYPE_UNITY_CLIENT (plank_unity_client_get_type ())
#define PLANK_UNITY_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_UNITY_CLIENT, PlankUnityClient))
#define PLANK_IS_UNITY_CLIENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_UNITY_CLIENT))
#define PLANK_UNITY_CLIENT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), PLANK_TYPE_UNITY_CLIENT, PlankUnityClientIface))

typedef struct _PlankUnityClient PlankUnityClient;
typedef struct _PlankUnityClientIface PlankUnityClientIface;

#define PLANK_TYPE_UNITY (plank_unity_get_type ())
#define PLANK_UNITY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_UNITY, PlankUnity))
#define PLANK_UNITY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_UNITY, PlankUnityClass))
#define PLANK_IS_UNITY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_UNITY))
#define PLANK_IS_UNITY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_UNITY))
#define PLANK_UNITY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_UNITY, PlankUnityClass))

typedef struct _PlankUnity PlankUnity;
typedef struct _PlankUnityClass PlankUnityClass;
typedef struct _PlankUnityPrivate PlankUnityPrivate;

#define PLANK_UNITY_TYPE_LAUNCHER_ENTRY (plank_unity_launcher_entry_get_type ())
#define PLANK_UNITY_LAUNCHER_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_UNITY_TYPE_LAUNCHER_ENTRY, PlankUnityLauncherEntry))
#define PLANK_UNITY_LAUNCHER_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_UNITY_TYPE_LAUNCHER_ENTRY, PlankUnityLauncherEntryClass))
#define PLANK_UNITY_IS_LAUNCHER_ENTRY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_UNITY_TYPE_LAUNCHER_ENTRY))
#define PLANK_UNITY_IS_LAUNCHER_ENTRY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_UNITY_TYPE_LAUNCHER_ENTRY))
#define PLANK_UNITY_LAUNCHER_ENTRY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_UNITY_TYPE_LAUNCHER_ENTRY, PlankUnityLauncherEntryClass))

typedef struct _PlankUnityLauncherEntry PlankUnityLauncherEntry;
typedef struct _PlankUnityLauncherEntryClass PlankUnityLauncherEntryClass;
enum  {
	PLANK_UNITY_0_PROPERTY,
	PLANK_UNITY_NUM_PROPERTIES
};
static GParamSpec* plank_unity_properties[PLANK_UNITY_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block14Data Block14Data;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block15Data Block15Data;
#define _plank_unity_launcher_entry_unref0(var) ((var == NULL) ? NULL : (var = (plank_unity_launcher_entry_unref (var), NULL)))
typedef struct _PlankUnityLauncherEntryPrivate PlankUnityLauncherEntryPrivate;
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
typedef struct _Block16Data Block16Data;
typedef struct _PlankUnityParamSpecLauncherEntry PlankUnityParamSpecLauncherEntry;
#define _g_variant_type_free0(var) ((var == NULL) ? NULL : (var = (g_variant_type_free (var), NULL)))

struct _PlankUnityClientIface {
	GTypeInterface parent_iface;
	void (*update_launcher_entry) (PlankUnityClient* self, const gchar* sender_name, GVariant* parameters, gboolean is_retry);
	void (*remove_launcher_entry) (PlankUnityClient* self, const gchar* sender_name);
};

struct _PlankUnity {
	GObject parent_instance;
	PlankUnityPrivate * priv;
};

struct _PlankUnityClass {
	GObjectClass parent_class;
};

struct _PlankUnityPrivate {
	GeeHashSet* clients;
	guint launcher_entry_dbus_signal_id;
	guint dbus_name_owner_changed_signal_id;
	GeeHashMap* launcher_entries;
	guint launcher_entries_timer_id;
};

struct _Block14Data {
	int _ref_count_;
	PlankUnity* self;
	gchar* name;
};

struct _Block15Data {
	int _ref_count_;
	PlankUnity* self;
	PlankUnityLauncherEntry* entry;
};

struct _PlankUnityLauncherEntry {
	GTypeInstance parent_instance;
	volatile int ref_count;
	PlankUnityLauncherEntryPrivate * priv;
	guint fast_count;
	gint64 last_update;
	gchar* sender_name;
	GVariant* parameters;
	guint timer_id;
	gboolean warned;
};

struct _PlankUnityLauncherEntryClass {
	GTypeClass parent_class;
	void (*finalize) (PlankUnityLauncherEntry *self);
};

struct _Block16Data {
	int _ref_count_;
	PlankUnity* self;
	gchar* sender_name;
	GVariant* parameters;
};

struct _PlankUnityParamSpecLauncherEntry {
	GParamSpec parent_instance;
};

static gint PlankUnity_private_offset;
static gpointer plank_unity_parent_class = NULL;
static guint plank_unity_unity_bus_id;
static GDBusConnection* plank_unity_connection;
static PlankUnity* plank_unity_instance;
static PlankUnity* plank_unity_instance = NULL;
static GDBusConnection* plank_unity_connection = NULL;
static guint plank_unity_unity_bus_id = 0U;
static GVariantType* plank_unity_payload_variant_type;
static GVariantType* plank_unity_payload_variant_type = NULL;
static gpointer plank_unity_launcher_entry_parent_class = NULL;

GType plank_unity_client_get_type (void) G_GNUC_CONST;
void plank_unity_client_update_launcher_entry (PlankUnityClient* self,
                                               const gchar* sender_name,
                                               GVariant* parameters,
                                               gboolean is_retry);
void plank_unity_client_remove_launcher_entry (PlankUnityClient* self,
                                               const gchar* sender_name);
static GType plank_unity_client_get_type_once (void);
GType plank_unity_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankUnity, g_object_unref)
static gpointer plank_unity_launcher_entry_ref (gpointer instance);
static void plank_unity_launcher_entry_unref (gpointer instance);
static GParamSpec* plank_unity_param_spec_launcher_entry (const gchar* name,
                                                   const gchar* nick,
                                                   const gchar* blurb,
                                                   GType object_type,
                                                   GParamFlags flags) G_GNUC_UNUSED;
static void plank_unity_value_set_launcher_entry (GValue* value,
                                           gpointer v_object) G_GNUC_UNUSED;
static void plank_unity_value_take_launcher_entry (GValue* value,
                                            gpointer v_object) G_GNUC_UNUSED;
static gpointer plank_unity_value_get_launcher_entry (const GValue* value) G_GNUC_UNUSED;
static GType plank_unity_launcher_entry_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankUnityLauncherEntry, plank_unity_launcher_entry_unref)
#define PLANK_UNITY_DBUS_NAME "com.canonical.Unity"
#define PLANK_UNITY_INTERFACE_NAME "com.canonical.Unity.LauncherEntry"
#define PLANK_UNITY_SIGNAL_NAME "Update"
PlankUnity* plank_unity_get_default (void);
static PlankUnity* plank_unity_new (void);
static PlankUnity* plank_unity_construct (GType object_type);
static void plank_unity_acquire_unity_dbus (void);
static void plank_unity_handle_bus_acquired (GDBusConnection* conn,
                                      const gchar* name);
static void plank_unity_handle_name_acquired (GDBusConnection* conn,
                                       const gchar* name);
static void plank_unity_handle_name_lost (GDBusConnection* conn,
                                   const gchar* name);
static void plank_unity_release_unity_dbus (void);
void plank_unity_add_client (PlankUnity* self,
                             PlankUnityClient* client);
void plank_unity_remove_client (PlankUnity* self,
                                PlankUnityClient* client);
static void plank_unity_handle_entry_signal (GDBusConnection* connection,
                                      const gchar* sender_name,
                                      const gchar* object_path,
                                      const gchar* interface_name,
                                      const gchar* signal_name,
                                      GVariant* parameters,
                                      PlankUnity* self);
static void plank_unity_handle_update_request (PlankUnity* self,
                                        const gchar* sender_name,
                                        GVariant* parameters);
static void plank_unity_handle_name_owner_changed (GDBusConnection* connection,
                                            const gchar* sender_name,
                                            const gchar* object_path,
                                            const gchar* interface_name,
                                            const gchar* signal_name,
                                            GVariant* parameters,
                                            PlankUnity* self);
static Block14Data* block14_data_ref (Block14Data* _data14_);
static void block14_data_unref (void * _userdata_);
static gboolean __lambda63_ (Block14Data* _data14_,
                      PlankUnityClient* client);
static gboolean ___lambda63__gee_forall_func (gpointer g,
                                       gpointer self);
static Block15Data* block15_data_ref (Block15Data* _data15_);
static void block15_data_unref (void * _userdata_);
static gboolean _____lambda61_ (Block15Data* _data15_);
static void plank_unity_perform_update (PlankUnity* self,
                                 const gchar* sender_name,
                                 GVariant* parameters);
static gboolean ______lambda61__gsource_func (gpointer self);
static PlankUnityLauncherEntry* plank_unity_launcher_entry_new (void);
static PlankUnityLauncherEntry* plank_unity_launcher_entry_construct (GType object_type);
static gboolean plank_unity_clean_up_launcher_entries (PlankUnity* self);
void plank_logger_verbose (const gchar* msg,
                           ...);
static Block16Data* block16_data_ref (Block16Data* _data16_);
static void block16_data_unref (void * _userdata_);
static gboolean __lambda62_ (Block16Data* _data16_,
                      PlankUnityClient* client);
static gboolean ___lambda62__gee_forall_func (gpointer g,
                                       gpointer self);
static void plank_unity_launcher_entry_finalize (PlankUnityLauncherEntry * obj);
static GType plank_unity_launcher_entry_get_type_once (void);
static GObject * plank_unity_constructor (GType type,
                                   guint n_construct_properties,
                                   GObjectConstructParam * construct_properties);
static void plank_unity_finalize (GObject * obj);
static GType plank_unity_get_type_once (void);

/**
 * The LauncherEntry corresponding to the sender_name requested an update
 *
 * @param sender_name the dbusname
 * @param parameters the data in a standardize format '(sa{sv})' from libunity
 * @param is_retry whether this data was already processed before and decided to give is another run
 */
void
plank_unity_client_update_launcher_entry (PlankUnityClient* self,
                                          const gchar* sender_name,
                                          GVariant* parameters,
                                          gboolean is_retry)
{
#line 34 "../lib/Services/Unity.vala"
	g_return_if_fail (self != NULL);
#line 34 "../lib/Services/Unity.vala"
	PLANK_UNITY_CLIENT_GET_INTERFACE (self)->update_launcher_entry (self, sender_name, parameters, is_retry);
#line 261 "Unity.c"
}

/**
 * The LauncherEntry corresponding to the sender_name vanished
 *
 * @param sender_name the dbusname
 */
void
plank_unity_client_remove_launcher_entry (PlankUnityClient* self,
                                          const gchar* sender_name)
{
#line 41 "../lib/Services/Unity.vala"
	g_return_if_fail (self != NULL);
#line 41 "../lib/Services/Unity.vala"
	PLANK_UNITY_CLIENT_GET_INTERFACE (self)->remove_launcher_entry (self, sender_name);
#line 277 "Unity.c"
}

static void
plank_unity_client_default_init (PlankUnityClientIface * iface,
                                 gpointer iface_data)
{
}

/**
 * The interface to provide the LauncherEntry handling.
 */
static GType
plank_unity_client_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankUnityClientIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_unity_client_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType plank_unity_client_type_id;
	plank_unity_client_type_id = g_type_register_static (G_TYPE_INTERFACE, "PlankUnityClient", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (plank_unity_client_type_id, G_TYPE_OBJECT);
	return plank_unity_client_type_id;
}

GType
plank_unity_client_get_type (void)
{
	static volatile gsize plank_unity_client_type_id__volatile = 0;
	if (g_once_init_enter (&plank_unity_client_type_id__volatile)) {
		GType plank_unity_client_type_id;
		plank_unity_client_type_id = plank_unity_client_get_type_once ();
		g_once_init_leave (&plank_unity_client_type_id__volatile, plank_unity_client_type_id);
	}
	return plank_unity_client_type_id__volatile;
}

static inline gpointer
plank_unity_get_instance_private (PlankUnity* self)
{
	return G_STRUCT_MEMBER_P (self, PlankUnity_private_offset);
}

PlankUnity*
plank_unity_get_default (void)
{
	PlankUnity* _tmp0_;
	PlankUnity* _tmp2_;
	PlankUnity* result = NULL;
#line 70 "../lib/Services/Unity.vala"
	_tmp0_ = plank_unity_instance;
#line 70 "../lib/Services/Unity.vala"
	if (_tmp0_ == NULL) {
#line 327 "Unity.c"
		PlankUnity* _tmp1_;
#line 71 "../lib/Services/Unity.vala"
		_tmp1_ = plank_unity_new ();
#line 71 "../lib/Services/Unity.vala"
		_g_object_unref0 (plank_unity_instance);
#line 71 "../lib/Services/Unity.vala"
		plank_unity_instance = _tmp1_;
#line 335 "Unity.c"
	}
#line 73 "../lib/Services/Unity.vala"
	_tmp2_ = plank_unity_instance;
#line 73 "../lib/Services/Unity.vala"
	result = _tmp2_;
#line 73 "../lib/Services/Unity.vala"
	return result;
#line 343 "Unity.c"
}

/**
 * Connect DBus connection and try to aquire unity busname
 */
static void
plank_unity_acquire_unity_dbus (void)
{
	GError* _inner_error0_ = NULL;
	{
		GDBusConnection* _tmp0_;
#line 89 "../lib/Services/Unity.vala"
		_tmp0_ = plank_unity_connection;
#line 89 "../lib/Services/Unity.vala"
		if (_tmp0_ == NULL) {
#line 359 "Unity.c"
			GDBusConnection* _tmp1_ = NULL;
			GDBusConnection* _tmp2_;
			GDBusConnection* _tmp3_;
#line 90 "../lib/Services/Unity.vala"
			_tmp2_ = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, &_inner_error0_);
#line 90 "../lib/Services/Unity.vala"
			_tmp1_ = _tmp2_;
#line 90 "../lib/Services/Unity.vala"
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 369 "Unity.c"
				goto __catch0_g_error;
			}
#line 90 "../lib/Services/Unity.vala"
			_tmp3_ = _tmp1_;
#line 90 "../lib/Services/Unity.vala"
			_tmp1_ = NULL;
#line 90 "../lib/Services/Unity.vala"
			_g_object_unref0 (plank_unity_connection);
#line 90 "../lib/Services/Unity.vala"
			plank_unity_connection = _tmp3_;
#line 89 "../lib/Services/Unity.vala"
			_g_object_unref0 (_tmp1_);
#line 382 "Unity.c"
		}
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp4_;
		const gchar* _tmp5_;
#line 88 "../lib/Services/Unity.vala"
		e = _inner_error0_;
#line 88 "../lib/Services/Unity.vala"
		_inner_error0_ = NULL;
#line 92 "../lib/Services/Unity.vala"
		_tmp4_ = e;
#line 92 "../lib/Services/Unity.vala"
		_tmp5_ = _tmp4_->message;
#line 92 "../lib/Services/Unity.vala"
		g_warning ("Unity.vala:92: %s", _tmp5_);
#line 93 "../lib/Services/Unity.vala"
		_g_error_free0 (e);
#line 93 "../lib/Services/Unity.vala"
		return;
#line 405 "Unity.c"
	}
	__finally0:
#line 88 "../lib/Services/Unity.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 88 "../lib/Services/Unity.vala"
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 88 "../lib/Services/Unity.vala"
		g_clear_error (&_inner_error0_);
#line 88 "../lib/Services/Unity.vala"
		return;
#line 416 "Unity.c"
	}
#line 96 "../lib/Services/Unity.vala"
	if (plank_unity_unity_bus_id == 0U) {
#line 98 "../lib/Services/Unity.vala"
		plank_unity_unity_bus_id = g_bus_own_name_with_closures (G_BUS_TYPE_SESSION, PLANK_UNITY_DBUS_NAME, G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT, (GClosure*) ((((GBusAcquiredCallback) plank_unity_handle_bus_acquired) == NULL) ? NULL : g_cclosure_new ((GCallback) ((GBusAcquiredCallback) plank_unity_handle_bus_acquired), NULL, (GClosureNotify) NULL)), (GClosure*) ((((GBusNameAcquiredCallback) plank_unity_handle_name_acquired) == NULL) ? NULL : g_cclosure_new ((GCallback) ((GBusNameAcquiredCallback) plank_unity_handle_name_acquired), NULL, (GClosureNotify) NULL)), (GClosure*) ((((GBusNameLostCallback) plank_unity_handle_name_lost) == NULL) ? NULL : g_cclosure_new ((GCallback) ((GBusNameLostCallback) plank_unity_handle_name_lost), NULL, (GClosureNotify) NULL)));
#line 422 "Unity.c"
	}
}

/**
 * Disconnect DBus connection and release unity busname
 */
static void
plank_unity_release_unity_dbus (void)
{
	GDBusConnection* _tmp0_;
	GError* _inner_error0_ = NULL;
#line 109 "../lib/Services/Unity.vala"
	if (plank_unity_unity_bus_id > 0U) {
#line 110 "../lib/Services/Unity.vala"
		g_bus_unown_name (plank_unity_unity_bus_id);
#line 111 "../lib/Services/Unity.vala"
		plank_unity_unity_bus_id = 0U;
#line 440 "Unity.c"
	}
#line 114 "../lib/Services/Unity.vala"
	_tmp0_ = plank_unity_connection;
#line 114 "../lib/Services/Unity.vala"
	if (_tmp0_ != NULL) {
#line 446 "Unity.c"
		{
			GDBusConnection* _tmp1_;
			GDBusConnection* _tmp2_;
#line 116 "../lib/Services/Unity.vala"
			_tmp1_ = plank_unity_connection;
#line 116 "../lib/Services/Unity.vala"
			g_dbus_connection_flush_sync (_tmp1_, NULL, &_inner_error0_);
#line 116 "../lib/Services/Unity.vala"
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 456 "Unity.c"
				goto __catch0_g_error;
			}
#line 117 "../lib/Services/Unity.vala"
			_tmp2_ = plank_unity_connection;
#line 117 "../lib/Services/Unity.vala"
			g_dbus_connection_close_sync (_tmp2_, NULL, &_inner_error0_);
#line 117 "../lib/Services/Unity.vala"
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 465 "Unity.c"
				goto __catch0_g_error;
			}
		}
		goto __finally0;
		__catch0_g_error:
		{
			GError* e = NULL;
			GError* _tmp3_;
			const gchar* _tmp4_;
#line 115 "../lib/Services/Unity.vala"
			e = _inner_error0_;
#line 115 "../lib/Services/Unity.vala"
			_inner_error0_ = NULL;
#line 119 "../lib/Services/Unity.vala"
			_tmp3_ = e;
#line 119 "../lib/Services/Unity.vala"
			_tmp4_ = _tmp3_->message;
#line 119 "../lib/Services/Unity.vala"
			g_warning ("Unity.vala:119: %s", _tmp4_);
#line 115 "../lib/Services/Unity.vala"
			_g_error_free0 (e);
#line 487 "Unity.c"
		}
		__finally0:
		{
			GError* _inner_error1_ = NULL;
#line 121 "../lib/Services/Unity.vala"
			_g_object_unref0 (plank_unity_connection);
#line 121 "../lib/Services/Unity.vala"
			plank_unity_connection = NULL;
#line 496 "Unity.c"
		}
#line 115 "../lib/Services/Unity.vala"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 115 "../lib/Services/Unity.vala"
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 115 "../lib/Services/Unity.vala"
			g_clear_error (&_inner_error0_);
#line 115 "../lib/Services/Unity.vala"
			return;
#line 506 "Unity.c"
		}
	}
}

static void
plank_unity_handle_bus_acquired (GDBusConnection* conn,
                                 const gchar* name)
{
#line 126 "../lib/Services/Unity.vala"
	g_return_if_fail (conn != NULL);
#line 126 "../lib/Services/Unity.vala"
	g_return_if_fail (name != NULL);
#line 519 "Unity.c"
}

static void
plank_unity_handle_name_acquired (GDBusConnection* conn,
                                  const gchar* name)
{
#line 131 "../lib/Services/Unity.vala"
	g_return_if_fail (conn != NULL);
#line 131 "../lib/Services/Unity.vala"
	g_return_if_fail (name != NULL);
#line 133 "../lib/Services/Unity.vala"
	g_debug ("Unity.vala:133: %s acquired", name);
#line 532 "Unity.c"
}

static void
plank_unity_handle_name_lost (GDBusConnection* conn,
                              const gchar* name)
{
#line 136 "../lib/Services/Unity.vala"
	g_return_if_fail (conn != NULL);
#line 136 "../lib/Services/Unity.vala"
	g_return_if_fail (name != NULL);
#line 138 "../lib/Services/Unity.vala"
	if (conn == NULL) {
#line 139 "../lib/Services/Unity.vala"
		g_warning ("Unity.vala:139: %s failed", name);
#line 547 "Unity.c"
	} else {
#line 141 "../lib/Services/Unity.vala"
		g_debug ("Unity.vala:141: %s lost", name);
#line 551 "Unity.c"
	}
}

static PlankUnity*
plank_unity_construct (GType object_type)
{
	PlankUnity * self = NULL;
#line 153 "../lib/Services/Unity.vala"
	self = (PlankUnity*) g_object_new (object_type, NULL);
#line 151 "../lib/Services/Unity.vala"
	return self;
#line 563 "Unity.c"
}

static PlankUnity*
plank_unity_new (void)
{
#line 151 "../lib/Services/Unity.vala"
	return plank_unity_construct (PLANK_TYPE_UNITY);
#line 571 "Unity.c"
}

/**
 * Add a client which will receive all update requests of running LauncherEntry applications.
 *
 * @param client the client to add
 */
void
plank_unity_add_client (PlankUnity* self,
                        PlankUnityClient* client)
{
	GeeHashSet* _tmp0_;
#line 197 "../lib/Services/Unity.vala"
	g_return_if_fail (self != NULL);
#line 197 "../lib/Services/Unity.vala"
	g_return_if_fail (client != NULL);
#line 199 "../lib/Services/Unity.vala"
	_tmp0_ = self->priv->clients;
#line 199 "../lib/Services/Unity.vala"
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp0_, client);
#line 592 "Unity.c"
}

/**
 * Remove a client.
 *
 * @param client the client to remove
 */
void
plank_unity_remove_client (PlankUnity* self,
                           PlankUnityClient* client)
{
	GeeHashSet* _tmp0_;
#line 207 "../lib/Services/Unity.vala"
	g_return_if_fail (self != NULL);
#line 207 "../lib/Services/Unity.vala"
	g_return_if_fail (client != NULL);
#line 209 "../lib/Services/Unity.vala"
	_tmp0_ = self->priv->clients;
#line 209 "../lib/Services/Unity.vala"
	gee_abstract_collection_remove ((GeeAbstractCollection*) _tmp0_, client);
#line 613 "Unity.c"
}

static void
plank_unity_handle_entry_signal (GDBusConnection* connection,
                                 const gchar* sender_name,
                                 const gchar* object_path,
                                 const gchar* interface_name,
                                 const gchar* signal_name,
                                 GVariant* parameters,
                                 PlankUnity* self)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
#line 213 "../lib/Services/Unity.vala"
	g_return_if_fail (self != NULL);
#line 213 "../lib/Services/Unity.vala"
	g_return_if_fail (connection != NULL);
#line 213 "../lib/Services/Unity.vala"
	g_return_if_fail (sender_name != NULL);
#line 213 "../lib/Services/Unity.vala"
	g_return_if_fail (object_path != NULL);
#line 213 "../lib/Services/Unity.vala"
	g_return_if_fail (interface_name != NULL);
#line 213 "../lib/Services/Unity.vala"
	g_return_if_fail (signal_name != NULL);
#line 213 "../lib/Services/Unity.vala"
	g_return_if_fail (parameters != NULL);
#line 216 "../lib/Services/Unity.vala"
	if (parameters == NULL) {
#line 216 "../lib/Services/Unity.vala"
		_tmp1_ = TRUE;
#line 645 "Unity.c"
	} else {
#line 216 "../lib/Services/Unity.vala"
		_tmp1_ = signal_name == NULL;
#line 649 "Unity.c"
	}
#line 216 "../lib/Services/Unity.vala"
	if (_tmp1_) {
#line 216 "../lib/Services/Unity.vala"
		_tmp0_ = TRUE;
#line 655 "Unity.c"
	} else {
#line 216 "../lib/Services/Unity.vala"
		_tmp0_ = sender_name == NULL;
#line 659 "Unity.c"
	}
#line 216 "../lib/Services/Unity.vala"
	if (_tmp0_) {
#line 217 "../lib/Services/Unity.vala"
		return;
#line 665 "Unity.c"
	}
#line 219 "../lib/Services/Unity.vala"
	if (g_strcmp0 (signal_name, PLANK_UNITY_SIGNAL_NAME) == 0) {
#line 220 "../lib/Services/Unity.vala"
		plank_unity_handle_update_request (self, sender_name, parameters);
#line 671 "Unity.c"
	}
}

static Block14Data*
block14_data_ref (Block14Data* _data14_)
{
#line 224 "../lib/Services/Unity.vala"
	g_atomic_int_inc (&_data14_->_ref_count_);
#line 224 "../lib/Services/Unity.vala"
	return _data14_;
#line 682 "Unity.c"
}

static void
block14_data_unref (void * _userdata_)
{
	Block14Data* _data14_;
	_data14_ = (Block14Data*) _userdata_;
#line 224 "../lib/Services/Unity.vala"
	if (g_atomic_int_dec_and_test (&_data14_->_ref_count_)) {
#line 692 "Unity.c"
		PlankUnity* self;
#line 224 "../lib/Services/Unity.vala"
		self = _data14_->self;
#line 224 "../lib/Services/Unity.vala"
		_g_free0 (_data14_->name);
#line 224 "../lib/Services/Unity.vala"
		_g_object_unref0 (self);
#line 224 "../lib/Services/Unity.vala"
		g_slice_free (Block14Data, _data14_);
#line 702 "Unity.c"
	}
}

static gboolean
__lambda63_ (Block14Data* _data14_,
             PlankUnityClient* client)
{
	PlankUnity* self;
	const gchar* _tmp0_;
	gboolean result = FALSE;
#line 233 "../lib/Services/Unity.vala"
	self = _data14_->self;
#line 233 "../lib/Services/Unity.vala"
	g_return_val_if_fail (client != NULL, FALSE);
#line 234 "../lib/Services/Unity.vala"
	_tmp0_ = _data14_->name;
#line 234 "../lib/Services/Unity.vala"
	plank_unity_client_remove_launcher_entry (client, _tmp0_);
#line 235 "../lib/Services/Unity.vala"
	result = TRUE;
#line 235 "../lib/Services/Unity.vala"
	_g_object_unref0 (client);
#line 235 "../lib/Services/Unity.vala"
	return result;
#line 727 "Unity.c"
}

static gboolean
___lambda63__gee_forall_func (gpointer g,
                              gpointer self)
{
	gboolean result;
	result = __lambda63_ (self, (PlankUnityClient*) g);
#line 233 "../lib/Services/Unity.vala"
	return result;
#line 738 "Unity.c"
}

static void
plank_unity_handle_name_owner_changed (GDBusConnection* connection,
                                       const gchar* sender_name,
                                       const gchar* object_path,
                                       const gchar* interface_name,
                                       const gchar* signal_name,
                                       GVariant* parameters,
                                       PlankUnity* self)
{
	Block14Data* _data14_;
	gchar* before = NULL;
	gchar* after = NULL;
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	const gchar* _tmp4_;
	GeeHashSet* _tmp6_;
#line 224 "../lib/Services/Unity.vala"
	g_return_if_fail (self != NULL);
#line 224 "../lib/Services/Unity.vala"
	g_return_if_fail (connection != NULL);
#line 224 "../lib/Services/Unity.vala"
	g_return_if_fail (sender_name != NULL);
#line 224 "../lib/Services/Unity.vala"
	g_return_if_fail (object_path != NULL);
#line 224 "../lib/Services/Unity.vala"
	g_return_if_fail (interface_name != NULL);
#line 224 "../lib/Services/Unity.vala"
	g_return_if_fail (signal_name != NULL);
#line 224 "../lib/Services/Unity.vala"
	g_return_if_fail (parameters != NULL);
#line 224 "../lib/Services/Unity.vala"
	_data14_ = g_slice_new0 (Block14Data);
#line 224 "../lib/Services/Unity.vala"
	_data14_->_ref_count_ = 1;
#line 224 "../lib/Services/Unity.vala"
	_data14_->self = g_object_ref (self);
#line 228 "../lib/Services/Unity.vala"
	g_variant_get (parameters, "(sss)", &_tmp0_, &_tmp1_, &_tmp2_, NULL);
#line 228 "../lib/Services/Unity.vala"
	_g_free0 (_data14_->name);
#line 228 "../lib/Services/Unity.vala"
	_data14_->name = _tmp0_;
#line 228 "../lib/Services/Unity.vala"
	_g_free0 (before);
#line 228 "../lib/Services/Unity.vala"
	before = _tmp1_;
#line 228 "../lib/Services/Unity.vala"
	_g_free0 (after);
#line 228 "../lib/Services/Unity.vala"
	after = _tmp2_;
#line 230 "../lib/Services/Unity.vala"
	_tmp4_ = after;
#line 230 "../lib/Services/Unity.vala"
	if (_tmp4_ != NULL) {
#line 797 "Unity.c"
		const gchar* _tmp5_;
#line 230 "../lib/Services/Unity.vala"
		_tmp5_ = after;
#line 230 "../lib/Services/Unity.vala"
		_tmp3_ = g_strcmp0 (_tmp5_, "") != 0;
#line 803 "Unity.c"
	} else {
#line 230 "../lib/Services/Unity.vala"
		_tmp3_ = FALSE;
#line 807 "Unity.c"
	}
#line 230 "../lib/Services/Unity.vala"
	if (_tmp3_) {
#line 231 "../lib/Services/Unity.vala"
		_g_free0 (after);
#line 231 "../lib/Services/Unity.vala"
		_g_free0 (before);
#line 231 "../lib/Services/Unity.vala"
		block14_data_unref (_data14_);
#line 231 "../lib/Services/Unity.vala"
		_data14_ = NULL;
#line 231 "../lib/Services/Unity.vala"
		return;
#line 821 "Unity.c"
	}
#line 233 "../lib/Services/Unity.vala"
	_tmp6_ = self->priv->clients;
#line 233 "../lib/Services/Unity.vala"
	gee_abstract_collection_foreach ((GeeAbstractCollection*) _tmp6_, ___lambda63__gee_forall_func, _data14_);
#line 224 "../lib/Services/Unity.vala"
	_g_free0 (after);
#line 224 "../lib/Services/Unity.vala"
	_g_free0 (before);
#line 224 "../lib/Services/Unity.vala"
	block14_data_unref (_data14_);
#line 224 "../lib/Services/Unity.vala"
	_data14_ = NULL;
#line 835 "Unity.c"
}

static Block15Data*
block15_data_ref (Block15Data* _data15_)
{
#line 239 "../lib/Services/Unity.vala"
	g_atomic_int_inc (&_data15_->_ref_count_);
#line 239 "../lib/Services/Unity.vala"
	return _data15_;
#line 845 "Unity.c"
}

static void
block15_data_unref (void * _userdata_)
{
	Block15Data* _data15_;
	_data15_ = (Block15Data*) _userdata_;
#line 239 "../lib/Services/Unity.vala"
	if (g_atomic_int_dec_and_test (&_data15_->_ref_count_)) {
#line 855 "Unity.c"
		PlankUnity* self;
#line 239 "../lib/Services/Unity.vala"
		self = _data15_->self;
#line 239 "../lib/Services/Unity.vala"
		_plank_unity_launcher_entry_unref0 (_data15_->entry);
#line 239 "../lib/Services/Unity.vala"
		_g_object_unref0 (self);
#line 239 "../lib/Services/Unity.vala"
		g_slice_free (Block15Data, _data15_);
#line 865 "Unity.c"
	}
}

static gpointer
_g_variant_ref0 (gpointer self)
{
#line 244 "../lib/Services/Unity.vala"
	return self ? g_variant_ref (self) : NULL;
#line 874 "Unity.c"
}

static gboolean
_____lambda61_ (Block15Data* _data15_)
{
	PlankUnity* self;
	PlankUnityLauncherEntry* _tmp0_;
	PlankUnityLauncherEntry* _tmp1_;
	PlankUnityLauncherEntry* _tmp2_;
	const gchar* _tmp3_;
	PlankUnityLauncherEntry* _tmp4_;
	GVariant* _tmp5_;
	gboolean result = FALSE;
#line 252 "../lib/Services/Unity.vala"
	self = _data15_->self;
#line 253 "../lib/Services/Unity.vala"
	_tmp0_ = _data15_->entry;
#line 253 "../lib/Services/Unity.vala"
	_tmp0_->timer_id = 0U;
#line 254 "../lib/Services/Unity.vala"
	_tmp1_ = _data15_->entry;
#line 254 "../lib/Services/Unity.vala"
	_tmp1_->last_update = g_get_monotonic_time ();
#line 255 "../lib/Services/Unity.vala"
	_tmp2_ = _data15_->entry;
#line 255 "../lib/Services/Unity.vala"
	_tmp3_ = _tmp2_->sender_name;
#line 255 "../lib/Services/Unity.vala"
	_tmp4_ = _data15_->entry;
#line 255 "../lib/Services/Unity.vala"
	_tmp5_ = _tmp4_->parameters;
#line 255 "../lib/Services/Unity.vala"
	plank_unity_perform_update (self, _tmp3_, _tmp5_);
#line 256 "../lib/Services/Unity.vala"
	result = FALSE;
#line 256 "../lib/Services/Unity.vala"
	return result;
#line 912 "Unity.c"
}

static gboolean
______lambda61__gsource_func (gpointer self)
{
	gboolean result;
	result = _____lambda61_ (self);
#line 252 "../lib/Services/Unity.vala"
	return result;
#line 922 "Unity.c"
}

static void
plank_unity_handle_update_request (PlankUnity* self,
                                   const gchar* sender_name,
                                   GVariant* parameters)
{
	Block15Data* _data15_;
	gint64 current_time = 0LL;
	GeeHashMap* _tmp0_;
	gpointer _tmp1_;
	PlankUnityLauncherEntry* _tmp2_;
#line 239 "../lib/Services/Unity.vala"
	g_return_if_fail (self != NULL);
#line 239 "../lib/Services/Unity.vala"
	g_return_if_fail (sender_name != NULL);
#line 239 "../lib/Services/Unity.vala"
	g_return_if_fail (parameters != NULL);
#line 239 "../lib/Services/Unity.vala"
	_data15_ = g_slice_new0 (Block15Data);
#line 239 "../lib/Services/Unity.vala"
	_data15_->_ref_count_ = 1;
#line 239 "../lib/Services/Unity.vala"
	_data15_->self = g_object_ref (self);
#line 241 "../lib/Services/Unity.vala"
	current_time = g_get_monotonic_time ();
#line 243 "../lib/Services/Unity.vala"
	_tmp0_ = self->priv->launcher_entries;
#line 243 "../lib/Services/Unity.vala"
	_tmp1_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp0_, sender_name);
#line 243 "../lib/Services/Unity.vala"
	_plank_unity_launcher_entry_unref0 (_data15_->entry);
#line 243 "../lib/Services/Unity.vala"
	_data15_->entry = (PlankUnityLauncherEntry*) _tmp1_;
#line 243 "../lib/Services/Unity.vala"
	_tmp2_ = _data15_->entry;
#line 243 "../lib/Services/Unity.vala"
	if (_tmp2_ != NULL) {
#line 961 "Unity.c"
		PlankUnityLauncherEntry* _tmp3_;
		GVariant* _tmp4_;
		gboolean _tmp5_ = FALSE;
		PlankUnityLauncherEntry* _tmp6_;
#line 244 "../lib/Services/Unity.vala"
		_tmp3_ = _data15_->entry;
#line 244 "../lib/Services/Unity.vala"
		_tmp4_ = _g_variant_ref0 (parameters);
#line 244 "../lib/Services/Unity.vala"
		_g_variant_unref0 (_tmp3_->parameters);
#line 244 "../lib/Services/Unity.vala"
		_tmp3_->parameters = _tmp4_;
#line 245 "../lib/Services/Unity.vala"
		_tmp6_ = _data15_->entry;
#line 245 "../lib/Services/Unity.vala"
		if ((current_time - _tmp6_->last_update) < ((gint64) (PLANK_UNITY_UPDATE_THRESHOLD_DURATION * 1000))) {
#line 978 "Unity.c"
			PlankUnityLauncherEntry* _tmp7_;
#line 246 "../lib/Services/Unity.vala"
			_tmp7_ = _data15_->entry;
#line 246 "../lib/Services/Unity.vala"
			_tmp5_ = _tmp7_->fast_count > PLANK_UNITY_UPDATE_THRESHOLD_FAST_COUNT;
#line 984 "Unity.c"
		} else {
#line 245 "../lib/Services/Unity.vala"
			_tmp5_ = FALSE;
#line 988 "Unity.c"
		}
#line 245 "../lib/Services/Unity.vala"
		if (_tmp5_) {
#line 992 "Unity.c"
			PlankUnityLauncherEntry* _tmp8_;
#line 247 "../lib/Services/Unity.vala"
			_tmp8_ = _data15_->entry;
#line 247 "../lib/Services/Unity.vala"
			if (_tmp8_->timer_id <= 0U) {
#line 998 "Unity.c"
				PlankUnityLauncherEntry* _tmp9_;
				PlankUnityLauncherEntry* _tmp11_;
#line 248 "../lib/Services/Unity.vala"
				_tmp9_ = _data15_->entry;
#line 248 "../lib/Services/Unity.vala"
				if (!_tmp9_->warned) {
#line 1005 "Unity.c"
					PlankUnityLauncherEntry* _tmp10_;
#line 249 "../lib/Services/Unity.vala"
					g_warning ("Unity.vala:249: LauncherEntry '%s' is behaving badly, skipping request" \
"s", sender_name);
#line 250 "../lib/Services/Unity.vala"
					_tmp10_ = _data15_->entry;
#line 250 "../lib/Services/Unity.vala"
					_tmp10_->warned = TRUE;
#line 1013 "Unity.c"
				}
#line 252 "../lib/Services/Unity.vala"
				_tmp11_ = _data15_->entry;
#line 252 "../lib/Services/Unity.vala"
				_tmp11_->timer_id = g_timeout_add_full (G_PRIORITY_DEFAULT, PLANK_UNITY_UPDATE_THRESHOLD_DURATION, ______lambda61__gsource_func, block15_data_ref (_data15_), block15_data_unref);
#line 1019 "Unity.c"
			}
		} else {
			PlankUnityLauncherEntry* _tmp12_;
			guint _tmp13_;
			PlankUnityLauncherEntry* _tmp14_;
			PlankUnityLauncherEntry* _tmp15_;
			const gchar* _tmp16_;
			PlankUnityLauncherEntry* _tmp17_;
			GVariant* _tmp18_;
#line 260 "../lib/Services/Unity.vala"
			_tmp12_ = _data15_->entry;
#line 260 "../lib/Services/Unity.vala"
			_tmp13_ = _tmp12_->fast_count;
#line 260 "../lib/Services/Unity.vala"
			_tmp12_->fast_count = _tmp13_ + 1;
#line 261 "../lib/Services/Unity.vala"
			_tmp14_ = _data15_->entry;
#line 261 "../lib/Services/Unity.vala"
			_tmp14_->last_update = current_time;
#line 262 "../lib/Services/Unity.vala"
			_tmp15_ = _data15_->entry;
#line 262 "../lib/Services/Unity.vala"
			_tmp16_ = _tmp15_->sender_name;
#line 262 "../lib/Services/Unity.vala"
			_tmp17_ = _data15_->entry;
#line 262 "../lib/Services/Unity.vala"
			_tmp18_ = _tmp17_->parameters;
#line 262 "../lib/Services/Unity.vala"
			plank_unity_perform_update (self, _tmp16_, _tmp18_);
#line 1049 "Unity.c"
		}
	} else {
		PlankUnityLauncherEntry* _tmp19_;
		PlankUnityLauncherEntry* _tmp20_;
		guint _tmp21_;
		PlankUnityLauncherEntry* _tmp22_;
		PlankUnityLauncherEntry* _tmp23_;
		gchar* _tmp24_;
		PlankUnityLauncherEntry* _tmp25_;
		GVariant* _tmp26_;
		GeeHashMap* _tmp27_;
		PlankUnityLauncherEntry* _tmp28_;
#line 265 "../lib/Services/Unity.vala"
		_tmp19_ = plank_unity_launcher_entry_new ();
#line 265 "../lib/Services/Unity.vala"
		_plank_unity_launcher_entry_unref0 (_data15_->entry);
#line 265 "../lib/Services/Unity.vala"
		_data15_->entry = _tmp19_;
#line 266 "../lib/Services/Unity.vala"
		_tmp20_ = _data15_->entry;
#line 266 "../lib/Services/Unity.vala"
		_tmp21_ = _tmp20_->fast_count;
#line 266 "../lib/Services/Unity.vala"
		_tmp20_->fast_count = _tmp21_ + 1;
#line 267 "../lib/Services/Unity.vala"
		_tmp22_ = _data15_->entry;
#line 267 "../lib/Services/Unity.vala"
		_tmp22_->last_update = current_time;
#line 268 "../lib/Services/Unity.vala"
		_tmp23_ = _data15_->entry;
#line 268 "../lib/Services/Unity.vala"
		_tmp24_ = g_strdup (sender_name);
#line 268 "../lib/Services/Unity.vala"
		_g_free0 (_tmp23_->sender_name);
#line 268 "../lib/Services/Unity.vala"
		_tmp23_->sender_name = _tmp24_;
#line 269 "../lib/Services/Unity.vala"
		_tmp25_ = _data15_->entry;
#line 269 "../lib/Services/Unity.vala"
		_tmp26_ = _g_variant_ref0 (parameters);
#line 269 "../lib/Services/Unity.vala"
		_g_variant_unref0 (_tmp25_->parameters);
#line 269 "../lib/Services/Unity.vala"
		_tmp25_->parameters = _tmp26_;
#line 270 "../lib/Services/Unity.vala"
		_tmp27_ = self->priv->launcher_entries;
#line 270 "../lib/Services/Unity.vala"
		_tmp28_ = _data15_->entry;
#line 270 "../lib/Services/Unity.vala"
		gee_abstract_map_set ((GeeAbstractMap*) _tmp27_, sender_name, _tmp28_);
#line 271 "../lib/Services/Unity.vala"
		plank_unity_perform_update (self, sender_name, parameters);
#line 1102 "Unity.c"
	}
#line 274 "../lib/Services/Unity.vala"
	if (self->priv->launcher_entries_timer_id <= 0U) {
#line 275 "../lib/Services/Unity.vala"
		self->priv->launcher_entries_timer_id = g_timeout_add_full (G_PRIORITY_DEFAULT, (guint) (60 * 1000), (GSourceFunc) plank_unity_clean_up_launcher_entries, g_object_ref (self), g_object_unref);
#line 1108 "Unity.c"
	}
#line 239 "../lib/Services/Unity.vala"
	block15_data_unref (_data15_);
#line 239 "../lib/Services/Unity.vala"
	_data15_ = NULL;
#line 1114 "Unity.c"
}

static gboolean
plank_unity_clean_up_launcher_entries (PlankUnity* self)
{
	gint64 current_time = 0LL;
	GeeMapIterator* launcher_entries_it = NULL;
	GeeHashMap* _tmp0_;
	GeeMapIterator* _tmp1_;
	gboolean keep_running = FALSE;
	GeeHashMap* _tmp7_;
	gint _tmp8_;
	gint _tmp9_;
	GeeHashMap* _tmp10_;
	gint _tmp11_;
	gint _tmp12_;
	gboolean result = FALSE;
#line 278 "../lib/Services/Unity.vala"
	g_return_val_if_fail (self != NULL, FALSE);
#line 280 "../lib/Services/Unity.vala"
	current_time = g_get_monotonic_time ();
#line 282 "../lib/Services/Unity.vala"
	_tmp0_ = self->priv->launcher_entries;
#line 282 "../lib/Services/Unity.vala"
	_tmp1_ = gee_abstract_map_map_iterator ((GeeAbstractMap*) _tmp0_);
#line 282 "../lib/Services/Unity.vala"
	launcher_entries_it = _tmp1_;
#line 283 "../lib/Services/Unity.vala"
	while (TRUE) {
#line 1144 "Unity.c"
		GeeMapIterator* _tmp2_;
		PlankUnityLauncherEntry* entry = NULL;
		GeeMapIterator* _tmp3_;
		gpointer _tmp4_;
		PlankUnityLauncherEntry* _tmp5_;
#line 283 "../lib/Services/Unity.vala"
		_tmp2_ = launcher_entries_it;
#line 283 "../lib/Services/Unity.vala"
		if (!gee_map_iterator_next (_tmp2_)) {
#line 283 "../lib/Services/Unity.vala"
			break;
#line 1156 "Unity.c"
		}
#line 284 "../lib/Services/Unity.vala"
		_tmp3_ = launcher_entries_it;
#line 284 "../lib/Services/Unity.vala"
		_tmp4_ = gee_map_iterator_get_value (_tmp3_);
#line 284 "../lib/Services/Unity.vala"
		entry = (PlankUnityLauncherEntry*) _tmp4_;
#line 285 "../lib/Services/Unity.vala"
		_tmp5_ = entry;
#line 285 "../lib/Services/Unity.vala"
		if ((current_time - _tmp5_->last_update) > ((gint64) ((10 * PLANK_UNITY_UPDATE_THRESHOLD_DURATION) * 1000))) {
#line 1168 "Unity.c"
			GeeMapIterator* _tmp6_;
#line 286 "../lib/Services/Unity.vala"
			_tmp6_ = launcher_entries_it;
#line 286 "../lib/Services/Unity.vala"
			gee_map_iterator_unset (_tmp6_);
#line 1174 "Unity.c"
		}
#line 283 "../lib/Services/Unity.vala"
		_plank_unity_launcher_entry_unref0 (entry);
#line 1178 "Unity.c"
	}
#line 289 "../lib/Services/Unity.vala"
	_tmp7_ = self->priv->launcher_entries;
#line 289 "../lib/Services/Unity.vala"
	_tmp8_ = gee_abstract_map_get_size ((GeeAbstractMap*) _tmp7_);
#line 289 "../lib/Services/Unity.vala"
	_tmp9_ = _tmp8_;
#line 289 "../lib/Services/Unity.vala"
	keep_running = _tmp9_ > 0;
#line 290 "../lib/Services/Unity.vala"
	if (!keep_running) {
#line 291 "../lib/Services/Unity.vala"
		self->priv->launcher_entries_timer_id = 0U;
#line 1192 "Unity.c"
	}
#line 293 "../lib/Services/Unity.vala"
	_tmp10_ = self->priv->launcher_entries;
#line 293 "../lib/Services/Unity.vala"
	_tmp11_ = gee_abstract_map_get_size ((GeeAbstractMap*) _tmp10_);
#line 293 "../lib/Services/Unity.vala"
	_tmp12_ = _tmp11_;
#line 293 "../lib/Services/Unity.vala"
	plank_logger_verbose ("[Unity] Keeping %i active LauncherEntries", _tmp12_, NULL);
#line 295 "../lib/Services/Unity.vala"
	result = keep_running;
#line 295 "../lib/Services/Unity.vala"
	_g_object_unref0 (launcher_entries_it);
#line 295 "../lib/Services/Unity.vala"
	return result;
#line 1208 "Unity.c"
}

static Block16Data*
block16_data_ref (Block16Data* _data16_)
{
#line 298 "../lib/Services/Unity.vala"
	g_atomic_int_inc (&_data16_->_ref_count_);
#line 298 "../lib/Services/Unity.vala"
	return _data16_;
#line 1218 "Unity.c"
}

static void
block16_data_unref (void * _userdata_)
{
	Block16Data* _data16_;
	_data16_ = (Block16Data*) _userdata_;
#line 298 "../lib/Services/Unity.vala"
	if (g_atomic_int_dec_and_test (&_data16_->_ref_count_)) {
#line 1228 "Unity.c"
		PlankUnity* self;
#line 298 "../lib/Services/Unity.vala"
		self = _data16_->self;
#line 298 "../lib/Services/Unity.vala"
		_g_free0 (_data16_->sender_name);
#line 298 "../lib/Services/Unity.vala"
		_g_variant_unref0 (_data16_->parameters);
#line 298 "../lib/Services/Unity.vala"
		_g_object_unref0 (self);
#line 298 "../lib/Services/Unity.vala"
		g_slice_free (Block16Data, _data16_);
#line 1240 "Unity.c"
	}
}

static gboolean
__lambda62_ (Block16Data* _data16_,
             PlankUnityClient* client)
{
	PlankUnity* self;
	gboolean result = FALSE;
#line 305 "../lib/Services/Unity.vala"
	self = _data16_->self;
#line 305 "../lib/Services/Unity.vala"
	g_return_val_if_fail (client != NULL, FALSE);
#line 306 "../lib/Services/Unity.vala"
	plank_unity_client_update_launcher_entry (client, _data16_->sender_name, _data16_->parameters, FALSE);
#line 307 "../lib/Services/Unity.vala"
	result = TRUE;
#line 307 "../lib/Services/Unity.vala"
	_g_object_unref0 (client);
#line 307 "../lib/Services/Unity.vala"
	return result;
#line 1262 "Unity.c"
}

static gboolean
___lambda62__gee_forall_func (gpointer g,
                              gpointer self)
{
	gboolean result;
	result = __lambda62_ (self, (PlankUnityClient*) g);
#line 305 "../lib/Services/Unity.vala"
	return result;
#line 1273 "Unity.c"
}

static void
plank_unity_perform_update (PlankUnity* self,
                            const gchar* sender_name,
                            GVariant* parameters)
{
	Block16Data* _data16_;
	gchar* _tmp0_;
	GVariant* _tmp1_;
	const GVariantType* _tmp2_;
	GeeHashSet* _tmp4_;
#line 298 "../lib/Services/Unity.vala"
	g_return_if_fail (self != NULL);
#line 298 "../lib/Services/Unity.vala"
	g_return_if_fail (sender_name != NULL);
#line 298 "../lib/Services/Unity.vala"
	g_return_if_fail (parameters != NULL);
#line 298 "../lib/Services/Unity.vala"
	_data16_ = g_slice_new0 (Block16Data);
#line 298 "../lib/Services/Unity.vala"
	_data16_->_ref_count_ = 1;
#line 298 "../lib/Services/Unity.vala"
	_data16_->self = g_object_ref (self);
#line 298 "../lib/Services/Unity.vala"
	_tmp0_ = g_strdup (sender_name);
#line 298 "../lib/Services/Unity.vala"
	_g_free0 (_data16_->sender_name);
#line 298 "../lib/Services/Unity.vala"
	_data16_->sender_name = _tmp0_;
#line 298 "../lib/Services/Unity.vala"
	_tmp1_ = _g_variant_ref0 (parameters);
#line 298 "../lib/Services/Unity.vala"
	_g_variant_unref0 (_data16_->parameters);
#line 298 "../lib/Services/Unity.vala"
	_data16_->parameters = _tmp1_;
#line 300 "../lib/Services/Unity.vala"
	_tmp2_ = plank_unity_payload_variant_type;
#line 300 "../lib/Services/Unity.vala"
	if (!g_variant_is_of_type (_data16_->parameters, _tmp2_)) {
#line 1314 "Unity.c"
		const gchar* _tmp3_;
#line 301 "../lib/Services/Unity.vala"
		_tmp3_ = g_variant_get_type_string (_data16_->parameters);
#line 301 "../lib/Services/Unity.vala"
		g_warning ("Unity.vala:301: Illegal payload signature '%s' from %s. expected '(sa{" \
"sv})'", _tmp3_, _data16_->sender_name);
#line 302 "../lib/Services/Unity.vala"
		block16_data_unref (_data16_);
#line 302 "../lib/Services/Unity.vala"
		_data16_ = NULL;
#line 302 "../lib/Services/Unity.vala"
		return;
#line 1326 "Unity.c"
	}
#line 305 "../lib/Services/Unity.vala"
	_tmp4_ = self->priv->clients;
#line 305 "../lib/Services/Unity.vala"
	gee_abstract_collection_foreach ((GeeAbstractCollection*) _tmp4_, ___lambda62__gee_forall_func, _data16_);
#line 298 "../lib/Services/Unity.vala"
	block16_data_unref (_data16_);
#line 298 "../lib/Services/Unity.vala"
	_data16_ = NULL;
#line 1336 "Unity.c"
}

static PlankUnityLauncherEntry*
plank_unity_launcher_entry_construct (GType object_type)
{
	PlankUnityLauncherEntry* self = NULL;
#line 49 "../lib/Services/Unity.vala"
	self = (PlankUnityLauncherEntry*) g_type_create_instance (object_type);
#line 49 "../lib/Services/Unity.vala"
	return self;
#line 1347 "Unity.c"
}

static PlankUnityLauncherEntry*
plank_unity_launcher_entry_new (void)
{
#line 49 "../lib/Services/Unity.vala"
	return plank_unity_launcher_entry_construct (PLANK_UNITY_TYPE_LAUNCHER_ENTRY);
#line 1355 "Unity.c"
}

static void
plank_unity_value_launcher_entry_init (GValue* value)
{
#line 49 "../lib/Services/Unity.vala"
	value->data[0].v_pointer = NULL;
#line 1363 "Unity.c"
}

static void
plank_unity_value_launcher_entry_free_value (GValue* value)
{
#line 49 "../lib/Services/Unity.vala"
	if (value->data[0].v_pointer) {
#line 49 "../lib/Services/Unity.vala"
		plank_unity_launcher_entry_unref (value->data[0].v_pointer);
#line 1373 "Unity.c"
	}
}

static void
plank_unity_value_launcher_entry_copy_value (const GValue* src_value,
                                             GValue* dest_value)
{
#line 49 "../lib/Services/Unity.vala"
	if (src_value->data[0].v_pointer) {
#line 49 "../lib/Services/Unity.vala"
		dest_value->data[0].v_pointer = plank_unity_launcher_entry_ref (src_value->data[0].v_pointer);
#line 1385 "Unity.c"
	} else {
#line 49 "../lib/Services/Unity.vala"
		dest_value->data[0].v_pointer = NULL;
#line 1389 "Unity.c"
	}
}

static gpointer
plank_unity_value_launcher_entry_peek_pointer (const GValue* value)
{
#line 49 "../lib/Services/Unity.vala"
	return value->data[0].v_pointer;
#line 1398 "Unity.c"
}

static gchar*
plank_unity_value_launcher_entry_collect_value (GValue* value,
                                                guint n_collect_values,
                                                GTypeCValue* collect_values,
                                                guint collect_flags)
{
#line 49 "../lib/Services/Unity.vala"
	if (collect_values[0].v_pointer) {
#line 1409 "Unity.c"
		PlankUnityLauncherEntry * object;
		object = collect_values[0].v_pointer;
#line 49 "../lib/Services/Unity.vala"
		if (object->parent_instance.g_class == NULL) {
#line 49 "../lib/Services/Unity.vala"
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
#line 1416 "Unity.c"
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
#line 49 "../lib/Services/Unity.vala"
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
#line 1420 "Unity.c"
		}
#line 49 "../lib/Services/Unity.vala"
		value->data[0].v_pointer = plank_unity_launcher_entry_ref (object);
#line 1424 "Unity.c"
	} else {
#line 49 "../lib/Services/Unity.vala"
		value->data[0].v_pointer = NULL;
#line 1428 "Unity.c"
	}
#line 49 "../lib/Services/Unity.vala"
	return NULL;
#line 1432 "Unity.c"
}

static gchar*
plank_unity_value_launcher_entry_lcopy_value (const GValue* value,
                                              guint n_collect_values,
                                              GTypeCValue* collect_values,
                                              guint collect_flags)
{
	PlankUnityLauncherEntry ** object_p;
	object_p = collect_values[0].v_pointer;
#line 49 "../lib/Services/Unity.vala"
	if (!object_p) {
#line 49 "../lib/Services/Unity.vala"
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
#line 1447 "Unity.c"
	}
#line 49 "../lib/Services/Unity.vala"
	if (!value->data[0].v_pointer) {
#line 49 "../lib/Services/Unity.vala"
		*object_p = NULL;
#line 1453 "Unity.c"
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
#line 49 "../lib/Services/Unity.vala"
		*object_p = value->data[0].v_pointer;
#line 1457 "Unity.c"
	} else {
#line 49 "../lib/Services/Unity.vala"
		*object_p = plank_unity_launcher_entry_ref (value->data[0].v_pointer);
#line 1461 "Unity.c"
	}
#line 49 "../lib/Services/Unity.vala"
	return NULL;
#line 1465 "Unity.c"
}

static GParamSpec*
plank_unity_param_spec_launcher_entry (const gchar* name,
                                       const gchar* nick,
                                       const gchar* blurb,
                                       GType object_type,
                                       GParamFlags flags)
{
	PlankUnityParamSpecLauncherEntry* spec;
#line 49 "../lib/Services/Unity.vala"
	g_return_val_if_fail (g_type_is_a (object_type, PLANK_UNITY_TYPE_LAUNCHER_ENTRY), NULL);
#line 49 "../lib/Services/Unity.vala"
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
#line 49 "../lib/Services/Unity.vala"
	G_PARAM_SPEC (spec)->value_type = object_type;
#line 49 "../lib/Services/Unity.vala"
	return G_PARAM_SPEC (spec);
#line 1484 "Unity.c"
}

static gpointer
plank_unity_value_get_launcher_entry (const GValue* value)
{
#line 49 "../lib/Services/Unity.vala"
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, PLANK_UNITY_TYPE_LAUNCHER_ENTRY), NULL);
#line 49 "../lib/Services/Unity.vala"
	return value->data[0].v_pointer;
#line 1494 "Unity.c"
}

static void
plank_unity_value_set_launcher_entry (GValue* value,
                                      gpointer v_object)
{
	PlankUnityLauncherEntry * old;
#line 49 "../lib/Services/Unity.vala"
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, PLANK_UNITY_TYPE_LAUNCHER_ENTRY));
#line 49 "../lib/Services/Unity.vala"
	old = value->data[0].v_pointer;
#line 49 "../lib/Services/Unity.vala"
	if (v_object) {
#line 49 "../lib/Services/Unity.vala"
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, PLANK_UNITY_TYPE_LAUNCHER_ENTRY));
#line 49 "../lib/Services/Unity.vala"
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
#line 49 "../lib/Services/Unity.vala"
		value->data[0].v_pointer = v_object;
#line 49 "../lib/Services/Unity.vala"
		plank_unity_launcher_entry_ref (value->data[0].v_pointer);
#line 1516 "Unity.c"
	} else {
#line 49 "../lib/Services/Unity.vala"
		value->data[0].v_pointer = NULL;
#line 1520 "Unity.c"
	}
#line 49 "../lib/Services/Unity.vala"
	if (old) {
#line 49 "../lib/Services/Unity.vala"
		plank_unity_launcher_entry_unref (old);
#line 1526 "Unity.c"
	}
}

static void
plank_unity_value_take_launcher_entry (GValue* value,
                                       gpointer v_object)
{
	PlankUnityLauncherEntry * old;
#line 49 "../lib/Services/Unity.vala"
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, PLANK_UNITY_TYPE_LAUNCHER_ENTRY));
#line 49 "../lib/Services/Unity.vala"
	old = value->data[0].v_pointer;
#line 49 "../lib/Services/Unity.vala"
	if (v_object) {
#line 49 "../lib/Services/Unity.vala"
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, PLANK_UNITY_TYPE_LAUNCHER_ENTRY));
#line 49 "../lib/Services/Unity.vala"
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
#line 49 "../lib/Services/Unity.vala"
		value->data[0].v_pointer = v_object;
#line 1547 "Unity.c"
	} else {
#line 49 "../lib/Services/Unity.vala"
		value->data[0].v_pointer = NULL;
#line 1551 "Unity.c"
	}
#line 49 "../lib/Services/Unity.vala"
	if (old) {
#line 49 "../lib/Services/Unity.vala"
		plank_unity_launcher_entry_unref (old);
#line 1557 "Unity.c"
	}
}

static void
plank_unity_launcher_entry_class_init (PlankUnityLauncherEntryClass * klass,
                                       gpointer klass_data)
{
#line 49 "../lib/Services/Unity.vala"
	plank_unity_launcher_entry_parent_class = g_type_class_peek_parent (klass);
#line 49 "../lib/Services/Unity.vala"
	((PlankUnityLauncherEntryClass *) klass)->finalize = plank_unity_launcher_entry_finalize;
#line 1569 "Unity.c"
}

static void
plank_unity_launcher_entry_instance_init (PlankUnityLauncherEntry * self,
                                          gpointer klass)
{
#line 51 "../lib/Services/Unity.vala"
	self->fast_count = 0U;
#line 52 "../lib/Services/Unity.vala"
	self->last_update = 0LL;
#line 55 "../lib/Services/Unity.vala"
	self->timer_id = 0U;
#line 56 "../lib/Services/Unity.vala"
	self->warned = FALSE;
#line 49 "../lib/Services/Unity.vala"
	self->ref_count = 1;
#line 1586 "Unity.c"
}

static void
plank_unity_launcher_entry_finalize (PlankUnityLauncherEntry * obj)
{
	PlankUnityLauncherEntry * self;
#line 49 "../lib/Services/Unity.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_UNITY_TYPE_LAUNCHER_ENTRY, PlankUnityLauncherEntry);
#line 49 "../lib/Services/Unity.vala"
	g_signal_handlers_destroy (self);
#line 53 "../lib/Services/Unity.vala"
	_g_free0 (self->sender_name);
#line 54 "../lib/Services/Unity.vala"
	_g_variant_unref0 (self->parameters);
#line 1601 "Unity.c"
}

static GType
plank_unity_launcher_entry_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { plank_unity_value_launcher_entry_init, plank_unity_value_launcher_entry_free_value, plank_unity_value_launcher_entry_copy_value, plank_unity_value_launcher_entry_peek_pointer, "p", plank_unity_value_launcher_entry_collect_value, "p", plank_unity_value_launcher_entry_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (PlankUnityLauncherEntryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_unity_launcher_entry_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankUnityLauncherEntry), 0, (GInstanceInitFunc) plank_unity_launcher_entry_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType plank_unity_launcher_entry_type_id;
	plank_unity_launcher_entry_type_id = g_type_register_fundamental (g_type_fundamental_next (), "PlankUnityLauncherEntry", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return plank_unity_launcher_entry_type_id;
}

static GType
plank_unity_launcher_entry_get_type (void)
{
	static volatile gsize plank_unity_launcher_entry_type_id__volatile = 0;
	if (g_once_init_enter (&plank_unity_launcher_entry_type_id__volatile)) {
		GType plank_unity_launcher_entry_type_id;
		plank_unity_launcher_entry_type_id = plank_unity_launcher_entry_get_type_once ();
		g_once_init_leave (&plank_unity_launcher_entry_type_id__volatile, plank_unity_launcher_entry_type_id);
	}
	return plank_unity_launcher_entry_type_id__volatile;
}

static gpointer
plank_unity_launcher_entry_ref (gpointer instance)
{
	PlankUnityLauncherEntry * self;
	self = instance;
#line 49 "../lib/Services/Unity.vala"
	g_atomic_int_inc (&self->ref_count);
#line 49 "../lib/Services/Unity.vala"
	return instance;
#line 1636 "Unity.c"
}

static void
plank_unity_launcher_entry_unref (gpointer instance)
{
	PlankUnityLauncherEntry * self;
	self = instance;
#line 49 "../lib/Services/Unity.vala"
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
#line 49 "../lib/Services/Unity.vala"
		PLANK_UNITY_LAUNCHER_ENTRY_GET_CLASS (self)->finalize (self);
#line 49 "../lib/Services/Unity.vala"
		g_type_free_instance ((GTypeInstance *) self);
#line 1650 "Unity.c"
	}
}

static GObject *
plank_unity_constructor (GType type,
                         guint n_construct_properties,
                         GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	PlankUnity * self;
	GeeHashSet* _tmp0_;
	GeeHashMap* _tmp1_;
	GDBusConnection* _tmp2_;
#line 156 "../lib/Services/Unity.vala"
	parent_class = G_OBJECT_CLASS (plank_unity_parent_class);
#line 156 "../lib/Services/Unity.vala"
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
#line 156 "../lib/Services/Unity.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_UNITY, PlankUnity);
#line 158 "../lib/Services/Unity.vala"
	_tmp0_ = gee_hash_set_new (PLANK_TYPE_UNITY_CLIENT, (GBoxedCopyFunc) g_object_ref, (GDestroyNotify) g_object_unref, NULL, NULL, NULL, NULL, NULL, NULL);
#line 158 "../lib/Services/Unity.vala"
	_g_object_unref0 (self->priv->clients);
#line 158 "../lib/Services/Unity.vala"
	self->priv->clients = _tmp0_;
#line 159 "../lib/Services/Unity.vala"
	_tmp1_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, PLANK_UNITY_TYPE_LAUNCHER_ENTRY, (GBoxedCopyFunc) plank_unity_launcher_entry_ref, (GDestroyNotify) plank_unity_launcher_entry_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
#line 159 "../lib/Services/Unity.vala"
	_g_object_unref0 (self->priv->launcher_entries);
#line 159 "../lib/Services/Unity.vala"
	self->priv->launcher_entries = _tmp1_;
#line 161 "../lib/Services/Unity.vala"
	plank_unity_acquire_unity_dbus ();
#line 163 "../lib/Services/Unity.vala"
	_tmp2_ = plank_unity_connection;
#line 163 "../lib/Services/Unity.vala"
	if (_tmp2_ != NULL) {
#line 1689 "Unity.c"
		GDBusConnection* _tmp3_;
		GDBusConnection* _tmp4_;
#line 164 "../lib/Services/Unity.vala"
		g_debug ("Unity.vala:164: Initializing LauncherEntry support");
#line 166 "../lib/Services/Unity.vala"
		_tmp3_ = plank_unity_connection;
#line 166 "../lib/Services/Unity.vala"
		self->priv->launcher_entry_dbus_signal_id = g_dbus_connection_signal_subscribe (_tmp3_, NULL, PLANK_UNITY_INTERFACE_NAME, NULL, NULL, NULL, G_DBUS_SIGNAL_FLAGS_NONE, (GDBusSignalCallback) plank_unity_handle_entry_signal, g_object_ref (self), g_object_unref);
#line 168 "../lib/Services/Unity.vala"
		_tmp4_ = plank_unity_connection;
#line 168 "../lib/Services/Unity.vala"
		self->priv->dbus_name_owner_changed_signal_id = g_dbus_connection_signal_subscribe (_tmp4_, "org.freedesktop.DBus", "org.freedesktop.DBus", "NameOwnerChanged", "/org/freedesktop/DBus", NULL, G_DBUS_SIGNAL_FLAGS_NONE, (GDBusSignalCallback) plank_unity_handle_name_owner_changed, g_object_ref (self), g_object_unref);
#line 1702 "Unity.c"
	}
#line 156 "../lib/Services/Unity.vala"
	return obj;
#line 1706 "Unity.c"
}

static void
plank_unity_class_init (PlankUnityClass * klass,
                        gpointer klass_data)
{
	GVariantType* _tmp0_;
#line 47 "../lib/Services/Unity.vala"
	plank_unity_parent_class = g_type_class_peek_parent (klass);
#line 47 "../lib/Services/Unity.vala"
	g_type_class_adjust_private_offset (klass, &PlankUnity_private_offset);
#line 47 "../lib/Services/Unity.vala"
	G_OBJECT_CLASS (klass)->constructor = plank_unity_constructor;
#line 47 "../lib/Services/Unity.vala"
	G_OBJECT_CLASS (klass)->finalize = plank_unity_finalize;
#line 78 "../lib/Services/Unity.vala"
	plank_unity_acquire_unity_dbus ();
#line 79 "../lib/Services/Unity.vala"
	_tmp0_ = g_variant_type_new ("(sa{sv})");
#line 79 "../lib/Services/Unity.vala"
	_g_variant_type_free0 (plank_unity_payload_variant_type);
#line 79 "../lib/Services/Unity.vala"
	plank_unity_payload_variant_type = _tmp0_;
#line 1730 "Unity.c"
}

static void
plank_unity_instance_init (PlankUnity * self,
                           gpointer klass)
{
#line 47 "../lib/Services/Unity.vala"
	self->priv = plank_unity_get_instance_private (self);
#line 146 "../lib/Services/Unity.vala"
	self->priv->launcher_entry_dbus_signal_id = 0U;
#line 147 "../lib/Services/Unity.vala"
	self->priv->dbus_name_owner_changed_signal_id = 0U;
#line 149 "../lib/Services/Unity.vala"
	self->priv->launcher_entries_timer_id = 0U;
#line 1745 "Unity.c"
}

static void
plank_unity_finalize (GObject * obj)
{
	PlankUnity * self;
	GDBusConnection* _tmp0_;
#line 47 "../lib/Services/Unity.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_UNITY, PlankUnity);
#line 175 "../lib/Services/Unity.vala"
	if (self->priv->launcher_entries_timer_id > 0U) {
#line 176 "../lib/Services/Unity.vala"
		g_source_remove (self->priv->launcher_entries_timer_id);
#line 1759 "Unity.c"
	}
#line 178 "../lib/Services/Unity.vala"
	_g_object_unref0 (self->priv->clients);
#line 178 "../lib/Services/Unity.vala"
	self->priv->clients = NULL;
#line 179 "../lib/Services/Unity.vala"
	_g_object_unref0 (self->priv->launcher_entries);
#line 179 "../lib/Services/Unity.vala"
	self->priv->launcher_entries = NULL;
#line 181 "../lib/Services/Unity.vala"
	if (plank_unity_unity_bus_id > 0U) {
#line 182 "../lib/Services/Unity.vala"
		g_bus_unown_name (plank_unity_unity_bus_id);
#line 1773 "Unity.c"
	}
#line 184 "../lib/Services/Unity.vala"
	_tmp0_ = plank_unity_connection;
#line 184 "../lib/Services/Unity.vala"
	if (_tmp0_ != NULL) {
#line 185 "../lib/Services/Unity.vala"
		if (self->priv->launcher_entry_dbus_signal_id > 0U) {
#line 1781 "Unity.c"
			GDBusConnection* _tmp1_;
#line 186 "../lib/Services/Unity.vala"
			_tmp1_ = plank_unity_connection;
#line 186 "../lib/Services/Unity.vala"
			g_dbus_connection_signal_unsubscribe (_tmp1_, self->priv->launcher_entry_dbus_signal_id);
#line 1787 "Unity.c"
		}
#line 187 "../lib/Services/Unity.vala"
		if (self->priv->dbus_name_owner_changed_signal_id > 0U) {
#line 1791 "Unity.c"
			GDBusConnection* _tmp2_;
#line 188 "../lib/Services/Unity.vala"
			_tmp2_ = plank_unity_connection;
#line 188 "../lib/Services/Unity.vala"
			g_dbus_connection_signal_unsubscribe (_tmp2_, self->priv->dbus_name_owner_changed_signal_id);
#line 1797 "Unity.c"
		}
	}
#line 144 "../lib/Services/Unity.vala"
	_g_object_unref0 (self->priv->clients);
#line 148 "../lib/Services/Unity.vala"
	_g_object_unref0 (self->priv->launcher_entries);
#line 47 "../lib/Services/Unity.vala"
	G_OBJECT_CLASS (plank_unity_parent_class)->finalize (obj);
#line 1806 "Unity.c"
}

/**
 * Handle the LauncherEntry DBus interface implemented by applications.
 */
static GType
plank_unity_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankUnityClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_unity_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankUnity), 0, (GInstanceInitFunc) plank_unity_instance_init, NULL };
	GType plank_unity_type_id;
	plank_unity_type_id = g_type_register_static (G_TYPE_OBJECT, "PlankUnity", &g_define_type_info, 0);
	PlankUnity_private_offset = g_type_add_instance_private (plank_unity_type_id, sizeof (PlankUnityPrivate));
	return plank_unity_type_id;
}

GType
plank_unity_get_type (void)
{
	static volatile gsize plank_unity_type_id__volatile = 0;
	if (g_once_init_enter (&plank_unity_type_id__volatile)) {
		GType plank_unity_type_id;
		plank_unity_type_id = plank_unity_get_type_once ();
		g_once_init_leave (&plank_unity_type_id__volatile, plank_unity_type_id);
	}
	return plank_unity_type_id__volatile;
}

