/* Logger.c generated by valac 0.48.17, the Vala compiler
 * generated from Logger.vala, do not modify */

/**/
/*  Copyright (C) 2011 Robert Dyer*/
/*                2015 Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib-object.h>
#include <stdarg.h>
#include <stdio.h>

typedef enum  {
	PLANK_LOG_LEVEL_VERBOSE,
	PLANK_LOG_LEVEL_DEBUG,
	PLANK_LOG_LEVEL_INFO,
	PLANK_LOG_LEVEL_NOTIFY,
	PLANK_LOG_LEVEL_WARN,
	PLANK_LOG_LEVEL_CRITICAL,
	PLANK_LOG_LEVEL_ERROR
} PlankLogLevel;

#define PLANK_TYPE_LOG_LEVEL (plank_log_level_get_type ())
typedef enum  {
	PLANK_CONSOLE_COLOR_BLACK,
	PLANK_CONSOLE_COLOR_RED,
	PLANK_CONSOLE_COLOR_GREEN,
	PLANK_CONSOLE_COLOR_YELLOW,
	PLANK_CONSOLE_COLOR_BLUE,
	PLANK_CONSOLE_COLOR_MAGENTA,
	PLANK_CONSOLE_COLOR_CYAN,
	PLANK_CONSOLE_COLOR_WHITE
} PlankConsoleColor;

#define PLANK_TYPE_CONSOLE_COLOR (plank_console_color_get_type ())

#define PLANK_TYPE_LOGGER (plank_logger_get_type ())
#define PLANK_LOGGER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_LOGGER, PlankLogger))
#define PLANK_LOGGER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_LOGGER, PlankLoggerClass))
#define PLANK_IS_LOGGER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_LOGGER))
#define PLANK_IS_LOGGER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_LOGGER))
#define PLANK_LOGGER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_LOGGER, PlankLoggerClass))

typedef struct _PlankLogger PlankLogger;
typedef struct _PlankLoggerClass PlankLoggerClass;
typedef struct _PlankLoggerPrivate PlankLoggerPrivate;
enum  {
	PLANK_LOGGER_0_PROPERTY,
	PLANK_LOGGER_NUM_PROPERTIES
};
static GParamSpec* plank_logger_properties[PLANK_LOGGER_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_date_time_unref0(var) ((var == NULL) ? NULL : (var = (g_date_time_unref (var), NULL)))

struct _PlankLogger {
	GObject parent_instance;
	PlankLoggerPrivate * priv;
};

struct _PlankLoggerClass {
	GObjectClass parent_class;
};

static gpointer plank_logger_parent_class = NULL;
static PlankLogLevel plank_logger__DisplayLevel;
static PlankLogLevel plank_logger__DisplayLevel = PLANK_LOG_LEVEL_WARN;
static gchar* plank_logger_app_domain;
static gchar* plank_logger_app_domain = NULL;
static GMutex plank_logger_write_mutex;
static GMutex plank_logger_write_mutex = {0};
static GRegex* plank_logger_message_regex;
static GRegex* plank_logger_message_regex = NULL;

GType plank_log_level_get_type (void) G_GNUC_CONST;
G_GNUC_INTERNAL GType plank_console_color_get_type (void) G_GNUC_CONST;
GType plank_logger_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankLogger, g_object_unref)
static PlankLogger* plank_logger_new (void);
static PlankLogger* plank_logger_construct (GType object_type);
void plank_logger_initialize (const gchar* app_name);
static void plank_logger_glib_log_func (const gchar* d,
                                 GLogLevelFlags flags,
                                 const gchar* msg);
static gchar* plank_logger_format_message (const gchar* msg);
void plank_logger_notification (const gchar* msg,
                                const gchar* icon);
static void plank_logger_write (PlankLogLevel level,
                         gchar* msg);
void plank_logger_verbose (const gchar* msg,
                           ...);
static gchar* plank_logger_get_time (void);
PlankLogLevel plank_logger_get_DisplayLevel (void);
static void plank_logger_set_color_for_level (PlankLogLevel level);
static void plank_logger_reset_color (void);
static void plank_logger_set_foreground (PlankConsoleColor color);
static void plank_logger_set_background (PlankConsoleColor color);
static void plank_logger_set_color (PlankConsoleColor color,
                             gboolean isForeground);
void plank_logger_set_DisplayLevel (PlankLogLevel value);
static void plank_logger_finalize (GObject * obj);
static GType plank_logger_get_type_once (void);
static void _vala_plank_logger_get_property (GObject * object,
                                      guint property_id,
                                      GValue * value,
                                      GParamSpec * pspec);
static void _vala_plank_logger_set_property (GObject * object,
                                      guint property_id,
                                      const GValue * value,
                                      GParamSpec * pspec);
static void _vala_array_destroy (gpointer array,
                          gint array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gint array_length,
                       GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

const gchar* PLANK_LOG_LEVEL_TO_STRING[7] = {"VERBOSE", "DEBUG", "INFO", "NOTIFY", "WARN", "CRITICAL", "ERROR"};
static GRegex* _tmp_regex_0 = NULL;

/**
 * Controls what messages show in the console log.
 */
static GType
plank_log_level_get_type_once (void)
{
	static const GEnumValue values[] = {{PLANK_LOG_LEVEL_VERBOSE, "PLANK_LOG_LEVEL_VERBOSE", "verbose"}, {PLANK_LOG_LEVEL_DEBUG, "PLANK_LOG_LEVEL_DEBUG", "debug"}, {PLANK_LOG_LEVEL_INFO, "PLANK_LOG_LEVEL_INFO", "info"}, {PLANK_LOG_LEVEL_NOTIFY, "PLANK_LOG_LEVEL_NOTIFY", "notify"}, {PLANK_LOG_LEVEL_WARN, "PLANK_LOG_LEVEL_WARN", "warn"}, {PLANK_LOG_LEVEL_CRITICAL, "PLANK_LOG_LEVEL_CRITICAL", "critical"}, {PLANK_LOG_LEVEL_ERROR, "PLANK_LOG_LEVEL_ERROR", "error"}, {0, NULL, NULL}};
	GType plank_log_level_type_id;
	plank_log_level_type_id = g_enum_register_static ("PlankLogLevel", values);
	return plank_log_level_type_id;
}

GType
plank_log_level_get_type (void)
{
	static volatile gsize plank_log_level_type_id__volatile = 0;
	if (g_once_init_enter (&plank_log_level_type_id__volatile)) {
		GType plank_log_level_type_id;
		plank_log_level_type_id = plank_log_level_get_type_once ();
		g_once_init_leave (&plank_log_level_type_id__volatile, plank_log_level_type_id);
	}
	return plank_log_level_type_id__volatile;
}

static GType
plank_console_color_get_type_once (void)
{
	static const GEnumValue values[] = {{PLANK_CONSOLE_COLOR_BLACK, "PLANK_CONSOLE_COLOR_BLACK", "black"}, {PLANK_CONSOLE_COLOR_RED, "PLANK_CONSOLE_COLOR_RED", "red"}, {PLANK_CONSOLE_COLOR_GREEN, "PLANK_CONSOLE_COLOR_GREEN", "green"}, {PLANK_CONSOLE_COLOR_YELLOW, "PLANK_CONSOLE_COLOR_YELLOW", "yellow"}, {PLANK_CONSOLE_COLOR_BLUE, "PLANK_CONSOLE_COLOR_BLUE", "blue"}, {PLANK_CONSOLE_COLOR_MAGENTA, "PLANK_CONSOLE_COLOR_MAGENTA", "magenta"}, {PLANK_CONSOLE_COLOR_CYAN, "PLANK_CONSOLE_COLOR_CYAN", "cyan"}, {PLANK_CONSOLE_COLOR_WHITE, "PLANK_CONSOLE_COLOR_WHITE", "white"}, {0, NULL, NULL}};
	GType plank_console_color_type_id;
	plank_console_color_type_id = g_enum_register_static ("PlankConsoleColor", values);
	return plank_console_color_type_id;
}

G_GNUC_INTERNAL GType
plank_console_color_get_type (void)
{
	static volatile gsize plank_console_color_type_id__volatile = 0;
	if (g_once_init_enter (&plank_console_color_type_id__volatile)) {
		GType plank_console_color_type_id;
		plank_console_color_type_id = plank_console_color_get_type_once ();
		g_once_init_leave (&plank_console_color_type_id__volatile, plank_console_color_type_id);
	}
	return plank_console_color_type_id__volatile;
}

static PlankLogger*
plank_logger_construct (GType object_type)
{
	PlankLogger * self = NULL;
#line 94 "../lib/Services/Logger.vala"
	self = (PlankLogger*) g_object_new (object_type, NULL);
#line 94 "../lib/Services/Logger.vala"
	return self;
#line 194 "Logger.c"
}

static PlankLogger*
plank_logger_new (void)
{
#line 94 "../lib/Services/Logger.vala"
	return plank_logger_construct (PLANK_TYPE_LOGGER);
#line 202 "Logger.c"
}

/**
 * Initializes the logger for the application.
 *
 * @param app_name the name of the application
 */
static inline GRegex*
_thread_safe_regex_init (GRegex** re,
                         const gchar * pattern,
                         GRegexCompileFlags compile_flags)
{
#line 107 "../lib/Services/Logger.vala"
	if (g_once_init_enter ((volatile gsize*) re)) {
#line 107 "../lib/Services/Logger.vala"
		GRegex* val = g_regex_new (pattern, compile_flags, 0, NULL);
#line 107 "../lib/Services/Logger.vala"
		g_once_init_leave ((volatile gsize*) re, (gsize) val);
#line 221 "Logger.c"
	}
#line 107 "../lib/Services/Logger.vala"
	return *re;
#line 225 "Logger.c"
}

static gpointer
_g_regex_ref0 (gpointer self)
{
#line 107 "../lib/Services/Logger.vala"
	return self ? g_regex_ref (self) : NULL;
#line 233 "Logger.c"
}

void
plank_logger_initialize (const gchar* app_name)
{
	gchar* _tmp0_;
	GRegex* _tmp1_;
#line 103 "../lib/Services/Logger.vala"
	g_return_if_fail (app_name != NULL);
#line 105 "../lib/Services/Logger.vala"
	_tmp0_ = g_strdup (app_name);
#line 105 "../lib/Services/Logger.vala"
	_g_free0 (plank_logger_app_domain);
#line 105 "../lib/Services/Logger.vala"
	plank_logger_app_domain = _tmp0_;
#line 107 "../lib/Services/Logger.vala"
	_tmp1_ = _g_regex_ref0 (_thread_safe_regex_init (&_tmp_regex_0, "[(]?.*?([^\\/]*?)(\\.2)?\\.vala(:\\d+)[)]?:\\s*(.*)", 0));
#line 107 "../lib/Services/Logger.vala"
	_g_regex_unref0 (plank_logger_message_regex);
#line 107 "../lib/Services/Logger.vala"
	plank_logger_message_regex = _tmp1_;
#line 109 "../lib/Services/Logger.vala"
	g_log_set_default_handler ((GLogFunc) plank_logger_glib_log_func, NULL);
#line 257 "Logger.c"
}

static gchar*
plank_logger_format_message (const gchar* msg)
{
	gboolean _tmp0_ = FALSE;
	GRegex* _tmp1_;
	gchar* _tmp13_;
	gchar* result = NULL;
#line 112 "../lib/Services/Logger.vala"
	g_return_val_if_fail (msg != NULL, NULL);
#line 114 "../lib/Services/Logger.vala"
	_tmp1_ = plank_logger_message_regex;
#line 114 "../lib/Services/Logger.vala"
	if (_tmp1_ != NULL) {
#line 273 "Logger.c"
		GRegex* _tmp2_;
#line 114 "../lib/Services/Logger.vala"
		_tmp2_ = plank_logger_message_regex;
#line 114 "../lib/Services/Logger.vala"
		_tmp0_ = g_regex_match (_tmp2_, msg, 0, NULL);
#line 279 "Logger.c"
	} else {
#line 114 "../lib/Services/Logger.vala"
		_tmp0_ = FALSE;
#line 283 "Logger.c"
	}
#line 114 "../lib/Services/Logger.vala"
	if (_tmp0_) {
#line 287 "Logger.c"
		gchar** parts = NULL;
		GRegex* _tmp3_;
		gchar** _tmp4_;
		gchar** _tmp5_;
		gint parts_length1;
		gint _parts_size_;
		gchar** _tmp6_;
		gint _tmp6__length1;
		const gchar* _tmp7_;
		gchar** _tmp8_;
		gint _tmp8__length1;
		const gchar* _tmp9_;
		gchar** _tmp10_;
		gint _tmp10__length1;
		const gchar* _tmp11_;
		gchar* _tmp12_;
#line 115 "../lib/Services/Logger.vala"
		_tmp3_ = plank_logger_message_regex;
#line 115 "../lib/Services/Logger.vala"
		_tmp5_ = _tmp4_ = g_regex_split (_tmp3_, msg, 0);
#line 115 "../lib/Services/Logger.vala"
		parts = _tmp5_;
#line 115 "../lib/Services/Logger.vala"
		parts_length1 = _vala_array_length (_tmp4_);
#line 115 "../lib/Services/Logger.vala"
		_parts_size_ = parts_length1;
#line 116 "../lib/Services/Logger.vala"
		_tmp6_ = parts;
#line 116 "../lib/Services/Logger.vala"
		_tmp6__length1 = parts_length1;
#line 116 "../lib/Services/Logger.vala"
		_tmp7_ = _tmp6_[1];
#line 116 "../lib/Services/Logger.vala"
		_tmp8_ = parts;
#line 116 "../lib/Services/Logger.vala"
		_tmp8__length1 = parts_length1;
#line 116 "../lib/Services/Logger.vala"
		_tmp9_ = _tmp8_[3];
#line 116 "../lib/Services/Logger.vala"
		_tmp10_ = parts;
#line 116 "../lib/Services/Logger.vala"
		_tmp10__length1 = parts_length1;
#line 116 "../lib/Services/Logger.vala"
		_tmp11_ = _tmp10_[4];
#line 116 "../lib/Services/Logger.vala"
		_tmp12_ = g_strdup_printf ("[%s%s] %s", _tmp7_, _tmp9_, _tmp11_);
#line 116 "../lib/Services/Logger.vala"
		result = _tmp12_;
#line 116 "../lib/Services/Logger.vala"
		parts = (_vala_array_free (parts, parts_length1, (GDestroyNotify) g_free), NULL);
#line 116 "../lib/Services/Logger.vala"
		return result;
#line 340 "Logger.c"
	}
#line 118 "../lib/Services/Logger.vala"
	_tmp13_ = g_strdup (msg);
#line 118 "../lib/Services/Logger.vala"
	result = _tmp13_;
#line 118 "../lib/Services/Logger.vala"
	return result;
#line 348 "Logger.c"
}

/**
 * Displays a log message using libnotify.  Also displays on the console.
 *
 * @param msg the log message to display
 * @param icon the icon to display in the notification
 */
void
plank_logger_notification (const gchar* msg,
                           const gchar* icon)
{
	gchar* _tmp0_;
#line 127 "../lib/Services/Logger.vala"
	g_return_if_fail (msg != NULL);
#line 127 "../lib/Services/Logger.vala"
	g_return_if_fail (icon != NULL);
#line 130 "../lib/Services/Logger.vala"
	_tmp0_ = plank_logger_format_message (msg);
#line 130 "../lib/Services/Logger.vala"
	plank_logger_write (PLANK_LOG_LEVEL_NOTIFY, _tmp0_);
#line 370 "Logger.c"
}

/**
 * Displays a verbose log message to the console.
 *
 * @param msg the log message to display
 */
void
plank_logger_verbose (const gchar* msg,
                      ...)
{
	va_list _tmp0_ = {0};
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
#line 138 "../lib/Services/Logger.vala"
	g_return_if_fail (msg != NULL);
#line 140 "../lib/Services/Logger.vala"
	va_start (_tmp0_, msg);
#line 140 "../lib/Services/Logger.vala"
	_tmp1_ = g_strdup_vprintf (msg, _tmp0_);
#line 140 "../lib/Services/Logger.vala"
	_tmp2_ = _tmp1_;
#line 140 "../lib/Services/Logger.vala"
	_tmp3_ = plank_logger_format_message (_tmp2_);
#line 140 "../lib/Services/Logger.vala"
	plank_logger_write (PLANK_LOG_LEVEL_VERBOSE, _tmp3_);
#line 140 "../lib/Services/Logger.vala"
	_g_free0 (_tmp2_);
#line 140 "../lib/Services/Logger.vala"
	va_end (_tmp0_);
#line 402 "Logger.c"
}

static gchar*
plank_logger_get_time (void)
{
	GDateTime* now = NULL;
	GDateTime* _tmp0_;
	gchar* _tmp1_;
	gchar* result = NULL;
#line 145 "../lib/Services/Logger.vala"
	_tmp0_ = g_date_time_new_now_local ();
#line 145 "../lib/Services/Logger.vala"
	now = _tmp0_;
#line 146 "../lib/Services/Logger.vala"
	_tmp1_ = g_strdup_printf ("%.2d:%.2d:%.2d.%.6d", g_date_time_get_hour (now), g_date_time_get_minute (now), g_date_time_get_second (now), g_date_time_get_microsecond (now));
#line 146 "../lib/Services/Logger.vala"
	result = _tmp1_;
#line 146 "../lib/Services/Logger.vala"
	_g_date_time_unref0 (now);
#line 146 "../lib/Services/Logger.vala"
	return result;
#line 424 "Logger.c"
}

static void
plank_logger_write (PlankLogLevel level,
                    gchar* msg)
{
	PlankLogLevel _tmp0_;
	PlankLogLevel _tmp1_;
	FILE* _tmp2_;
	const gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	FILE* _tmp6_;
#line 149 "../lib/Services/Logger.vala"
	g_return_if_fail (msg != NULL);
#line 151 "../lib/Services/Logger.vala"
	_tmp0_ = plank_logger_get_DisplayLevel ();
#line 151 "../lib/Services/Logger.vala"
	_tmp1_ = _tmp0_;
#line 151 "../lib/Services/Logger.vala"
	if (level < _tmp1_) {
#line 152 "../lib/Services/Logger.vala"
		_g_free0 (msg);
#line 152 "../lib/Services/Logger.vala"
		return;
#line 450 "Logger.c"
	}
#line 154 "../lib/Services/Logger.vala"
	g_mutex_lock (&plank_logger_write_mutex);
#line 156 "../lib/Services/Logger.vala"
	plank_logger_set_color_for_level (level);
#line 157 "../lib/Services/Logger.vala"
	_tmp2_ = stdout;
#line 157 "../lib/Services/Logger.vala"
	_tmp3_ = PLANK_LOG_LEVEL_TO_STRING[level];
#line 157 "../lib/Services/Logger.vala"
	_tmp4_ = plank_logger_get_time ();
#line 157 "../lib/Services/Logger.vala"
	_tmp5_ = _tmp4_;
#line 157 "../lib/Services/Logger.vala"
	fprintf (_tmp2_, "[%s %s]", _tmp3_, _tmp5_);
#line 157 "../lib/Services/Logger.vala"
	_g_free0 (_tmp5_);
#line 159 "../lib/Services/Logger.vala"
	plank_logger_reset_color ();
#line 160 "../lib/Services/Logger.vala"
	_tmp6_ = stdout;
#line 160 "../lib/Services/Logger.vala"
	fprintf (_tmp6_, " %s\n", msg);
#line 162 "../lib/Services/Logger.vala"
	g_mutex_unlock (&plank_logger_write_mutex);
#line 149 "../lib/Services/Logger.vala"
	_g_free0 (msg);
#line 478 "Logger.c"
}

static void
plank_logger_set_color_for_level (PlankLogLevel level)
{
#line 167 "../lib/Services/Logger.vala"
	switch (level) {
#line 167 "../lib/Services/Logger.vala"
		case PLANK_LOG_LEVEL_VERBOSE:
#line 488 "Logger.c"
		{
#line 169 "../lib/Services/Logger.vala"
			plank_logger_set_foreground (PLANK_CONSOLE_COLOR_CYAN);
#line 170 "../lib/Services/Logger.vala"
			break;
#line 494 "Logger.c"
		}
#line 167 "../lib/Services/Logger.vala"
		case PLANK_LOG_LEVEL_DEBUG:
#line 498 "Logger.c"
		{
#line 172 "../lib/Services/Logger.vala"
			plank_logger_set_foreground (PLANK_CONSOLE_COLOR_GREEN);
#line 173 "../lib/Services/Logger.vala"
			break;
#line 504 "Logger.c"
		}
#line 167 "../lib/Services/Logger.vala"
		case PLANK_LOG_LEVEL_INFO:
#line 508 "Logger.c"
		{
#line 175 "../lib/Services/Logger.vala"
			plank_logger_set_foreground (PLANK_CONSOLE_COLOR_BLUE);
#line 176 "../lib/Services/Logger.vala"
			break;
#line 514 "Logger.c"
		}
#line 167 "../lib/Services/Logger.vala"
		case PLANK_LOG_LEVEL_NOTIFY:
#line 518 "Logger.c"
		{
#line 178 "../lib/Services/Logger.vala"
			plank_logger_set_foreground (PLANK_CONSOLE_COLOR_MAGENTA);
#line 179 "../lib/Services/Logger.vala"
			break;
#line 524 "Logger.c"
		}
		default:
#line 167 "../lib/Services/Logger.vala"
		case PLANK_LOG_LEVEL_WARN:
#line 529 "Logger.c"
		{
#line 182 "../lib/Services/Logger.vala"
			plank_logger_set_foreground (PLANK_CONSOLE_COLOR_YELLOW);
#line 183 "../lib/Services/Logger.vala"
			break;
#line 535 "Logger.c"
		}
#line 167 "../lib/Services/Logger.vala"
		case PLANK_LOG_LEVEL_CRITICAL:
#line 539 "Logger.c"
		{
#line 185 "../lib/Services/Logger.vala"
			plank_logger_set_foreground (PLANK_CONSOLE_COLOR_RED);
#line 186 "../lib/Services/Logger.vala"
			break;
#line 545 "Logger.c"
		}
#line 167 "../lib/Services/Logger.vala"
		case PLANK_LOG_LEVEL_ERROR:
#line 549 "Logger.c"
		{
#line 188 "../lib/Services/Logger.vala"
			plank_logger_set_background (PLANK_CONSOLE_COLOR_RED);
#line 189 "../lib/Services/Logger.vala"
			plank_logger_set_foreground (PLANK_CONSOLE_COLOR_WHITE);
#line 190 "../lib/Services/Logger.vala"
			break;
#line 557 "Logger.c"
		}
	}
}

static void
plank_logger_reset_color (void)
{
	FILE* _tmp0_;
#line 196 "../lib/Services/Logger.vala"
	_tmp0_ = stdout;
#line 196 "../lib/Services/Logger.vala"
	fprintf (_tmp0_, "\x001b[0m");
#line 570 "Logger.c"
}

static void
plank_logger_set_foreground (PlankConsoleColor color)
{
#line 201 "../lib/Services/Logger.vala"
	plank_logger_set_color (color, TRUE);
#line 578 "Logger.c"
}

static void
plank_logger_set_background (PlankConsoleColor color)
{
#line 206 "../lib/Services/Logger.vala"
	plank_logger_set_color (color, FALSE);
#line 586 "Logger.c"
}

static void
plank_logger_set_color (PlankConsoleColor color,
                        gboolean isForeground)
{
	PlankConsoleColor color_code = 0;
	FILE* _tmp1_;
	PlankConsoleColor _tmp2_;
#line 211 "../lib/Services/Logger.vala"
	color_code = (color + 30) + 60;
#line 212 "../lib/Services/Logger.vala"
	if (!isForeground) {
#line 600 "Logger.c"
		PlankConsoleColor _tmp0_;
#line 213 "../lib/Services/Logger.vala"
		_tmp0_ = color_code;
#line 213 "../lib/Services/Logger.vala"
		color_code = _tmp0_ + 10;
#line 606 "Logger.c"
	}
#line 214 "../lib/Services/Logger.vala"
	_tmp1_ = stdout;
#line 214 "../lib/Services/Logger.vala"
	_tmp2_ = color_code;
#line 214 "../lib/Services/Logger.vala"
	fprintf (_tmp1_, "\x001b[%dm", (gint) _tmp2_);
#line 614 "Logger.c"
}

static gboolean
string_contains (const gchar* self,
                 const gchar* needle)
{
	gchar* _tmp0_;
	gboolean result = FALSE;
#line 1538 "glib-2.0.vapi"
	g_return_val_if_fail (self != NULL, FALSE);
#line 1538 "glib-2.0.vapi"
	g_return_val_if_fail (needle != NULL, FALSE);
#line 1539 "glib-2.0.vapi"
	_tmp0_ = strstr ((gchar*) self, (gchar*) needle);
#line 1539 "glib-2.0.vapi"
	result = _tmp0_ != NULL;
#line 1539 "glib-2.0.vapi"
	return result;
#line 633 "Logger.c"
}

static gchar*
string_replace (const gchar* self,
                const gchar* old,
                const gchar* replacement)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GError* _inner_error0_ = NULL;
	gchar* result = NULL;
#line 1542 "glib-2.0.vapi"
	g_return_val_if_fail (self != NULL, NULL);
#line 1542 "glib-2.0.vapi"
	g_return_val_if_fail (old != NULL, NULL);
#line 1542 "glib-2.0.vapi"
	g_return_val_if_fail (replacement != NULL, NULL);
#line 1543 "glib-2.0.vapi"
	if ((*((gchar*) self)) == '\0') {
#line 1543 "glib-2.0.vapi"
		_tmp1_ = TRUE;
#line 655 "Logger.c"
	} else {
#line 1543 "glib-2.0.vapi"
		_tmp1_ = (*((gchar*) old)) == '\0';
#line 659 "Logger.c"
	}
#line 1543 "glib-2.0.vapi"
	if (_tmp1_) {
#line 1543 "glib-2.0.vapi"
		_tmp0_ = TRUE;
#line 665 "Logger.c"
	} else {
#line 1543 "glib-2.0.vapi"
		_tmp0_ = g_strcmp0 (old, replacement) == 0;
#line 669 "Logger.c"
	}
#line 1543 "glib-2.0.vapi"
	if (_tmp0_) {
#line 673 "Logger.c"
		gchar* _tmp2_;
#line 1544 "glib-2.0.vapi"
		_tmp2_ = g_strdup (self);
#line 1544 "glib-2.0.vapi"
		result = _tmp2_;
#line 1544 "glib-2.0.vapi"
		return result;
#line 681 "Logger.c"
	}
	{
		GRegex* regex = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_;
		GRegex* _tmp5_;
		GRegex* _tmp6_;
		gchar* _tmp7_ = NULL;
		GRegex* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
#line 1547 "glib-2.0.vapi"
		_tmp3_ = g_regex_escape_string (old, -1);
#line 1547 "glib-2.0.vapi"
		_tmp4_ = _tmp3_;
#line 1547 "glib-2.0.vapi"
		_tmp5_ = g_regex_new (_tmp4_, 0, 0, &_inner_error0_);
#line 1547 "glib-2.0.vapi"
		_tmp6_ = _tmp5_;
#line 1547 "glib-2.0.vapi"
		_g_free0 (_tmp4_);
#line 1547 "glib-2.0.vapi"
		regex = _tmp6_;
#line 1547 "glib-2.0.vapi"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 1547 "glib-2.0.vapi"
			_g_free0 (_tmp7_);
#line 1547 "glib-2.0.vapi"
			_g_regex_unref0 (regex);
#line 1547 "glib-2.0.vapi"
			if (_inner_error0_->domain == G_REGEX_ERROR) {
#line 713 "Logger.c"
				goto __catch0_g_regex_error;
			}
#line 1547 "glib-2.0.vapi"
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 1547 "glib-2.0.vapi"
			g_clear_error (&_inner_error0_);
#line 1547 "glib-2.0.vapi"
			return NULL;
#line 722 "Logger.c"
		}
#line 1548 "glib-2.0.vapi"
		_tmp8_ = regex;
#line 1548 "glib-2.0.vapi"
		_tmp9_ = g_regex_replace_literal (_tmp8_, self, (gssize) -1, 0, replacement, 0, &_inner_error0_);
#line 1548 "glib-2.0.vapi"
		_tmp7_ = _tmp9_;
#line 1548 "glib-2.0.vapi"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 1548 "glib-2.0.vapi"
			_g_free0 (_tmp7_);
#line 1548 "glib-2.0.vapi"
			_g_regex_unref0 (regex);
#line 1548 "glib-2.0.vapi"
			if (_inner_error0_->domain == G_REGEX_ERROR) {
#line 738 "Logger.c"
				goto __catch0_g_regex_error;
			}
#line 1548 "glib-2.0.vapi"
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 1548 "glib-2.0.vapi"
			g_clear_error (&_inner_error0_);
#line 1548 "glib-2.0.vapi"
			return NULL;
#line 747 "Logger.c"
		}
#line 1548 "glib-2.0.vapi"
		_tmp10_ = _tmp7_;
#line 1548 "glib-2.0.vapi"
		_tmp7_ = NULL;
#line 1548 "glib-2.0.vapi"
		result = _tmp10_;
#line 1548 "glib-2.0.vapi"
		_g_free0 (_tmp7_);
#line 1548 "glib-2.0.vapi"
		_g_regex_unref0 (regex);
#line 1548 "glib-2.0.vapi"
		return result;
#line 761 "Logger.c"
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
#line 1546 "glib-2.0.vapi"
		g_clear_error (&_inner_error0_);
#line 1550 "glib-2.0.vapi"
		g_assert_not_reached ();
#line 770 "Logger.c"
	}
	__finally0:
#line 1546 "glib-2.0.vapi"
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 1546 "glib-2.0.vapi"
	g_clear_error (&_inner_error0_);
#line 1546 "glib-2.0.vapi"
	return NULL;
#line 779 "Logger.c"
}

static void
plank_logger_glib_log_func (const gchar* d,
                            GLogLevelFlags flags,
                            const gchar* msg)
{
	gchar* domain = NULL;
	gchar* message = NULL;
	gboolean _tmp2_ = FALSE;
	PlankLogLevel level = 0;
	PlankLogLevel _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
#line 217 "../lib/Services/Logger.vala"
	g_return_if_fail (msg != NULL);
#line 220 "../lib/Services/Logger.vala"
	if (d != NULL) {
#line 798 "Logger.c"
		gchar* _tmp0_;
#line 221 "../lib/Services/Logger.vala"
		_tmp0_ = g_strdup_printf ("[%s] ", d);
#line 221 "../lib/Services/Logger.vala"
		_g_free0 (domain);
#line 221 "../lib/Services/Logger.vala"
		domain = _tmp0_;
#line 806 "Logger.c"
	} else {
		gchar* _tmp1_;
#line 223 "../lib/Services/Logger.vala"
		_tmp1_ = g_strdup ("");
#line 223 "../lib/Services/Logger.vala"
		_g_free0 (domain);
#line 223 "../lib/Services/Logger.vala"
		domain = _tmp1_;
#line 815 "Logger.c"
	}
#line 226 "../lib/Services/Logger.vala"
	if (string_contains (msg, "\n")) {
#line 226 "../lib/Services/Logger.vala"
		_tmp2_ = TRUE;
#line 821 "Logger.c"
	} else {
#line 226 "../lib/Services/Logger.vala"
		_tmp2_ = string_contains (msg, "\r");
#line 825 "Logger.c"
	}
#line 226 "../lib/Services/Logger.vala"
	if (_tmp2_) {
#line 829 "Logger.c"
		const gchar* _tmp3_;
		gchar* _tmp4_;
		gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
#line 227 "../lib/Services/Logger.vala"
		_tmp3_ = domain;
#line 227 "../lib/Services/Logger.vala"
		_tmp4_ = string_replace (msg, "\n", "");
#line 227 "../lib/Services/Logger.vala"
		_tmp5_ = _tmp4_;
#line 227 "../lib/Services/Logger.vala"
		_tmp6_ = string_replace (_tmp5_, "\r", "");
#line 227 "../lib/Services/Logger.vala"
		_tmp7_ = _tmp6_;
#line 227 "../lib/Services/Logger.vala"
		_tmp8_ = g_strdup_printf ("%s%s", _tmp3_, _tmp7_);
#line 227 "../lib/Services/Logger.vala"
		_g_free0 (message);
#line 227 "../lib/Services/Logger.vala"
		message = _tmp8_;
#line 227 "../lib/Services/Logger.vala"
		_g_free0 (_tmp7_);
#line 227 "../lib/Services/Logger.vala"
		_g_free0 (_tmp5_);
#line 856 "Logger.c"
	} else {
		const gchar* _tmp9_;
		gchar* _tmp10_;
#line 229 "../lib/Services/Logger.vala"
		_tmp9_ = domain;
#line 229 "../lib/Services/Logger.vala"
		_tmp10_ = g_strdup_printf ("%s%s", _tmp9_, msg);
#line 229 "../lib/Services/Logger.vala"
		_g_free0 (message);
#line 229 "../lib/Services/Logger.vala"
		message = _tmp10_;
#line 868 "Logger.c"
	}
#line 234 "../lib/Services/Logger.vala"
	flags = flags & G_LOG_LEVEL_MASK;
#line 236 "../lib/Services/Logger.vala"
	switch (flags) {
#line 236 "../lib/Services/Logger.vala"
		case G_LOG_LEVEL_ERROR:
#line 876 "Logger.c"
		{
#line 238 "../lib/Services/Logger.vala"
			level = PLANK_LOG_LEVEL_ERROR;
#line 239 "../lib/Services/Logger.vala"
			break;
#line 882 "Logger.c"
		}
#line 236 "../lib/Services/Logger.vala"
		case G_LOG_LEVEL_CRITICAL:
#line 886 "Logger.c"
		{
#line 241 "../lib/Services/Logger.vala"
			level = PLANK_LOG_LEVEL_CRITICAL;
#line 242 "../lib/Services/Logger.vala"
			break;
#line 892 "Logger.c"
		}
#line 236 "../lib/Services/Logger.vala"
		case G_LOG_LEVEL_INFO:
#line 236 "../lib/Services/Logger.vala"
		case G_LOG_LEVEL_MESSAGE:
#line 898 "Logger.c"
		{
#line 245 "../lib/Services/Logger.vala"
			level = PLANK_LOG_LEVEL_INFO;
#line 246 "../lib/Services/Logger.vala"
			break;
#line 904 "Logger.c"
		}
#line 236 "../lib/Services/Logger.vala"
		case G_LOG_LEVEL_DEBUG:
#line 908 "Logger.c"
		{
#line 248 "../lib/Services/Logger.vala"
			level = PLANK_LOG_LEVEL_DEBUG;
#line 249 "../lib/Services/Logger.vala"
			break;
#line 914 "Logger.c"
		}
		default:
#line 236 "../lib/Services/Logger.vala"
		case G_LOG_LEVEL_WARNING:
#line 919 "Logger.c"
		{
#line 252 "../lib/Services/Logger.vala"
			level = PLANK_LOG_LEVEL_WARN;
#line 253 "../lib/Services/Logger.vala"
			break;
#line 925 "Logger.c"
		}
	}
#line 256 "../lib/Services/Logger.vala"
	_tmp11_ = level;
#line 256 "../lib/Services/Logger.vala"
	_tmp12_ = message;
#line 256 "../lib/Services/Logger.vala"
	_tmp13_ = plank_logger_format_message (_tmp12_);
#line 256 "../lib/Services/Logger.vala"
	plank_logger_write (_tmp11_, _tmp13_);
#line 217 "../lib/Services/Logger.vala"
	_g_free0 (message);
#line 217 "../lib/Services/Logger.vala"
	_g_free0 (domain);
#line 940 "Logger.c"
}

PlankLogLevel
plank_logger_get_DisplayLevel (void)
{
	PlankLogLevel result;
	PlankLogLevel _tmp0_;
#line 88 "../lib/Services/Logger.vala"
	_tmp0_ = plank_logger__DisplayLevel;
#line 88 "../lib/Services/Logger.vala"
	result = _tmp0_;
#line 88 "../lib/Services/Logger.vala"
	return result;
#line 954 "Logger.c"
}

void
plank_logger_set_DisplayLevel (PlankLogLevel value)
{
#line 88 "../lib/Services/Logger.vala"
	plank_logger__DisplayLevel = value;
#line 962 "Logger.c"
}

static void
plank_logger_class_init (PlankLoggerClass * klass,
                         gpointer klass_data)
{
#line 83 "../lib/Services/Logger.vala"
	plank_logger_parent_class = g_type_class_peek_parent (klass);
#line 83 "../lib/Services/Logger.vala"
	G_OBJECT_CLASS (klass)->get_property = _vala_plank_logger_get_property;
#line 83 "../lib/Services/Logger.vala"
	G_OBJECT_CLASS (klass)->set_property = _vala_plank_logger_set_property;
#line 83 "../lib/Services/Logger.vala"
	G_OBJECT_CLASS (klass)->finalize = plank_logger_finalize;
#line 977 "Logger.c"
}

static void
plank_logger_instance_init (PlankLogger * self,
                            gpointer klass)
{
}

static void
plank_logger_finalize (GObject * obj)
{
	PlankLogger * self;
#line 83 "../lib/Services/Logger.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_LOGGER, PlankLogger);
#line 83 "../lib/Services/Logger.vala"
	G_OBJECT_CLASS (plank_logger_parent_class)->finalize (obj);
#line 994 "Logger.c"
}

/**
 * A logging class to display all console messages in a nice colored format.
 */
static GType
plank_logger_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankLoggerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_logger_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankLogger), 0, (GInstanceInitFunc) plank_logger_instance_init, NULL };
	GType plank_logger_type_id;
	plank_logger_type_id = g_type_register_static (G_TYPE_OBJECT, "PlankLogger", &g_define_type_info, 0);
	return plank_logger_type_id;
}

GType
plank_logger_get_type (void)
{
	static volatile gsize plank_logger_type_id__volatile = 0;
	if (g_once_init_enter (&plank_logger_type_id__volatile)) {
		GType plank_logger_type_id;
		plank_logger_type_id = plank_logger_get_type_once ();
		g_once_init_leave (&plank_logger_type_id__volatile, plank_logger_type_id);
	}
	return plank_logger_type_id__volatile;
}

static void
_vala_plank_logger_get_property (GObject * object,
                                 guint property_id,
                                 GValue * value,
                                 GParamSpec * pspec)
{
	PlankLogger * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_LOGGER, PlankLogger);
#line 83 "../lib/Services/Logger.vala"
	switch (property_id) {
#line 1031 "Logger.c"
		default:
#line 83 "../lib/Services/Logger.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 83 "../lib/Services/Logger.vala"
		break;
#line 1037 "Logger.c"
	}
}

static void
_vala_plank_logger_set_property (GObject * object,
                                 guint property_id,
                                 const GValue * value,
                                 GParamSpec * pspec)
{
	PlankLogger * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, PLANK_TYPE_LOGGER, PlankLogger);
#line 83 "../lib/Services/Logger.vala"
	switch (property_id) {
#line 1051 "Logger.c"
		default:
#line 83 "../lib/Services/Logger.vala"
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
#line 83 "../lib/Services/Logger.vala"
		break;
#line 1057 "Logger.c"
	}
}

static void
_vala_array_destroy (gpointer array,
                     gint array_length,
                     GDestroyNotify destroy_func)
{
#line 114 "../lib/Services/EnvironmentSettings.vala"
	if ((array != NULL) && (destroy_func != NULL)) {
#line 1068 "Logger.c"
		gint i;
#line 114 "../lib/Services/EnvironmentSettings.vala"
		for (i = 0; i < array_length; i = i + 1) {
#line 114 "../lib/Services/EnvironmentSettings.vala"
			if (((gpointer*) array)[i] != NULL) {
#line 114 "../lib/Services/EnvironmentSettings.vala"
				destroy_func (((gpointer*) array)[i]);
#line 1076 "Logger.c"
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gint array_length,
                  GDestroyNotify destroy_func)
{
#line 114 "../lib/Services/EnvironmentSettings.vala"
	_vala_array_destroy (array, array_length, destroy_func);
#line 114 "../lib/Services/EnvironmentSettings.vala"
	g_free (array);
#line 1091 "Logger.c"
}

static gint
_vala_array_length (gpointer array)
{
	gint length;
	length = 0;
#line 114 "../lib/Services/EnvironmentSettings.vala"
	if (array) {
#line 114 "../lib/Services/EnvironmentSettings.vala"
		while (((gpointer*) array)[length]) {
#line 114 "../lib/Services/EnvironmentSettings.vala"
			length++;
#line 1105 "Logger.c"
		}
	}
#line 114 "../lib/Services/EnvironmentSettings.vala"
	return length;
#line 1110 "Logger.c"
}

