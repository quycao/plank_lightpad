/* Worker.c generated by valac 0.48.17, the Vala compiler
 * generated from Worker.vala, do not modify */

/**/
/*  Copyright (C) 2015 Rico Tzschichholz*/
/**/
/*  This file is part of Plank.*/
/**/
/*  Plank is free software: you can redistribute it and/or modify*/
/*  it under the terms of the GNU General Public License as published by*/
/*  the Free Software Foundation, either version 3 of the License, or*/
/*  (at your option) any later version.*/
/**/
/*  Plank is distributed in the hope that it will be useful,*/
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of*/
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the*/
/*  GNU General Public License for more details.*/
/**/
/*  You should have received a copy of the GNU General Public License*/
/*  along with this program.  If not, see <http://www.gnu.org/licenses/>.*/
/**/

#include <glib-object.h>
#include <glib.h>
#include <gio/gio.h>

typedef enum  {
	PLANK_TASK_PRIORITY_LOW,
	PLANK_TASK_PRIORITY_DEFAULT,
	PLANK_TASK_PRIORITY_HIGH
} PlankTaskPriority;

#define PLANK_TYPE_TASK_PRIORITY (plank_task_priority_get_type ())
typedef gpointer (*PlankTaskFunc) (gpointer user_data, GError** error);
typedef struct _PlankTask PlankTask;

#define PLANK_TYPE_WORKER (plank_worker_get_type ())
#define PLANK_WORKER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), PLANK_TYPE_WORKER, PlankWorker))
#define PLANK_WORKER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), PLANK_TYPE_WORKER, PlankWorkerClass))
#define PLANK_IS_WORKER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), PLANK_TYPE_WORKER))
#define PLANK_IS_WORKER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), PLANK_TYPE_WORKER))
#define PLANK_WORKER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), PLANK_TYPE_WORKER, PlankWorkerClass))

typedef struct _PlankWorker PlankWorker;
typedef struct _PlankWorkerClass PlankWorkerClass;
typedef struct _PlankWorkerPrivate PlankWorkerPrivate;
enum  {
	PLANK_WORKER_0_PROPERTY,
	PLANK_WORKER_NUM_PROPERTIES
};
static GParamSpec* plank_worker_properties[PLANK_WORKER_NUM_PROPERTIES];
#define _g_thread_pool_free0(var) ((var == NULL) ? NULL : (var = (g_thread_pool_free (var, FALSE, TRUE), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _Block17Data Block17Data;
typedef struct _PlankWorkerAddTaskWithResultData PlankWorkerAddTaskWithResultData;
#define _plank_task_free0(var) ((var == NULL) ? NULL : (var = (plank_task_free (var), NULL)))

struct _PlankTask {
	GThreadFunc func;
	gpointer func_target;
	PlankTaskPriority priority;
};

struct _PlankWorker {
	GObject parent_instance;
	PlankWorkerPrivate * priv;
};

struct _PlankWorkerClass {
	GObjectClass parent_class;
};

struct _PlankWorkerPrivate {
	GThreadPool* pool;
};

struct _Block17Data {
	int _ref_count_;
	PlankWorker* self;
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	GSourceFunc resume;
	gpointer resume_target;
	GDestroyNotify resume_target_destroy_notify;
	GError* err;
	gpointer _result_;
	PlankTaskFunc func;
	gpointer func_target;
	GDestroyNotify func_target_destroy_notify;
	gpointer _async_data_;
};

struct _PlankWorkerAddTaskWithResultData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	PlankWorker* self;
	PlankTaskFunc func;
	gpointer func_target;
	GDestroyNotify func_target_destroy_notify;
	PlankTaskPriority priority;
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	gpointer result;
	Block17Data* _data17_;
	GThreadFunc tfunc;
	gpointer tfunc_target;
	GThreadPool* _tmp0_;
	GThreadFunc _tmp1_;
	gpointer _tmp1__target;
	PlankTask* _tmp2_;
	GError* e;
	GError* _tmp3_;
	const gchar* _tmp4_;
	GError* _tmp5_;
	GError* _tmp6_;
	GError* _tmp7_;
	gconstpointer _tmp8_;
	gpointer _tmp9_;
	GError* _inner_error0_;
};

static gint PlankWorker_private_offset;
static gpointer plank_worker_parent_class = NULL;
static PlankWorker* plank_worker_worker;
static PlankWorker* plank_worker_worker = NULL;

GType plank_task_priority_get_type (void) G_GNUC_CONST;
G_GNUC_INTERNAL void plank_task_free (PlankTask * self);
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankTask, plank_task_free)
static void plank_task_instance_init (PlankTask * self);
G_GNUC_INTERNAL PlankTask* plank_task_new (GThreadFunc _func,
                           gpointer _func_target,
                           PlankTaskPriority _priority);
G_GNUC_INTERNAL void* plank_task_run (PlankTask* self);
GType plank_worker_get_type (void) G_GNUC_CONST;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (PlankWorker, g_object_unref)
PlankWorker* plank_worker_get_default (void);
static PlankWorker* plank_worker_new (void);
static PlankWorker* plank_worker_construct (GType object_type);
static gint plank_worker_compare_task_priority (PlankTask* t1,
                                         PlankTask* t2);
void plank_worker_add_task (PlankWorker* self,
                            GThreadFunc func,
                            gpointer func_target,
                            PlankTaskPriority priority);
static void plank_worker_add_task_with_result_data_free (gpointer _data);
void plank_worker_add_task_with_result (PlankWorker* self,
                                        GType g_type,
                                        GBoxedCopyFunc g_dup_func,
                                        GDestroyNotify g_destroy_func,
                                        PlankTaskFunc func,
                                        gpointer func_target,
                                        GDestroyNotify func_target_destroy_notify,
                                        PlankTaskPriority priority,
                                        GAsyncReadyCallback _callback_,
                                        gpointer _user_data_);
gpointer plank_worker_add_task_with_result_finish (PlankWorker* self,
                                                   GAsyncResult* _res_,
                                                   GError** error);
static gboolean plank_worker_add_task_with_result_co (PlankWorkerAddTaskWithResultData* _data_);
static Block17Data* block17_data_ref (Block17Data* _data17_);
static void block17_data_unref (void * _userdata_);
static gboolean _plank_worker_add_task_with_result_co_gsource_func (gpointer self);
static gpointer ___lambda65_ (Block17Data* _data17_);
static gpointer ____lambda65__gthread_func (gpointer self);
static GObject * plank_worker_constructor (GType type,
                                    guint n_construct_properties,
                                    GObjectConstructParam * construct_properties);
static void _plank_worker____lambda66_ (PlankWorker* self,
                                 PlankTask* task);
static void __plank_worker____lambda66__gfunc (gpointer data,
                                        gpointer self);
static void plank_worker_finalize (GObject * obj);
static GType plank_worker_get_type_once (void);

static GType
plank_task_priority_get_type_once (void)
{
	static const GEnumValue values[] = {{PLANK_TASK_PRIORITY_LOW, "PLANK_TASK_PRIORITY_LOW", "low"}, {PLANK_TASK_PRIORITY_DEFAULT, "PLANK_TASK_PRIORITY_DEFAULT", "default"}, {PLANK_TASK_PRIORITY_HIGH, "PLANK_TASK_PRIORITY_HIGH", "high"}, {0, NULL, NULL}};
	GType plank_task_priority_type_id;
	plank_task_priority_type_id = g_enum_register_static ("PlankTaskPriority", values);
	return plank_task_priority_type_id;
}

GType
plank_task_priority_get_type (void)
{
	static volatile gsize plank_task_priority_type_id__volatile = 0;
	if (g_once_init_enter (&plank_task_priority_type_id__volatile)) {
		GType plank_task_priority_type_id;
		plank_task_priority_type_id = plank_task_priority_get_type_once ();
		g_once_init_leave (&plank_task_priority_type_id__volatile, plank_task_priority_type_id);
	}
	return plank_task_priority_type_id__volatile;
}

G_GNUC_INTERNAL PlankTask*
plank_task_new (GThreadFunc _func,
                gpointer _func_target,
                PlankTaskPriority _priority)
{
	PlankTask* self;
#line 36 "../lib/Services/Worker.vala"
	self = g_slice_new0 (PlankTask);
#line 36 "../lib/Services/Worker.vala"
	plank_task_instance_init (self);
#line 38 "../lib/Services/Worker.vala"
	self->func = _func;
#line 38 "../lib/Services/Worker.vala"
	self->func_target = _func_target;
#line 39 "../lib/Services/Worker.vala"
	self->priority = _priority;
#line 36 "../lib/Services/Worker.vala"
	return self;
#line 221 "Worker.c"
}

G_GNUC_INTERNAL void*
plank_task_run (PlankTask* self)
{
	GThreadFunc _tmp0_;
	gpointer _tmp0__target;
	gpointer _tmp1_;
	void* result = NULL;
#line 42 "../lib/Services/Worker.vala"
	g_return_val_if_fail (self != NULL, NULL);
#line 44 "../lib/Services/Worker.vala"
	_tmp0_ = self->func;
#line 44 "../lib/Services/Worker.vala"
	_tmp0__target = self->func_target;
#line 44 "../lib/Services/Worker.vala"
	_tmp1_ = _tmp0_ (_tmp0__target);
#line 44 "../lib/Services/Worker.vala"
	result = _tmp1_;
#line 44 "../lib/Services/Worker.vala"
	return result;
#line 243 "Worker.c"
}

static void
plank_task_instance_init (PlankTask * self)
{
}

G_GNUC_INTERNAL void
plank_task_free (PlankTask * self)
{
#line 31 "../lib/Services/Worker.vala"
	g_slice_free (PlankTask, self);
#line 256 "Worker.c"
}

static inline gpointer
plank_worker_get_instance_private (PlankWorker* self)
{
	return G_STRUCT_MEMBER_P (self, PlankWorker_private_offset);
}

PlankWorker*
plank_worker_get_default (void)
{
	PlankWorker* _tmp0_;
	PlankWorker* _tmp2_;
	PlankWorker* result = NULL;
#line 54 "../lib/Services/Worker.vala"
	_tmp0_ = plank_worker_worker;
#line 54 "../lib/Services/Worker.vala"
	if (_tmp0_ == NULL) {
#line 275 "Worker.c"
		PlankWorker* _tmp1_;
#line 55 "../lib/Services/Worker.vala"
		_tmp1_ = plank_worker_new ();
#line 55 "../lib/Services/Worker.vala"
		_g_object_unref0 (plank_worker_worker);
#line 55 "../lib/Services/Worker.vala"
		plank_worker_worker = _tmp1_;
#line 283 "Worker.c"
	}
#line 56 "../lib/Services/Worker.vala"
	_tmp2_ = plank_worker_worker;
#line 56 "../lib/Services/Worker.vala"
	result = _tmp2_;
#line 56 "../lib/Services/Worker.vala"
	return result;
#line 291 "Worker.c"
}

static PlankWorker*
plank_worker_construct (GType object_type)
{
	PlankWorker * self = NULL;
#line 61 "../lib/Services/Worker.vala"
	self = (PlankWorker*) g_object_new (object_type, NULL);
#line 61 "../lib/Services/Worker.vala"
	return self;
#line 302 "Worker.c"
}

static PlankWorker*
plank_worker_new (void)
{
#line 61 "../lib/Services/Worker.vala"
	return plank_worker_construct (PLANK_TYPE_WORKER);
#line 310 "Worker.c"
}

static gint
plank_worker_compare_task_priority (PlankTask* t1,
                                    PlankTask* t2)
{
	gint p1 = 0;
	PlankTaskPriority _tmp0_;
	gint p2 = 0;
	PlankTaskPriority _tmp1_;
	gint _tmp2_ = 0;
	gint result = 0;
#line 83 "../lib/Services/Worker.vala"
	g_return_val_if_fail (t1 != NULL, 0);
#line 83 "../lib/Services/Worker.vala"
	g_return_val_if_fail (t2 != NULL, 0);
#line 85 "../lib/Services/Worker.vala"
	_tmp0_ = t1->priority;
#line 85 "../lib/Services/Worker.vala"
	p1 = (gint) _tmp0_;
#line 85 "../lib/Services/Worker.vala"
	_tmp1_ = t2->priority;
#line 85 "../lib/Services/Worker.vala"
	p2 = (gint) _tmp1_;
#line 86 "../lib/Services/Worker.vala"
	if (p1 < p2) {
#line 86 "../lib/Services/Worker.vala"
		_tmp2_ = -1;
#line 339 "Worker.c"
	} else {
#line 86 "../lib/Services/Worker.vala"
		_tmp2_ = (gint) (p1 > p2);
#line 343 "Worker.c"
	}
#line 86 "../lib/Services/Worker.vala"
	result = _tmp2_;
#line 86 "../lib/Services/Worker.vala"
	return result;
#line 349 "Worker.c"
}

/**
 * Schedule given function to be run in our ThreadPool
 * The given priority influences execution-time of the task 
 * depending on the currently scheduled amount of tasks.
 *
 * @param func function to be executed
 * @param priority priority of the given function
 */
void
plank_worker_add_task (PlankWorker* self,
                       GThreadFunc func,
                       gpointer func_target,
                       PlankTaskPriority priority)
{
	GError* _inner_error0_ = NULL;
#line 97 "../lib/Services/Worker.vala"
	g_return_if_fail (self != NULL);
#line 369 "Worker.c"
	{
		GThreadPool* _tmp0_;
		PlankTask* _tmp1_;
#line 100 "../lib/Services/Worker.vala"
		_tmp0_ = self->priv->pool;
#line 100 "../lib/Services/Worker.vala"
		_tmp1_ = plank_task_new (func, func_target, priority);
#line 100 "../lib/Services/Worker.vala"
		g_thread_pool_push (_tmp0_, _tmp1_, &_inner_error0_);
#line 100 "../lib/Services/Worker.vala"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 100 "../lib/Services/Worker.vala"
			if (_inner_error0_->domain == G_THREAD_ERROR) {
#line 383 "Worker.c"
				goto __catch0_g_thread_error;
			}
#line 100 "../lib/Services/Worker.vala"
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 100 "../lib/Services/Worker.vala"
			g_clear_error (&_inner_error0_);
#line 100 "../lib/Services/Worker.vala"
			return;
#line 392 "Worker.c"
		}
	}
	goto __finally0;
	__catch0_g_thread_error:
	{
		GError* e = NULL;
		GError* _tmp2_;
		const gchar* _tmp3_;
#line 99 "../lib/Services/Worker.vala"
		e = _inner_error0_;
#line 99 "../lib/Services/Worker.vala"
		_inner_error0_ = NULL;
#line 102 "../lib/Services/Worker.vala"
		_tmp2_ = e;
#line 102 "../lib/Services/Worker.vala"
		_tmp3_ = _tmp2_->message;
#line 102 "../lib/Services/Worker.vala"
		g_warning ("Worker.vala:102: %s", _tmp3_);
#line 99 "../lib/Services/Worker.vala"
		_g_error_free0 (e);
#line 413 "Worker.c"
	}
	__finally0:
#line 99 "../lib/Services/Worker.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 99 "../lib/Services/Worker.vala"
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 99 "../lib/Services/Worker.vala"
		g_clear_error (&_inner_error0_);
#line 99 "../lib/Services/Worker.vala"
		return;
#line 424 "Worker.c"
	}
}

static void
plank_worker_add_task_with_result_data_free (gpointer _data)
{
	PlankWorkerAddTaskWithResultData* _data_;
	_data_ = _data;
#line 48 "../lib/Services/Worker.vala"
	((_data_->result == NULL) || (_data_->g_destroy_func == NULL)) ? NULL : (_data_->result = (_data_->g_destroy_func (_data_->result), NULL));
#line 48 "../lib/Services/Worker.vala"
	_g_object_unref0 (_data_->self);
#line 48 "../lib/Services/Worker.vala"
	g_slice_free (PlankWorkerAddTaskWithResultData, _data_);
#line 439 "Worker.c"
}

static gpointer
_g_object_ref0 (gpointer self)
{
#line 48 "../lib/Services/Worker.vala"
	return self ? g_object_ref (self) : NULL;
#line 447 "Worker.c"
}

void
plank_worker_add_task_with_result (PlankWorker* self,
                                   GType g_type,
                                   GBoxedCopyFunc g_dup_func,
                                   GDestroyNotify g_destroy_func,
                                   PlankTaskFunc func,
                                   gpointer func_target,
                                   GDestroyNotify func_target_destroy_notify,
                                   PlankTaskPriority priority,
                                   GAsyncReadyCallback _callback_,
                                   gpointer _user_data_)
{
	PlankWorkerAddTaskWithResultData* _data_;
	PlankWorker* _tmp0_;
#line 48 "../lib/Services/Worker.vala"
	_data_ = g_slice_new0 (PlankWorkerAddTaskWithResultData);
#line 48 "../lib/Services/Worker.vala"
	_data_->_async_result = g_task_new (G_OBJECT (self), NULL, _callback_, _user_data_);
#line 48 "../lib/Services/Worker.vala"
	g_task_set_task_data (_data_->_async_result, _data_, plank_worker_add_task_with_result_data_free);
#line 48 "../lib/Services/Worker.vala"
	_tmp0_ = _g_object_ref0 (self);
#line 48 "../lib/Services/Worker.vala"
	_data_->self = _tmp0_;
#line 48 "../lib/Services/Worker.vala"
	(_data_->func_target_destroy_notify == NULL) ? NULL : (_data_->func_target_destroy_notify (_data_->func_target), NULL);
#line 48 "../lib/Services/Worker.vala"
	_data_->func = NULL;
#line 48 "../lib/Services/Worker.vala"
	_data_->func_target = NULL;
#line 48 "../lib/Services/Worker.vala"
	_data_->func_target_destroy_notify = NULL;
#line 48 "../lib/Services/Worker.vala"
	_data_->func = func;
#line 48 "../lib/Services/Worker.vala"
	_data_->func_target = func_target;
#line 48 "../lib/Services/Worker.vala"
	_data_->func_target_destroy_notify = func_target_destroy_notify;
#line 48 "../lib/Services/Worker.vala"
	_data_->priority = priority;
#line 48 "../lib/Services/Worker.vala"
	_data_->g_type = g_type;
#line 48 "../lib/Services/Worker.vala"
	_data_->g_dup_func = g_dup_func;
#line 48 "../lib/Services/Worker.vala"
	_data_->g_destroy_func = g_destroy_func;
#line 48 "../lib/Services/Worker.vala"
	plank_worker_add_task_with_result_co (_data_);
#line 498 "Worker.c"
}

gpointer
plank_worker_add_task_with_result_finish (PlankWorker* self,
                                          GAsyncResult* _res_,
                                          GError** error)
{
	gpointer result;
	PlankWorkerAddTaskWithResultData* _data_;
#line 48 "../lib/Services/Worker.vala"
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
#line 48 "../lib/Services/Worker.vala"
	if (NULL == _data_) {
#line 48 "../lib/Services/Worker.vala"
		return NULL;
#line 514 "Worker.c"
	}
#line 48 "../lib/Services/Worker.vala"
	result = _data_->result;
#line 48 "../lib/Services/Worker.vala"
	_data_->result = NULL;
#line 48 "../lib/Services/Worker.vala"
	return result;
#line 522 "Worker.c"
}

/**
 * Schedule given function to be run in our ThreadPool
 * The given priority influences execution-time of the task 
 * depending on the currently scheduled amount of tasks.
 *
 * AsyncReadyCallback will be executed on the main-thread through an idle
 * with GLib.Priority.HIGH_IDLE.
 *
 * @param func the function to be executed returning a typed result
 * @param priority priority of the given function
 * @return the typed result
 */
static Block17Data*
block17_data_ref (Block17Data* _data17_)
{
#line 118 "../lib/Services/Worker.vala"
	g_atomic_int_inc (&_data17_->_ref_count_);
#line 118 "../lib/Services/Worker.vala"
	return _data17_;
#line 544 "Worker.c"
}

static void
block17_data_unref (void * _userdata_)
{
	Block17Data* _data17_;
	_data17_ = (Block17Data*) _userdata_;
#line 118 "../lib/Services/Worker.vala"
	if (g_atomic_int_dec_and_test (&_data17_->_ref_count_)) {
#line 554 "Worker.c"
		PlankWorker* self;
		GType g_type;
		GBoxedCopyFunc g_dup_func;
		GDestroyNotify g_destroy_func;
#line 118 "../lib/Services/Worker.vala"
		self = _data17_->self;
#line 118 "../lib/Services/Worker.vala"
		g_type = _data17_->g_type;
#line 118 "../lib/Services/Worker.vala"
		g_dup_func = _data17_->g_dup_func;
#line 118 "../lib/Services/Worker.vala"
		g_destroy_func = _data17_->g_destroy_func;
#line 118 "../lib/Services/Worker.vala"
		((_data17_->_result_ == NULL) || (g_destroy_func == NULL)) ? NULL : (_data17_->_result_ = (g_destroy_func (_data17_->_result_), NULL));
#line 118 "../lib/Services/Worker.vala"
		_g_error_free0 (_data17_->err);
#line 118 "../lib/Services/Worker.vala"
		(_data17_->resume_target_destroy_notify == NULL) ? NULL : (_data17_->resume_target_destroy_notify (_data17_->resume_target), NULL);
#line 118 "../lib/Services/Worker.vala"
		_data17_->resume = NULL;
#line 118 "../lib/Services/Worker.vala"
		_data17_->resume_target = NULL;
#line 118 "../lib/Services/Worker.vala"
		_data17_->resume_target_destroy_notify = NULL;
#line 118 "../lib/Services/Worker.vala"
		(_data17_->func_target_destroy_notify == NULL) ? NULL : (_data17_->func_target_destroy_notify (_data17_->func_target), NULL);
#line 118 "../lib/Services/Worker.vala"
		_data17_->func = NULL;
#line 118 "../lib/Services/Worker.vala"
		_data17_->func_target = NULL;
#line 118 "../lib/Services/Worker.vala"
		_data17_->func_target_destroy_notify = NULL;
#line 118 "../lib/Services/Worker.vala"
		_g_object_unref0 (self);
#line 118 "../lib/Services/Worker.vala"
		g_slice_free (Block17Data, _data17_);
#line 591 "Worker.c"
	}
}

static gboolean
_plank_worker_add_task_with_result_co_gsource_func (gpointer self)
{
	gboolean result;
	result = plank_worker_add_task_with_result_co (self);
#line 120 "../lib/Services/Worker.vala"
	return result;
#line 602 "Worker.c"
}

static gpointer
_g_error_copy0 (gpointer self)
{
#line 129 "../lib/Services/Worker.vala"
	return self ? g_error_copy (self) : NULL;
#line 610 "Worker.c"
}

static gpointer
___lambda65_ (Block17Data* _data17_)
{
	PlankWorker* self;
	GType g_type;
	GBoxedCopyFunc g_dup_func;
	GDestroyNotify g_destroy_func;
	GSourceFunc _tmp5_;
	gpointer _tmp5__target;
	GDestroyNotify _tmp5__target_destroy_notify;
	GError* _inner_error0_ = NULL;
	gpointer result = NULL;
#line 125 "../lib/Services/Worker.vala"
	self = _data17_->self;
#line 125 "../lib/Services/Worker.vala"
	g_type = _data17_->g_type;
#line 125 "../lib/Services/Worker.vala"
	g_dup_func = _data17_->g_dup_func;
#line 125 "../lib/Services/Worker.vala"
	g_destroy_func = _data17_->g_destroy_func;
#line 633 "Worker.c"
	{
		gpointer _tmp0_ = NULL;
		gpointer _tmp1_;
		gpointer _tmp2_;
#line 127 "../lib/Services/Worker.vala"
		_tmp1_ = _data17_->func (_data17_->func_target, &_inner_error0_);
#line 127 "../lib/Services/Worker.vala"
		_tmp0_ = _tmp1_;
#line 127 "../lib/Services/Worker.vala"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 644 "Worker.c"
			goto __catch0_g_error;
		}
#line 127 "../lib/Services/Worker.vala"
		_tmp2_ = _tmp0_;
#line 127 "../lib/Services/Worker.vala"
		_tmp0_ = NULL;
#line 127 "../lib/Services/Worker.vala"
		((_data17_->_result_ == NULL) || (g_destroy_func == NULL)) ? NULL : (_data17_->_result_ = (g_destroy_func (_data17_->_result_), NULL));
#line 127 "../lib/Services/Worker.vala"
		_data17_->_result_ = _tmp2_;
#line 126 "../lib/Services/Worker.vala"
		((_tmp0_ == NULL) || (g_destroy_func == NULL)) ? NULL : (_tmp0_ = (g_destroy_func (_tmp0_), NULL));
#line 657 "Worker.c"
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp3_;
		GError* _tmp4_;
#line 126 "../lib/Services/Worker.vala"
		e = _inner_error0_;
#line 126 "../lib/Services/Worker.vala"
		_inner_error0_ = NULL;
#line 129 "../lib/Services/Worker.vala"
		_tmp3_ = e;
#line 129 "../lib/Services/Worker.vala"
		_tmp4_ = _g_error_copy0 (_tmp3_);
#line 129 "../lib/Services/Worker.vala"
		_g_error_free0 (_data17_->err);
#line 129 "../lib/Services/Worker.vala"
		_data17_->err = _tmp4_;
#line 126 "../lib/Services/Worker.vala"
		_g_error_free0 (e);
#line 679 "Worker.c"
	}
	__finally0:
#line 126 "../lib/Services/Worker.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 126 "../lib/Services/Worker.vala"
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 126 "../lib/Services/Worker.vala"
		g_clear_error (&_inner_error0_);
#line 126 "../lib/Services/Worker.vala"
		return NULL;
#line 690 "Worker.c"
	}
#line 132 "../lib/Services/Worker.vala"
	_tmp5_ = _data17_->resume;
#line 132 "../lib/Services/Worker.vala"
	_tmp5__target = _data17_->resume_target;
#line 132 "../lib/Services/Worker.vala"
	_tmp5__target_destroy_notify = _data17_->resume_target_destroy_notify;
#line 132 "../lib/Services/Worker.vala"
	_data17_->resume = NULL;
#line 132 "../lib/Services/Worker.vala"
	_data17_->resume_target = NULL;
#line 132 "../lib/Services/Worker.vala"
	_data17_->resume_target_destroy_notify = NULL;
#line 132 "../lib/Services/Worker.vala"
	g_idle_add_full (G_PRIORITY_HIGH_IDLE, _tmp5_, _tmp5__target, _tmp5__target_destroy_notify);
#line 133 "../lib/Services/Worker.vala"
	result = NULL;
#line 133 "../lib/Services/Worker.vala"
	return result;
#line 710 "Worker.c"
}

static gpointer
____lambda65__gthread_func (gpointer self)
{
	gpointer result;
	result = ___lambda65_ (self);
#line 125 "../lib/Services/Worker.vala"
	block17_data_unref (self);
#line 125 "../lib/Services/Worker.vala"
	return result;
#line 722 "Worker.c"
}

static gboolean
plank_worker_add_task_with_result_co (PlankWorkerAddTaskWithResultData* _data_)
{
#line 118 "../lib/Services/Worker.vala"
	switch (_data_->_state_) {
#line 118 "../lib/Services/Worker.vala"
		case 0:
#line 732 "Worker.c"
		goto _state_0;
#line 118 "../lib/Services/Worker.vala"
		case 1:
#line 736 "Worker.c"
		goto _state_1;
		default:
#line 118 "../lib/Services/Worker.vala"
		g_assert_not_reached ();
#line 741 "Worker.c"
	}
	_state_0:
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_ = g_slice_new0 (Block17Data);
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_->_ref_count_ = 1;
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_->self = g_object_ref (_data_->self);
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_->g_type = _data_->g_type;
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_->g_dup_func = _data_->g_dup_func;
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_->g_destroy_func = _data_->g_destroy_func;
#line 118 "../lib/Services/Worker.vala"
	(_data_->_data17_->func_target_destroy_notify == NULL) ? NULL : (_data_->_data17_->func_target_destroy_notify (_data_->_data17_->func_target), NULL);
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_->func = NULL;
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_->func_target = NULL;
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_->func_target_destroy_notify = NULL;
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_->func = _data_->func;
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_->func_target = _data_->func_target;
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_->func_target_destroy_notify = _data_->func_target_destroy_notify;
#line 118 "../lib/Services/Worker.vala"
	_data_->_data17_->_async_data_ = _data_;
#line 120 "../lib/Services/Worker.vala"
	_data_->_data17_->resume = _plank_worker_add_task_with_result_co_gsource_func;
#line 120 "../lib/Services/Worker.vala"
	_data_->_data17_->resume_target = _data_;
#line 120 "../lib/Services/Worker.vala"
	_data_->_data17_->resume_target_destroy_notify = NULL;
#line 121 "../lib/Services/Worker.vala"
	_data_->_data17_->err = NULL;
#line 122 "../lib/Services/Worker.vala"
	_data_->_data17_->_result_ = NULL;
#line 782 "Worker.c"
	{
#line 125 "../lib/Services/Worker.vala"
		_data_->tfunc = ____lambda65__gthread_func;
#line 125 "../lib/Services/Worker.vala"
		_data_->tfunc_target = block17_data_ref (_data_->_data17_);
#line 135 "../lib/Services/Worker.vala"
		_data_->_tmp0_ = _data_->self->priv->pool;
#line 135 "../lib/Services/Worker.vala"
		_data_->_tmp1_ = _data_->tfunc;
#line 135 "../lib/Services/Worker.vala"
		_data_->_tmp1__target = _data_->tfunc_target;
#line 135 "../lib/Services/Worker.vala"
		_data_->_tmp2_ = plank_task_new (_data_->_tmp1_, _data_->_tmp1__target, _data_->priority);
#line 135 "../lib/Services/Worker.vala"
		g_thread_pool_push (_data_->_tmp0_, _data_->_tmp2_, &_data_->_inner_error0_);
#line 135 "../lib/Services/Worker.vala"
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
#line 135 "../lib/Services/Worker.vala"
			if (_data_->_inner_error0_->domain == G_THREAD_ERROR) {
#line 802 "Worker.c"
				goto __catch0_g_thread_error;
			}
#line 135 "../lib/Services/Worker.vala"
			block17_data_unref (_data_->_data17_);
#line 135 "../lib/Services/Worker.vala"
			_data_->_data17_ = NULL;
#line 135 "../lib/Services/Worker.vala"
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
#line 135 "../lib/Services/Worker.vala"
			g_clear_error (&_data_->_inner_error0_);
#line 135 "../lib/Services/Worker.vala"
			g_object_unref (_data_->_async_result);
#line 135 "../lib/Services/Worker.vala"
			return FALSE;
#line 817 "Worker.c"
		}
	}
	goto __finally0;
	__catch0_g_thread_error:
	{
#line 124 "../lib/Services/Worker.vala"
		_data_->e = _data_->_inner_error0_;
#line 124 "../lib/Services/Worker.vala"
		_data_->_inner_error0_ = NULL;
#line 137 "../lib/Services/Worker.vala"
		_data_->_tmp3_ = _data_->e;
#line 137 "../lib/Services/Worker.vala"
		_data_->_tmp4_ = _data_->_tmp3_->message;
#line 137 "../lib/Services/Worker.vala"
		g_warning ("Worker.vala:137: %s", _data_->_tmp4_);
#line 124 "../lib/Services/Worker.vala"
		_g_error_free0 (_data_->e);
#line 835 "Worker.c"
	}
	__finally0:
#line 124 "../lib/Services/Worker.vala"
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
#line 124 "../lib/Services/Worker.vala"
		g_task_return_error (_data_->_async_result, _data_->_inner_error0_);
#line 124 "../lib/Services/Worker.vala"
		block17_data_unref (_data_->_data17_);
#line 124 "../lib/Services/Worker.vala"
		_data_->_data17_ = NULL;
#line 124 "../lib/Services/Worker.vala"
		g_object_unref (_data_->_async_result);
#line 124 "../lib/Services/Worker.vala"
		return FALSE;
#line 850 "Worker.c"
	}
#line 140 "../lib/Services/Worker.vala"
	_data_->_state_ = 1;
#line 140 "../lib/Services/Worker.vala"
	return FALSE;
#line 856 "Worker.c"
	_state_1:
	;
#line 141 "../lib/Services/Worker.vala"
	_data_->_tmp5_ = _data_->_data17_->err;
#line 141 "../lib/Services/Worker.vala"
	if (_data_->_tmp5_ != NULL) {
#line 142 "../lib/Services/Worker.vala"
		_data_->_tmp6_ = _data_->_data17_->err;
#line 142 "../lib/Services/Worker.vala"
		_data_->_tmp7_ = _g_error_copy0 (_data_->_tmp6_);
#line 142 "../lib/Services/Worker.vala"
		_data_->_inner_error0_ = _data_->_tmp7_;
#line 142 "../lib/Services/Worker.vala"
		g_task_return_error (_data_->_async_result, _data_->_inner_error0_);
#line 142 "../lib/Services/Worker.vala"
		block17_data_unref (_data_->_data17_);
#line 142 "../lib/Services/Worker.vala"
		_data_->_data17_ = NULL;
#line 142 "../lib/Services/Worker.vala"
		g_object_unref (_data_->_async_result);
#line 142 "../lib/Services/Worker.vala"
		return FALSE;
#line 879 "Worker.c"
	}
#line 144 "../lib/Services/Worker.vala"
	_data_->_tmp8_ = _data_->_data17_->_result_;
#line 144 "../lib/Services/Worker.vala"
	_data_->_tmp9_ = ((_data_->_tmp8_ != NULL) && (_data_->g_dup_func != NULL)) ? _data_->g_dup_func ((gpointer) _data_->_tmp8_) : ((gpointer) _data_->_tmp8_);
#line 144 "../lib/Services/Worker.vala"
	_data_->result = _data_->_tmp9_;
#line 144 "../lib/Services/Worker.vala"
	block17_data_unref (_data_->_data17_);
#line 144 "../lib/Services/Worker.vala"
	_data_->_data17_ = NULL;
#line 144 "../lib/Services/Worker.vala"
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
#line 144 "../lib/Services/Worker.vala"
	if (_data_->_state_ != 0) {
#line 144 "../lib/Services/Worker.vala"
		while (!g_task_get_completed (_data_->_async_result)) {
#line 144 "../lib/Services/Worker.vala"
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
#line 899 "Worker.c"
		}
	}
#line 144 "../lib/Services/Worker.vala"
	g_object_unref (_data_->_async_result);
#line 144 "../lib/Services/Worker.vala"
	return FALSE;
#line 906 "Worker.c"
}

static void
_plank_worker____lambda66_ (PlankWorker* self,
                            PlankTask* task)
{
#line 73 "../lib/Services/Worker.vala"
	g_return_if_fail (task != NULL);
#line 74 "../lib/Services/Worker.vala"
	plank_task_run (task);
#line 73 "../lib/Services/Worker.vala"
	_plank_task_free0 (task);
#line 919 "Worker.c"
}

static void
__plank_worker____lambda66__gfunc (gpointer data,
                                   gpointer self)
{
#line 73 "../lib/Services/Worker.vala"
	_plank_worker____lambda66_ ((PlankWorker*) self, (PlankTask*) data);
#line 928 "Worker.c"
}

static GObject *
plank_worker_constructor (GType type,
                          guint n_construct_properties,
                          GObjectConstructParam * construct_properties)
{
	GObject * obj;
	GObjectClass * parent_class;
	PlankWorker * self;
	GError* _inner_error0_ = NULL;
#line 65 "../lib/Services/Worker.vala"
	parent_class = G_OBJECT_CLASS (plank_worker_parent_class);
#line 65 "../lib/Services/Worker.vala"
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
#line 65 "../lib/Services/Worker.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_WORKER, PlankWorker);
#line 946 "Worker.c"
	{
		gint thread_count = 0;
		GThreadPool* _tmp0_ = NULL;
		GThreadPool* _tmp1_;
		GThreadPool* _tmp2_;
		GThreadPool* _tmp3_;
#line 68 "../lib/Services/Worker.vala"
		g_thread_pool_set_max_unused_threads (0);
#line 70 "../lib/Services/Worker.vala"
		thread_count = (gint) g_get_num_processors ();
#line 71 "../lib/Services/Worker.vala"
		g_message ("Worker.vala:71: Using up to %i threads.", thread_count);
#line 73 "../lib/Services/Worker.vala"
		_tmp1_ = g_thread_pool_new (__plank_worker____lambda66__gfunc, self, thread_count, FALSE, &_inner_error0_);
#line 73 "../lib/Services/Worker.vala"
		_tmp0_ = _tmp1_;
#line 73 "../lib/Services/Worker.vala"
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 73 "../lib/Services/Worker.vala"
			if (_inner_error0_->domain == G_THREAD_ERROR) {
#line 967 "Worker.c"
				goto __catch0_g_thread_error;
			}
#line 73 "../lib/Services/Worker.vala"
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 73 "../lib/Services/Worker.vala"
			g_clear_error (&_inner_error0_);
#line 974 "Worker.c"
		}
#line 73 "../lib/Services/Worker.vala"
		_tmp2_ = _tmp0_;
#line 73 "../lib/Services/Worker.vala"
		_tmp0_ = NULL;
#line 73 "../lib/Services/Worker.vala"
		_g_thread_pool_free0 (self->priv->pool);
#line 73 "../lib/Services/Worker.vala"
		self->priv->pool = _tmp2_;
#line 77 "../lib/Services/Worker.vala"
		_tmp3_ = self->priv->pool;
#line 77 "../lib/Services/Worker.vala"
		g_thread_pool_set_sort_function (_tmp3_, (GCompareDataFunc) plank_worker_compare_task_priority, NULL);
#line 67 "../lib/Services/Worker.vala"
		_g_thread_pool_free0 (_tmp0_);
#line 990 "Worker.c"
	}
	goto __finally0;
	__catch0_g_thread_error:
	{
		GError* e = NULL;
		GError* _tmp4_;
		const gchar* _tmp5_;
#line 67 "../lib/Services/Worker.vala"
		e = _inner_error0_;
#line 67 "../lib/Services/Worker.vala"
		_inner_error0_ = NULL;
#line 79 "../lib/Services/Worker.vala"
		_tmp4_ = e;
#line 79 "../lib/Services/Worker.vala"
		_tmp5_ = _tmp4_->message;
#line 79 "../lib/Services/Worker.vala"
		g_error ("Worker.vala:79: Creating ThreadPool failed! (%s)", _tmp5_);
#line 67 "../lib/Services/Worker.vala"
		_g_error_free0 (e);
#line 1010 "Worker.c"
	}
	__finally0:
#line 67 "../lib/Services/Worker.vala"
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
#line 67 "../lib/Services/Worker.vala"
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
#line 67 "../lib/Services/Worker.vala"
		g_clear_error (&_inner_error0_);
#line 1019 "Worker.c"
	}
#line 65 "../lib/Services/Worker.vala"
	return obj;
#line 1023 "Worker.c"
}

static void
plank_worker_class_init (PlankWorkerClass * klass,
                         gpointer klass_data)
{
#line 48 "../lib/Services/Worker.vala"
	plank_worker_parent_class = g_type_class_peek_parent (klass);
#line 48 "../lib/Services/Worker.vala"
	g_type_class_adjust_private_offset (klass, &PlankWorker_private_offset);
#line 48 "../lib/Services/Worker.vala"
	G_OBJECT_CLASS (klass)->constructor = plank_worker_constructor;
#line 48 "../lib/Services/Worker.vala"
	G_OBJECT_CLASS (klass)->finalize = plank_worker_finalize;
#line 1038 "Worker.c"
}

static void
plank_worker_instance_init (PlankWorker * self,
                            gpointer klass)
{
#line 48 "../lib/Services/Worker.vala"
	self->priv = plank_worker_get_instance_private (self);
#line 1047 "Worker.c"
}

static void
plank_worker_finalize (GObject * obj)
{
	PlankWorker * self;
#line 48 "../lib/Services/Worker.vala"
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, PLANK_TYPE_WORKER, PlankWorker);
#line 59 "../lib/Services/Worker.vala"
	_g_thread_pool_free0 (self->priv->pool);
#line 48 "../lib/Services/Worker.vala"
	G_OBJECT_CLASS (plank_worker_parent_class)->finalize (obj);
#line 1060 "Worker.c"
}

static GType
plank_worker_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (PlankWorkerClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) plank_worker_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (PlankWorker), 0, (GInstanceInitFunc) plank_worker_instance_init, NULL };
	GType plank_worker_type_id;
	plank_worker_type_id = g_type_register_static (G_TYPE_OBJECT, "PlankWorker", &g_define_type_info, 0);
	PlankWorker_private_offset = g_type_add_instance_private (plank_worker_type_id, sizeof (PlankWorkerPrivate));
	return plank_worker_type_id;
}

GType
plank_worker_get_type (void)
{
	static volatile gsize plank_worker_type_id__volatile = 0;
	if (g_once_init_enter (&plank_worker_type_id__volatile)) {
		GType plank_worker_type_id;
		plank_worker_type_id = plank_worker_get_type_once ();
		g_once_init_leave (&plank_worker_type_id__volatile, plank_worker_type_id);
	}
	return plank_worker_type_id__volatile;
}

